// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: netrc_handler.go

package mock

import (
	sync "sync"

	github_com_confluentinc_cli_internal_pkg_netrc "github.com/confluentinc/cli/internal/pkg/netrc"
)

// MockNetrcHandler is a mock of NetrcHandler interface
type MockNetrcHandler struct {
	lockWriteNetrcCredentials sync.Mutex
	WriteNetrcCredentialsFunc func(isCloud bool, ctxName, username, password string) error

	lockRemoveNetrcCredentials sync.Mutex
	RemoveNetrcCredentialsFunc func(isCloud bool, ctxName string) (string, error)

	lockCheckCredentialExist sync.Mutex
	CheckCredentialExistFunc func(isCloud bool, ctxName string) (bool, error)

	lockGetMatchingNetrcMachine sync.Mutex
	GetMatchingNetrcMachineFunc func(params github_com_confluentinc_cli_internal_pkg_netrc.NetrcMachineParams) (*github_com_confluentinc_cli_internal_pkg_netrc.Machine, error)

	lockGetFileName sync.Mutex
	GetFileNameFunc func() string

	calls struct {
		WriteNetrcCredentials []struct {
			IsCloud  bool
			CtxName  string
			Username string
			Password string
		}
		RemoveNetrcCredentials []struct {
			IsCloud bool
			CtxName string
		}
		CheckCredentialExist []struct {
			IsCloud bool
			CtxName string
		}
		GetMatchingNetrcMachine []struct {
			Params github_com_confluentinc_cli_internal_pkg_netrc.NetrcMachineParams
		}
		GetFileName []struct {
		}
	}
}

// WriteNetrcCredentials mocks base method by wrapping the associated func.
func (m *MockNetrcHandler) WriteNetrcCredentials(isCloud bool, ctxName, username, password string) error {
	m.lockWriteNetrcCredentials.Lock()
	defer m.lockWriteNetrcCredentials.Unlock()

	if m.WriteNetrcCredentialsFunc == nil {
		panic("mocker: MockNetrcHandler.WriteNetrcCredentialsFunc is nil but MockNetrcHandler.WriteNetrcCredentials was called.")
	}

	call := struct {
		IsCloud  bool
		CtxName  string
		Username string
		Password string
	}{
		IsCloud:  isCloud,
		CtxName:  ctxName,
		Username: username,
		Password: password,
	}

	m.calls.WriteNetrcCredentials = append(m.calls.WriteNetrcCredentials, call)

	return m.WriteNetrcCredentialsFunc(isCloud, ctxName, username, password)
}

// WriteNetrcCredentialsCalled returns true if WriteNetrcCredentials was called at least once.
func (m *MockNetrcHandler) WriteNetrcCredentialsCalled() bool {
	m.lockWriteNetrcCredentials.Lock()
	defer m.lockWriteNetrcCredentials.Unlock()

	return len(m.calls.WriteNetrcCredentials) > 0
}

// WriteNetrcCredentialsCalls returns the calls made to WriteNetrcCredentials.
func (m *MockNetrcHandler) WriteNetrcCredentialsCalls() []struct {
	IsCloud  bool
	CtxName  string
	Username string
	Password string
} {
	m.lockWriteNetrcCredentials.Lock()
	defer m.lockWriteNetrcCredentials.Unlock()

	return m.calls.WriteNetrcCredentials
}

// RemoveNetrcCredentials mocks base method by wrapping the associated func.
func (m *MockNetrcHandler) RemoveNetrcCredentials(isCloud bool, ctxName string) (string, error) {
	m.lockRemoveNetrcCredentials.Lock()
	defer m.lockRemoveNetrcCredentials.Unlock()

	if m.RemoveNetrcCredentialsFunc == nil {
		panic("mocker: MockNetrcHandler.RemoveNetrcCredentialsFunc is nil but MockNetrcHandler.RemoveNetrcCredentials was called.")
	}

	call := struct {
		IsCloud bool
		CtxName string
	}{
		IsCloud: isCloud,
		CtxName: ctxName,
	}

	m.calls.RemoveNetrcCredentials = append(m.calls.RemoveNetrcCredentials, call)

	return m.RemoveNetrcCredentialsFunc(isCloud, ctxName)
}

// RemoveNetrcCredentialsCalled returns true if RemoveNetrcCredentials was called at least once.
func (m *MockNetrcHandler) RemoveNetrcCredentialsCalled() bool {
	m.lockRemoveNetrcCredentials.Lock()
	defer m.lockRemoveNetrcCredentials.Unlock()

	return len(m.calls.RemoveNetrcCredentials) > 0
}

// RemoveNetrcCredentialsCalls returns the calls made to RemoveNetrcCredentials.
func (m *MockNetrcHandler) RemoveNetrcCredentialsCalls() []struct {
	IsCloud bool
	CtxName string
} {
	m.lockRemoveNetrcCredentials.Lock()
	defer m.lockRemoveNetrcCredentials.Unlock()

	return m.calls.RemoveNetrcCredentials
}

// CheckCredentialExist mocks base method by wrapping the associated func.
func (m *MockNetrcHandler) CheckCredentialExist(isCloud bool, ctxName string) (bool, error) {
	m.lockCheckCredentialExist.Lock()
	defer m.lockCheckCredentialExist.Unlock()

	if m.CheckCredentialExistFunc == nil {
		panic("mocker: MockNetrcHandler.CheckCredentialExistFunc is nil but MockNetrcHandler.CheckCredentialExist was called.")
	}

	call := struct {
		IsCloud bool
		CtxName string
	}{
		IsCloud: isCloud,
		CtxName: ctxName,
	}

	m.calls.CheckCredentialExist = append(m.calls.CheckCredentialExist, call)

	return m.CheckCredentialExistFunc(isCloud, ctxName)
}

// CheckCredentialExistCalled returns true if CheckCredentialExist was called at least once.
func (m *MockNetrcHandler) CheckCredentialExistCalled() bool {
	m.lockCheckCredentialExist.Lock()
	defer m.lockCheckCredentialExist.Unlock()

	return len(m.calls.CheckCredentialExist) > 0
}

// CheckCredentialExistCalls returns the calls made to CheckCredentialExist.
func (m *MockNetrcHandler) CheckCredentialExistCalls() []struct {
	IsCloud bool
	CtxName string
} {
	m.lockCheckCredentialExist.Lock()
	defer m.lockCheckCredentialExist.Unlock()

	return m.calls.CheckCredentialExist
}

// GetMatchingNetrcMachine mocks base method by wrapping the associated func.
func (m *MockNetrcHandler) GetMatchingNetrcMachine(params github_com_confluentinc_cli_internal_pkg_netrc.NetrcMachineParams) (*github_com_confluentinc_cli_internal_pkg_netrc.Machine, error) {
	m.lockGetMatchingNetrcMachine.Lock()
	defer m.lockGetMatchingNetrcMachine.Unlock()

	if m.GetMatchingNetrcMachineFunc == nil {
		panic("mocker: MockNetrcHandler.GetMatchingNetrcMachineFunc is nil but MockNetrcHandler.GetMatchingNetrcMachine was called.")
	}

	call := struct {
		Params github_com_confluentinc_cli_internal_pkg_netrc.NetrcMachineParams
	}{
		Params: params,
	}

	m.calls.GetMatchingNetrcMachine = append(m.calls.GetMatchingNetrcMachine, call)

	return m.GetMatchingNetrcMachineFunc(params)
}

// GetMatchingNetrcMachineCalled returns true if GetMatchingNetrcMachine was called at least once.
func (m *MockNetrcHandler) GetMatchingNetrcMachineCalled() bool {
	m.lockGetMatchingNetrcMachine.Lock()
	defer m.lockGetMatchingNetrcMachine.Unlock()

	return len(m.calls.GetMatchingNetrcMachine) > 0
}

// GetMatchingNetrcMachineCalls returns the calls made to GetMatchingNetrcMachine.
func (m *MockNetrcHandler) GetMatchingNetrcMachineCalls() []struct {
	Params github_com_confluentinc_cli_internal_pkg_netrc.NetrcMachineParams
} {
	m.lockGetMatchingNetrcMachine.Lock()
	defer m.lockGetMatchingNetrcMachine.Unlock()

	return m.calls.GetMatchingNetrcMachine
}

// GetFileName mocks base method by wrapping the associated func.
func (m *MockNetrcHandler) GetFileName() string {
	m.lockGetFileName.Lock()
	defer m.lockGetFileName.Unlock()

	if m.GetFileNameFunc == nil {
		panic("mocker: MockNetrcHandler.GetFileNameFunc is nil but MockNetrcHandler.GetFileName was called.")
	}

	call := struct {
	}{}

	m.calls.GetFileName = append(m.calls.GetFileName, call)

	return m.GetFileNameFunc()
}

// GetFileNameCalled returns true if GetFileName was called at least once.
func (m *MockNetrcHandler) GetFileNameCalled() bool {
	m.lockGetFileName.Lock()
	defer m.lockGetFileName.Unlock()

	return len(m.calls.GetFileName) > 0
}

// GetFileNameCalls returns the calls made to GetFileName.
func (m *MockNetrcHandler) GetFileNameCalls() []struct {
} {
	m.lockGetFileName.Lock()
	defer m.lockGetFileName.Unlock()

	return m.calls.GetFileName
}

// Reset resets the calls made to the mocked methods.
func (m *MockNetrcHandler) Reset() {
	m.lockWriteNetrcCredentials.Lock()
	m.calls.WriteNetrcCredentials = nil
	m.lockWriteNetrcCredentials.Unlock()
	m.lockRemoveNetrcCredentials.Lock()
	m.calls.RemoveNetrcCredentials = nil
	m.lockRemoveNetrcCredentials.Unlock()
	m.lockCheckCredentialExist.Lock()
	m.calls.CheckCredentialExist = nil
	m.lockCheckCredentialExist.Unlock()
	m.lockGetMatchingNetrcMachine.Lock()
	m.calls.GetMatchingNetrcMachine = nil
	m.lockGetMatchingNetrcMachine.Unlock()
	m.lockGetFileName.Lock()
	m.calls.GetFileName = nil
	m.lockGetFileName.Unlock()
}
