// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: netrc_handler.go

package mock

import (
	sync "sync"

	github_com_confluentinc_cli_internal_pkg_netrc "github.com/confluentinc/cli/internal/pkg/netrc"
)

// MockNetrcHandler is a mock of NetrcHandler interface
type MockNetrcHandler struct {
	lockWriteNetrcCredentials   sync.Mutex
	WriteNetrcCredentialsFunc   func(cliName string, isSSO bool, ctxName, username, password string) error
	RemoveNetrcCredentialsFunc  func(cliName string, ctxName string) (string, error)
	CheckCredentialExistFunc    func(cliName string, ctxName string) (bool, error)
	lockGetMatchingNetrcMachine sync.Mutex
	GetMatchingNetrcMachineFunc func(params github_com_confluentinc_cli_internal_pkg_netrc.GetMatchingNetrcMachineParams) (*github_com_confluentinc_cli_internal_pkg_netrc.Machine, error)

	lockGetFileName sync.Mutex
	GetFileNameFunc func() string

	calls struct {
		WriteNetrcCredentials []struct {
			CliName  string
			IsSSO    bool
			CtxName  string
			Username string
			Password string
		}
		RemoveNetrcCredentials []struct {
			CliName string
			CtxName string
		}
		CheckCredentialExist []struct {
			CliName string
			CtxName string
		}
		GetMatchingNetrcMachine []struct {
			Params github_com_confluentinc_cli_internal_pkg_netrc.GetMatchingNetrcMachineParams
		}
		GetFileName []struct {
		}
	}
}

// WriteNetrcCredentials mocks base method by wrapping the associated func.
func (m *MockNetrcHandler) WriteNetrcCredentials(cliName string, isSSO bool, ctxName, username, password string) error {
	m.lockWriteNetrcCredentials.Lock()
	defer m.lockWriteNetrcCredentials.Unlock()

	if m.WriteNetrcCredentialsFunc == nil {
		panic("mocker: MockNetrcHandler.WriteNetrcCredentialsFunc is nil but MockNetrcHandler.WriteNetrcCredentials was called.")
	}

	call := struct {
		CliName  string
		IsSSO    bool
		CtxName  string
		Username string
		Password string
	}{
		CliName:  cliName,
		IsSSO:    isSSO,
		CtxName:  ctxName,
		Username: username,
		Password: password,
	}

	m.calls.WriteNetrcCredentials = append(m.calls.WriteNetrcCredentials, call)

	return m.WriteNetrcCredentialsFunc(cliName, isSSO, ctxName, username, password)
}

func (m *MockNetrcHandler) RemoveNetrcCredentials(cliName string, ctxName string) (string, error) {

	if m.RemoveNetrcCredentialsFunc == nil {
		panic("mocker: MockNetrcHandler.RemoveNetrcCredentialsFunc is nil but MockNetrcHandler.RemoveNetrcCredentials was called.")
	}

	call := struct {
		CliName string
		CtxName string
	}{
		CliName: cliName,
		CtxName: ctxName,
	}

	m.calls.RemoveNetrcCredentials = append(m.calls.RemoveNetrcCredentials, call)

	return m.RemoveNetrcCredentialsFunc(cliName, ctxName)
}

func (m *MockNetrcHandler) CheckCredentialExist(cliName string, ctxName string) (bool, error) {

	if m.CheckCredentialExistFunc == nil {
		panic("mocker: MockNetrcHandler.CheckCredentialExistFunc is nil but MockNetrcHandler.CheckCredentialExist was called.")
	}

	call := struct {
		CliName string
		CtxName string
	}{
		CliName: cliName,
		CtxName: ctxName,
	}

	m.calls.CheckCredentialExist = append(m.calls.CheckCredentialExist, call)

	return m.CheckCredentialExistFunc(cliName, ctxName)
}

// WriteNetrcCredentialsCalled returns true if WriteNetrcCredentials was called at least once.
func (m *MockNetrcHandler) WriteNetrcCredentialsCalled() bool {
	m.lockWriteNetrcCredentials.Lock()
	defer m.lockWriteNetrcCredentials.Unlock()

	return len(m.calls.WriteNetrcCredentials) > 0
}

// WriteNetrcCredentialsCalls returns the calls made to WriteNetrcCredentials.
func (m *MockNetrcHandler) WriteNetrcCredentialsCalls() []struct {
	CliName  string
	IsSSO    bool
	CtxName  string
	Username string
	Password string
} {
	m.lockWriteNetrcCredentials.Lock()
	defer m.lockWriteNetrcCredentials.Unlock()

	return m.calls.WriteNetrcCredentials
}

// GetMatchingNetrcMachine mocks base method by wrapping the associated func.
func (m *MockNetrcHandler) GetMatchingNetrcMachine(params github_com_confluentinc_cli_internal_pkg_netrc.GetMatchingNetrcMachineParams) (*github_com_confluentinc_cli_internal_pkg_netrc.Machine, error) {
	m.lockGetMatchingNetrcMachine.Lock()
	defer m.lockGetMatchingNetrcMachine.Unlock()

	if m.GetMatchingNetrcMachineFunc == nil {
		panic("mocker: MockNetrcHandler.GetMatchingNetrcMachineFunc is nil but MockNetrcHandler.GetMatchingNetrcMachine was called.")
	}

	call := struct {
		Params github_com_confluentinc_cli_internal_pkg_netrc.GetMatchingNetrcMachineParams
	}{
		Params: params,
	}

	m.calls.GetMatchingNetrcMachine = append(m.calls.GetMatchingNetrcMachine, call)

	return m.GetMatchingNetrcMachineFunc(params)
}

// GetMatchingNetrcMachineCalled returns true if GetMatchingNetrcMachine was called at least once.
func (m *MockNetrcHandler) GetMatchingNetrcMachineCalled() bool {
	m.lockGetMatchingNetrcMachine.Lock()
	defer m.lockGetMatchingNetrcMachine.Unlock()

	return len(m.calls.GetMatchingNetrcMachine) > 0
}

// GetMatchingNetrcMachineCalls returns the calls made to GetMatchingNetrcMachine.
func (m *MockNetrcHandler) GetMatchingNetrcMachineCalls() []struct {
	Params github_com_confluentinc_cli_internal_pkg_netrc.GetMatchingNetrcMachineParams
} {
	m.lockGetMatchingNetrcMachine.Lock()
	defer m.lockGetMatchingNetrcMachine.Unlock()

	return m.calls.GetMatchingNetrcMachine
}

// GetFileName mocks base method by wrapping the associated func.
func (m *MockNetrcHandler) GetFileName() string {
	m.lockGetFileName.Lock()
	defer m.lockGetFileName.Unlock()

	if m.GetFileNameFunc == nil {
		panic("mocker: MockNetrcHandler.GetFileNameFunc is nil but MockNetrcHandler.GetFileName was called.")
	}

	call := struct {
	}{}

	m.calls.GetFileName = append(m.calls.GetFileName, call)

	return m.GetFileNameFunc()
}

// GetFileNameCalled returns true if GetFileName was called at least once.
func (m *MockNetrcHandler) GetFileNameCalled() bool {
	m.lockGetFileName.Lock()
	defer m.lockGetFileName.Unlock()

	return len(m.calls.GetFileName) > 0
}

// GetFileNameCalls returns the calls made to GetFileName.
func (m *MockNetrcHandler) GetFileNameCalls() []struct {
} {
	m.lockGetFileName.Lock()
	defer m.lockGetFileName.Unlock()

	return m.calls.GetFileName
}

// Reset resets the calls made to the mocked methods.
func (m *MockNetrcHandler) Reset() {
	m.lockWriteNetrcCredentials.Lock()
	m.calls.WriteNetrcCredentials = nil
	m.lockWriteNetrcCredentials.Unlock()
	m.lockGetMatchingNetrcMachine.Lock()
	m.calls.GetMatchingNetrcMachine = nil
	m.lockGetMatchingNetrcMachine.Unlock()
	m.lockGetFileName.Lock()
	m.calls.GetFileName = nil
	m.lockGetFileName.Unlock()
}
