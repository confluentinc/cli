// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: io.go

package mock

import (
	io "io"
	os "os"
	sync "sync"
	time "time"

	github_com_confluentinc_cli_internal_pkg_update_io "github.com/confluentinc/cli/internal/pkg/update/io"
)

// FileSystem is a mock of FileSystem interface
type FileSystem struct {
	lockOpen sync.Mutex
	OpenFunc func(name string) (github_com_confluentinc_cli_internal_pkg_update_io.File, error)

	lockStat sync.Mutex
	StatFunc func(name string) (os.FileInfo, error)

	lockCreate sync.Mutex
	CreateFunc func(name string) (github_com_confluentinc_cli_internal_pkg_update_io.File, error)

	lockChtimes sync.Mutex
	ChtimesFunc func(name string, atime, mtime time.Time) error

	lockChmod sync.Mutex
	ChmodFunc func(name string, mode os.FileMode) error

	lockRemove sync.Mutex
	RemoveFunc func(name string) error

	lockRemoveAll sync.Mutex
	RemoveAllFunc func(path string) error

	lockTempDir sync.Mutex
	TempDirFunc func(dir, prefix string) (string, error)

	lockCopy sync.Mutex
	CopyFunc func(dst io.Writer, src io.Reader) (int64, error)

	calls struct {
		Open []struct {
			Name string
		}
		Stat []struct {
			Name string
		}
		Create []struct {
			Name string
		}
		Chtimes []struct {
			Name  string
			Atime time.Time
			Mtime time.Time
		}
		Chmod []struct {
			Name string
			Mode os.FileMode
		}
		Remove []struct {
			Name string
		}
		RemoveAll []struct {
			Path string
		}
		TempDir []struct {
			Dir    string
			Prefix string
		}
		Copy []struct {
			Dst io.Writer
			Src io.Reader
		}
	}
}

// Open mocks base method by wrapping the associated func.
func (m *FileSystem) Open(name string) (github_com_confluentinc_cli_internal_pkg_update_io.File, error) {
	m.lockOpen.Lock()
	defer m.lockOpen.Unlock()

	if m.OpenFunc == nil {
		panic("mocker: FileSystem.OpenFunc is nil but FileSystem.Open was called.")
	}

	call := struct {
		Name string
	}{
		Name: name,
	}

	m.calls.Open = append(m.calls.Open, call)

	return m.OpenFunc(name)
}

// OpenCalled returns true if Open was called at least once.
func (m *FileSystem) OpenCalled() bool {
	m.lockOpen.Lock()
	defer m.lockOpen.Unlock()

	return len(m.calls.Open) > 0
}

// OpenCalls returns the calls made to Open.
func (m *FileSystem) OpenCalls() []struct {
	Name string
} {
	m.lockOpen.Lock()
	defer m.lockOpen.Unlock()

	return m.calls.Open
}

// Stat mocks base method by wrapping the associated func.
func (m *FileSystem) Stat(name string) (os.FileInfo, error) {
	m.lockStat.Lock()
	defer m.lockStat.Unlock()

	if m.StatFunc == nil {
		panic("mocker: FileSystem.StatFunc is nil but FileSystem.Stat was called.")
	}

	call := struct {
		Name string
	}{
		Name: name,
	}

	m.calls.Stat = append(m.calls.Stat, call)

	return m.StatFunc(name)
}

// StatCalled returns true if Stat was called at least once.
func (m *FileSystem) StatCalled() bool {
	m.lockStat.Lock()
	defer m.lockStat.Unlock()

	return len(m.calls.Stat) > 0
}

// StatCalls returns the calls made to Stat.
func (m *FileSystem) StatCalls() []struct {
	Name string
} {
	m.lockStat.Lock()
	defer m.lockStat.Unlock()

	return m.calls.Stat
}

// Create mocks base method by wrapping the associated func.
func (m *FileSystem) Create(name string) (github_com_confluentinc_cli_internal_pkg_update_io.File, error) {
	m.lockCreate.Lock()
	defer m.lockCreate.Unlock()

	if m.CreateFunc == nil {
		panic("mocker: FileSystem.CreateFunc is nil but FileSystem.Create was called.")
	}

	call := struct {
		Name string
	}{
		Name: name,
	}

	m.calls.Create = append(m.calls.Create, call)

	return m.CreateFunc(name)
}

// CreateCalled returns true if Create was called at least once.
func (m *FileSystem) CreateCalled() bool {
	m.lockCreate.Lock()
	defer m.lockCreate.Unlock()

	return len(m.calls.Create) > 0
}

// CreateCalls returns the calls made to Create.
func (m *FileSystem) CreateCalls() []struct {
	Name string
} {
	m.lockCreate.Lock()
	defer m.lockCreate.Unlock()

	return m.calls.Create
}

// Chtimes mocks base method by wrapping the associated func.
func (m *FileSystem) Chtimes(name string, atime, mtime time.Time) error {
	m.lockChtimes.Lock()
	defer m.lockChtimes.Unlock()

	if m.ChtimesFunc == nil {
		panic("mocker: FileSystem.ChtimesFunc is nil but FileSystem.Chtimes was called.")
	}

	call := struct {
		Name  string
		Atime time.Time
		Mtime time.Time
	}{
		Name:  name,
		Atime: atime,
		Mtime: mtime,
	}

	m.calls.Chtimes = append(m.calls.Chtimes, call)

	return m.ChtimesFunc(name, atime, mtime)
}

// ChtimesCalled returns true if Chtimes was called at least once.
func (m *FileSystem) ChtimesCalled() bool {
	m.lockChtimes.Lock()
	defer m.lockChtimes.Unlock()

	return len(m.calls.Chtimes) > 0
}

// ChtimesCalls returns the calls made to Chtimes.
func (m *FileSystem) ChtimesCalls() []struct {
	Name  string
	Atime time.Time
	Mtime time.Time
} {
	m.lockChtimes.Lock()
	defer m.lockChtimes.Unlock()

	return m.calls.Chtimes
}

// Chmod mocks base method by wrapping the associated func.
func (m *FileSystem) Chmod(name string, mode os.FileMode) error {
	m.lockChmod.Lock()
	defer m.lockChmod.Unlock()

	if m.ChmodFunc == nil {
		panic("mocker: FileSystem.ChmodFunc is nil but FileSystem.Chmod was called.")
	}

	call := struct {
		Name string
		Mode os.FileMode
	}{
		Name: name,
		Mode: mode,
	}

	m.calls.Chmod = append(m.calls.Chmod, call)

	return m.ChmodFunc(name, mode)
}

// ChmodCalled returns true if Chmod was called at least once.
func (m *FileSystem) ChmodCalled() bool {
	m.lockChmod.Lock()
	defer m.lockChmod.Unlock()

	return len(m.calls.Chmod) > 0
}

// ChmodCalls returns the calls made to Chmod.
func (m *FileSystem) ChmodCalls() []struct {
	Name string
	Mode os.FileMode
} {
	m.lockChmod.Lock()
	defer m.lockChmod.Unlock()

	return m.calls.Chmod
}

// Remove mocks base method by wrapping the associated func.
func (m *FileSystem) Remove(name string) error {
	m.lockRemove.Lock()
	defer m.lockRemove.Unlock()

	if m.RemoveFunc == nil {
		panic("mocker: FileSystem.RemoveFunc is nil but FileSystem.Remove was called.")
	}

	call := struct {
		Name string
	}{
		Name: name,
	}

	m.calls.Remove = append(m.calls.Remove, call)

	return m.RemoveFunc(name)
}

// RemoveCalled returns true if Remove was called at least once.
func (m *FileSystem) RemoveCalled() bool {
	m.lockRemove.Lock()
	defer m.lockRemove.Unlock()

	return len(m.calls.Remove) > 0
}

// RemoveCalls returns the calls made to Remove.
func (m *FileSystem) RemoveCalls() []struct {
	Name string
} {
	m.lockRemove.Lock()
	defer m.lockRemove.Unlock()

	return m.calls.Remove
}

// RemoveAll mocks base method by wrapping the associated func.
func (m *FileSystem) RemoveAll(path string) error {
	m.lockRemoveAll.Lock()
	defer m.lockRemoveAll.Unlock()

	if m.RemoveAllFunc == nil {
		panic("mocker: FileSystem.RemoveAllFunc is nil but FileSystem.RemoveAll was called.")
	}

	call := struct {
		Path string
	}{
		Path: path,
	}

	m.calls.RemoveAll = append(m.calls.RemoveAll, call)

	return m.RemoveAllFunc(path)
}

// RemoveAllCalled returns true if RemoveAll was called at least once.
func (m *FileSystem) RemoveAllCalled() bool {
	m.lockRemoveAll.Lock()
	defer m.lockRemoveAll.Unlock()

	return len(m.calls.RemoveAll) > 0
}

// RemoveAllCalls returns the calls made to RemoveAll.
func (m *FileSystem) RemoveAllCalls() []struct {
	Path string
} {
	m.lockRemoveAll.Lock()
	defer m.lockRemoveAll.Unlock()

	return m.calls.RemoveAll
}

// TempDir mocks base method by wrapping the associated func.
func (m *FileSystem) TempDir(dir, prefix string) (string, error) {
	m.lockTempDir.Lock()
	defer m.lockTempDir.Unlock()

	if m.TempDirFunc == nil {
		panic("mocker: FileSystem.TempDirFunc is nil but FileSystem.TempDir was called.")
	}

	call := struct {
		Dir    string
		Prefix string
	}{
		Dir:    dir,
		Prefix: prefix,
	}

	m.calls.TempDir = append(m.calls.TempDir, call)

	return m.TempDirFunc(dir, prefix)
}

// TempDirCalled returns true if TempDir was called at least once.
func (m *FileSystem) TempDirCalled() bool {
	m.lockTempDir.Lock()
	defer m.lockTempDir.Unlock()

	return len(m.calls.TempDir) > 0
}

// TempDirCalls returns the calls made to TempDir.
func (m *FileSystem) TempDirCalls() []struct {
	Dir    string
	Prefix string
} {
	m.lockTempDir.Lock()
	defer m.lockTempDir.Unlock()

	return m.calls.TempDir
}

// Copy mocks base method by wrapping the associated func.
func (m *FileSystem) Copy(dst io.Writer, src io.Reader) (int64, error) {
	m.lockCopy.Lock()
	defer m.lockCopy.Unlock()

	if m.CopyFunc == nil {
		panic("mocker: FileSystem.CopyFunc is nil but FileSystem.Copy was called.")
	}

	call := struct {
		Dst io.Writer
		Src io.Reader
	}{
		Dst: dst,
		Src: src,
	}

	m.calls.Copy = append(m.calls.Copy, call)

	return m.CopyFunc(dst, src)
}

// CopyCalled returns true if Copy was called at least once.
func (m *FileSystem) CopyCalled() bool {
	m.lockCopy.Lock()
	defer m.lockCopy.Unlock()

	return len(m.calls.Copy) > 0
}

// CopyCalls returns the calls made to Copy.
func (m *FileSystem) CopyCalls() []struct {
	Dst io.Writer
	Src io.Reader
} {
	m.lockCopy.Lock()
	defer m.lockCopy.Unlock()

	return m.calls.Copy
}

// Reset resets the calls made to the mocked methods.
func (m *FileSystem) Reset() {
	m.lockOpen.Lock()
	m.calls.Open = nil
	m.lockOpen.Unlock()
	m.lockStat.Lock()
	m.calls.Stat = nil
	m.lockStat.Unlock()
	m.lockCreate.Lock()
	m.calls.Create = nil
	m.lockCreate.Unlock()
	m.lockChtimes.Lock()
	m.calls.Chtimes = nil
	m.lockChtimes.Unlock()
	m.lockChmod.Lock()
	m.calls.Chmod = nil
	m.lockChmod.Unlock()
	m.lockRemove.Lock()
	m.calls.Remove = nil
	m.lockRemove.Unlock()
	m.lockRemoveAll.Lock()
	m.calls.RemoveAll = nil
	m.lockRemoveAll.Unlock()
	m.lockTempDir.Lock()
	m.calls.TempDir = nil
	m.lockTempDir.Unlock()
	m.lockCopy.Lock()
	m.calls.Copy = nil
	m.lockCopy.Unlock()
}
