// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: repository.go

package mock

import (
	sync "sync"

	github_com_hashicorp_go_version "github.com/hashicorp/go-version"
)

// Repository is a mock of Repository interface
type Repository struct {
	lockGetAvailableVersions sync.Mutex
	GetAvailableVersionsFunc func(name string) (github_com_hashicorp_go_version.Collection, error)

	lockDownloadVersion sync.Mutex
	DownloadVersionFunc func(name, version, downloadDir string) (string, int64, error)

	calls struct {
		GetAvailableVersions []struct {
			Name string
		}
		DownloadVersion []struct {
			Name        string
			Version     string
			DownloadDir string
		}
	}
}

// GetAvailableVersions mocks base method by wrapping the associated func.
func (m *Repository) GetAvailableVersions(name string) (github_com_hashicorp_go_version.Collection, error) {
	m.lockGetAvailableVersions.Lock()
	defer m.lockGetAvailableVersions.Unlock()

	if m.GetAvailableVersionsFunc == nil {
		panic("mocker: Repository.GetAvailableVersionsFunc is nil but Repository.GetAvailableVersions was called.")
	}

	call := struct {
		Name string
	}{
		Name: name,
	}

	m.calls.GetAvailableVersions = append(m.calls.GetAvailableVersions, call)

	return m.GetAvailableVersionsFunc(name)
}

// GetAvailableVersionsCalled returns true if GetAvailableVersions was called at least once.
func (m *Repository) GetAvailableVersionsCalled() bool {
	m.lockGetAvailableVersions.Lock()
	defer m.lockGetAvailableVersions.Unlock()

	return len(m.calls.GetAvailableVersions) > 0
}

// GetAvailableVersionsCalls returns the calls made to GetAvailableVersions.
func (m *Repository) GetAvailableVersionsCalls() []struct {
	Name string
} {
	m.lockGetAvailableVersions.Lock()
	defer m.lockGetAvailableVersions.Unlock()

	return m.calls.GetAvailableVersions
}

// DownloadVersion mocks base method by wrapping the associated func.
func (m *Repository) DownloadVersion(name, version, downloadDir string) (string, int64, error) {
	m.lockDownloadVersion.Lock()
	defer m.lockDownloadVersion.Unlock()

	if m.DownloadVersionFunc == nil {
		panic("mocker: Repository.DownloadVersionFunc is nil but Repository.DownloadVersion was called.")
	}

	call := struct {
		Name        string
		Version     string
		DownloadDir string
	}{
		Name:        name,
		Version:     version,
		DownloadDir: downloadDir,
	}

	m.calls.DownloadVersion = append(m.calls.DownloadVersion, call)

	return m.DownloadVersionFunc(name, version, downloadDir)
}

// DownloadVersionCalled returns true if DownloadVersion was called at least once.
func (m *Repository) DownloadVersionCalled() bool {
	m.lockDownloadVersion.Lock()
	defer m.lockDownloadVersion.Unlock()

	return len(m.calls.DownloadVersion) > 0
}

// DownloadVersionCalls returns the calls made to DownloadVersion.
func (m *Repository) DownloadVersionCalls() []struct {
	Name        string
	Version     string
	DownloadDir string
} {
	m.lockDownloadVersion.Lock()
	defer m.lockDownloadVersion.Unlock()

	return m.calls.DownloadVersion
}

// Reset resets the calls made to the mocked methods.
func (m *Repository) Reset() {
	m.lockGetAvailableVersions.Lock()
	m.calls.GetAvailableVersions = nil
	m.lockGetAvailableVersions.Unlock()
	m.lockDownloadVersion.Lock()
	m.calls.DownloadVersion = nil
	m.lockDownloadVersion.Unlock()
}
