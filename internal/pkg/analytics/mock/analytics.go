// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: analytics.go

package mock

import (
	sync "sync"

	github_com_spf13_cobra "github.com/spf13/cobra"
)

// Client is a mock of Client interface
type Client struct {
	lockTrackCommand sync.Mutex
	TrackCommandFunc func(cmd *github_com_spf13_cobra.Command, args []string)

	lockFlushCommandSucceeded sync.Mutex
	FlushCommandSucceededFunc func() error

	lockFlushCommandFailed sync.Mutex
	FlushCommandFailedFunc func(e error) error

	calls struct {
		TrackCommand []struct {
			Cmd  *github_com_spf13_cobra.Command
			Args []string
		}
		FlushCommandSucceeded []struct {
		}
		FlushCommandFailed []struct {
			E error
		}
	}
}

// TrackCommand mocks base method by wrapping the associated func.
func (m *Client) TrackCommand(cmd *github_com_spf13_cobra.Command, args []string) {
	m.lockTrackCommand.Lock()
	defer m.lockTrackCommand.Unlock()

	if m.TrackCommandFunc == nil {
		panic("mocker: Client.TrackCommandFunc is nil but Client.TrackCommand was called.")
	}

	call := struct {
		Cmd  *github_com_spf13_cobra.Command
		Args []string
	}{
		Cmd:  cmd,
		Args: args,
	}

	m.calls.TrackCommand = append(m.calls.TrackCommand, call)

	m.TrackCommandFunc(cmd, args)
}

// TrackCommandCalled returns true if TrackCommand was called at least once.
func (m *Client) TrackCommandCalled() bool {
	m.lockTrackCommand.Lock()
	defer m.lockTrackCommand.Unlock()

	return len(m.calls.TrackCommand) > 0
}

// TrackCommandCalls returns the calls made to TrackCommand.
func (m *Client) TrackCommandCalls() []struct {
	Cmd  *github_com_spf13_cobra.Command
	Args []string
} {
	m.lockTrackCommand.Lock()
	defer m.lockTrackCommand.Unlock()

	return m.calls.TrackCommand
}

// FlushCommandSucceeded mocks base method by wrapping the associated func.
func (m *Client) FlushCommandSucceeded() error {
	m.lockFlushCommandSucceeded.Lock()
	defer m.lockFlushCommandSucceeded.Unlock()

	if m.FlushCommandSucceededFunc == nil {
		panic("mocker: Client.FlushCommandSucceededFunc is nil but Client.FlushCommandSucceeded was called.")
	}

	call := struct {
	}{}

	m.calls.FlushCommandSucceeded = append(m.calls.FlushCommandSucceeded, call)

	return m.FlushCommandSucceededFunc()
}

// FlushCommandSucceededCalled returns true if FlushCommandSucceeded was called at least once.
func (m *Client) FlushCommandSucceededCalled() bool {
	m.lockFlushCommandSucceeded.Lock()
	defer m.lockFlushCommandSucceeded.Unlock()

	return len(m.calls.FlushCommandSucceeded) > 0
}

// FlushCommandSucceededCalls returns the calls made to FlushCommandSucceeded.
func (m *Client) FlushCommandSucceededCalls() []struct {
} {
	m.lockFlushCommandSucceeded.Lock()
	defer m.lockFlushCommandSucceeded.Unlock()

	return m.calls.FlushCommandSucceeded
}

// FlushCommandFailed mocks base method by wrapping the associated func.
func (m *Client) FlushCommandFailed(e error) error {
	m.lockFlushCommandFailed.Lock()
	defer m.lockFlushCommandFailed.Unlock()

	if m.FlushCommandFailedFunc == nil {
		panic("mocker: Client.FlushCommandFailedFunc is nil but Client.FlushCommandFailed was called.")
	}

	call := struct {
		E error
	}{
		E: e,
	}

	m.calls.FlushCommandFailed = append(m.calls.FlushCommandFailed, call)

	return m.FlushCommandFailedFunc(e)
}

// FlushCommandFailedCalled returns true if FlushCommandFailed was called at least once.
func (m *Client) FlushCommandFailedCalled() bool {
	m.lockFlushCommandFailed.Lock()
	defer m.lockFlushCommandFailed.Unlock()

	return len(m.calls.FlushCommandFailed) > 0
}

// FlushCommandFailedCalls returns the calls made to FlushCommandFailed.
func (m *Client) FlushCommandFailedCalls() []struct {
	E error
} {
	m.lockFlushCommandFailed.Lock()
	defer m.lockFlushCommandFailed.Unlock()

	return m.calls.FlushCommandFailed
}

// Reset resets the calls made to the mocked methods.
func (m *Client) Reset() {
	m.lockTrackCommand.Lock()
	m.calls.TrackCommand = nil
	m.lockTrackCommand.Unlock()
	m.lockFlushCommandSucceeded.Lock()
	m.calls.FlushCommandSucceeded = nil
	m.lockFlushCommandSucceeded.Unlock()
	m.lockFlushCommandFailed.Lock()
	m.calls.FlushCommandFailed = nil
	m.lockFlushCommandFailed.Unlock()
}
