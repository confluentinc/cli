// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: confluent_current.go

package mock

import (
	sync "sync"
)

// MockConfluentCurrent is a mock of ConfluentCurrent interface
type MockConfluentCurrent struct {
	lockHasTrackingFile sync.Mutex
	HasTrackingFileFunc func() bool

	lockRemoveTrackingFile sync.Mutex
	RemoveTrackingFileFunc func() error

	lockGetCurrentDir sync.Mutex
	GetCurrentDirFunc func() (string, error)

	lockRemoveCurrentDir sync.Mutex
	RemoveCurrentDirFunc func() error

	lockGetDataDir sync.Mutex
	GetDataDirFunc func(service string) (string, error)

	lockGetLogsDir sync.Mutex
	GetLogsDirFunc func(service string) (string, error)

	lockGetConfigFile sync.Mutex
	GetConfigFileFunc func(service string) (string, error)

	lockWriteConfig sync.Mutex
	WriteConfigFunc func(service string, config []byte) error

	lockGetLogFile sync.Mutex
	GetLogFileFunc func(service string) (string, error)

	lockGetPidFile sync.Mutex
	GetPidFileFunc func(service string) (string, error)

	lockHasPidFile sync.Mutex
	HasPidFileFunc func(service string) (bool, error)

	lockReadPid sync.Mutex
	ReadPidFunc func(service string) (int, error)

	lockWritePid sync.Mutex
	WritePidFunc func(service string, pid int) error

	lockRemovePidFile sync.Mutex
	RemovePidFileFunc func(service string) error

	calls struct {
		HasTrackingFile []struct {
		}
		RemoveTrackingFile []struct {
		}
		GetCurrentDir []struct {
		}
		RemoveCurrentDir []struct {
		}
		GetDataDir []struct {
			Service string
		}
		GetLogsDir []struct {
			Service string
		}
		GetConfigFile []struct {
			Service string
		}
		WriteConfig []struct {
			Service string
			Config  []byte
		}
		GetLogFile []struct {
			Service string
		}
		GetPidFile []struct {
			Service string
		}
		HasPidFile []struct {
			Service string
		}
		ReadPid []struct {
			Service string
		}
		WritePid []struct {
			Service string
			Pid     int
		}
		RemovePidFile []struct {
			Service string
		}
	}
}

// HasTrackingFile mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) HasTrackingFile() bool {
	m.lockHasTrackingFile.Lock()
	defer m.lockHasTrackingFile.Unlock()

	if m.HasTrackingFileFunc == nil {
		panic("mocker: MockConfluentCurrent.HasTrackingFileFunc is nil but MockConfluentCurrent.HasTrackingFile was called.")
	}

	call := struct {
	}{}

	m.calls.HasTrackingFile = append(m.calls.HasTrackingFile, call)

	return m.HasTrackingFileFunc()
}

// HasTrackingFileCalled returns true if HasTrackingFile was called at least once.
func (m *MockConfluentCurrent) HasTrackingFileCalled() bool {
	m.lockHasTrackingFile.Lock()
	defer m.lockHasTrackingFile.Unlock()

	return len(m.calls.HasTrackingFile) > 0
}

// HasTrackingFileCalls returns the calls made to HasTrackingFile.
func (m *MockConfluentCurrent) HasTrackingFileCalls() []struct {
} {
	m.lockHasTrackingFile.Lock()
	defer m.lockHasTrackingFile.Unlock()

	return m.calls.HasTrackingFile
}

// RemoveTrackingFile mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) RemoveTrackingFile() error {
	m.lockRemoveTrackingFile.Lock()
	defer m.lockRemoveTrackingFile.Unlock()

	if m.RemoveTrackingFileFunc == nil {
		panic("mocker: MockConfluentCurrent.RemoveTrackingFileFunc is nil but MockConfluentCurrent.RemoveTrackingFile was called.")
	}

	call := struct {
	}{}

	m.calls.RemoveTrackingFile = append(m.calls.RemoveTrackingFile, call)

	return m.RemoveTrackingFileFunc()
}

// RemoveTrackingFileCalled returns true if RemoveTrackingFile was called at least once.
func (m *MockConfluentCurrent) RemoveTrackingFileCalled() bool {
	m.lockRemoveTrackingFile.Lock()
	defer m.lockRemoveTrackingFile.Unlock()

	return len(m.calls.RemoveTrackingFile) > 0
}

// RemoveTrackingFileCalls returns the calls made to RemoveTrackingFile.
func (m *MockConfluentCurrent) RemoveTrackingFileCalls() []struct {
} {
	m.lockRemoveTrackingFile.Lock()
	defer m.lockRemoveTrackingFile.Unlock()

	return m.calls.RemoveTrackingFile
}

// GetCurrentDir mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) GetCurrentDir() (string, error) {
	m.lockGetCurrentDir.Lock()
	defer m.lockGetCurrentDir.Unlock()

	if m.GetCurrentDirFunc == nil {
		panic("mocker: MockConfluentCurrent.GetCurrentDirFunc is nil but MockConfluentCurrent.GetCurrentDir was called.")
	}

	call := struct {
	}{}

	m.calls.GetCurrentDir = append(m.calls.GetCurrentDir, call)

	return m.GetCurrentDirFunc()
}

// GetCurrentDirCalled returns true if GetCurrentDir was called at least once.
func (m *MockConfluentCurrent) GetCurrentDirCalled() bool {
	m.lockGetCurrentDir.Lock()
	defer m.lockGetCurrentDir.Unlock()

	return len(m.calls.GetCurrentDir) > 0
}

// GetCurrentDirCalls returns the calls made to GetCurrentDir.
func (m *MockConfluentCurrent) GetCurrentDirCalls() []struct {
} {
	m.lockGetCurrentDir.Lock()
	defer m.lockGetCurrentDir.Unlock()

	return m.calls.GetCurrentDir
}

// RemoveCurrentDir mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) RemoveCurrentDir() error {
	m.lockRemoveCurrentDir.Lock()
	defer m.lockRemoveCurrentDir.Unlock()

	if m.RemoveCurrentDirFunc == nil {
		panic("mocker: MockConfluentCurrent.RemoveCurrentDirFunc is nil but MockConfluentCurrent.RemoveCurrentDir was called.")
	}

	call := struct {
	}{}

	m.calls.RemoveCurrentDir = append(m.calls.RemoveCurrentDir, call)

	return m.RemoveCurrentDirFunc()
}

// RemoveCurrentDirCalled returns true if RemoveCurrentDir was called at least once.
func (m *MockConfluentCurrent) RemoveCurrentDirCalled() bool {
	m.lockRemoveCurrentDir.Lock()
	defer m.lockRemoveCurrentDir.Unlock()

	return len(m.calls.RemoveCurrentDir) > 0
}

// RemoveCurrentDirCalls returns the calls made to RemoveCurrentDir.
func (m *MockConfluentCurrent) RemoveCurrentDirCalls() []struct {
} {
	m.lockRemoveCurrentDir.Lock()
	defer m.lockRemoveCurrentDir.Unlock()

	return m.calls.RemoveCurrentDir
}

// GetDataDir mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) GetDataDir(service string) (string, error) {
	m.lockGetDataDir.Lock()
	defer m.lockGetDataDir.Unlock()

	if m.GetDataDirFunc == nil {
		panic("mocker: MockConfluentCurrent.GetDataDirFunc is nil but MockConfluentCurrent.GetDataDir was called.")
	}

	call := struct {
		Service string
	}{
		Service: service,
	}

	m.calls.GetDataDir = append(m.calls.GetDataDir, call)

	return m.GetDataDirFunc(service)
}

// GetDataDirCalled returns true if GetDataDir was called at least once.
func (m *MockConfluentCurrent) GetDataDirCalled() bool {
	m.lockGetDataDir.Lock()
	defer m.lockGetDataDir.Unlock()

	return len(m.calls.GetDataDir) > 0
}

// GetDataDirCalls returns the calls made to GetDataDir.
func (m *MockConfluentCurrent) GetDataDirCalls() []struct {
	Service string
} {
	m.lockGetDataDir.Lock()
	defer m.lockGetDataDir.Unlock()

	return m.calls.GetDataDir
}

// GetLogsDir mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) GetLogsDir(service string) (string, error) {
	m.lockGetLogsDir.Lock()
	defer m.lockGetLogsDir.Unlock()

	if m.GetLogsDirFunc == nil {
		panic("mocker: MockConfluentCurrent.GetLogsDirFunc is nil but MockConfluentCurrent.GetLogsDir was called.")
	}

	call := struct {
		Service string
	}{
		Service: service,
	}

	m.calls.GetLogsDir = append(m.calls.GetLogsDir, call)

	return m.GetLogsDirFunc(service)
}

// GetLogsDirCalled returns true if GetLogsDir was called at least once.
func (m *MockConfluentCurrent) GetLogsDirCalled() bool {
	m.lockGetLogsDir.Lock()
	defer m.lockGetLogsDir.Unlock()

	return len(m.calls.GetLogsDir) > 0
}

// GetLogsDirCalls returns the calls made to GetLogsDir.
func (m *MockConfluentCurrent) GetLogsDirCalls() []struct {
	Service string
} {
	m.lockGetLogsDir.Lock()
	defer m.lockGetLogsDir.Unlock()

	return m.calls.GetLogsDir
}

// GetConfigFile mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) GetConfigFile(service string) (string, error) {
	m.lockGetConfigFile.Lock()
	defer m.lockGetConfigFile.Unlock()

	if m.GetConfigFileFunc == nil {
		panic("mocker: MockConfluentCurrent.GetConfigFileFunc is nil but MockConfluentCurrent.GetConfigFile was called.")
	}

	call := struct {
		Service string
	}{
		Service: service,
	}

	m.calls.GetConfigFile = append(m.calls.GetConfigFile, call)

	return m.GetConfigFileFunc(service)
}

// GetConfigFileCalled returns true if GetConfigFile was called at least once.
func (m *MockConfluentCurrent) GetConfigFileCalled() bool {
	m.lockGetConfigFile.Lock()
	defer m.lockGetConfigFile.Unlock()

	return len(m.calls.GetConfigFile) > 0
}

// GetConfigFileCalls returns the calls made to GetConfigFile.
func (m *MockConfluentCurrent) GetConfigFileCalls() []struct {
	Service string
} {
	m.lockGetConfigFile.Lock()
	defer m.lockGetConfigFile.Unlock()

	return m.calls.GetConfigFile
}

// WriteConfig mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) WriteConfig(service string, config []byte) error {
	m.lockWriteConfig.Lock()
	defer m.lockWriteConfig.Unlock()

	if m.WriteConfigFunc == nil {
		panic("mocker: MockConfluentCurrent.WriteConfigFunc is nil but MockConfluentCurrent.WriteConfig was called.")
	}

	call := struct {
		Service string
		Config  []byte
	}{
		Service: service,
		Config:  config,
	}

	m.calls.WriteConfig = append(m.calls.WriteConfig, call)

	return m.WriteConfigFunc(service, config)
}

// WriteConfigCalled returns true if WriteConfig was called at least once.
func (m *MockConfluentCurrent) WriteConfigCalled() bool {
	m.lockWriteConfig.Lock()
	defer m.lockWriteConfig.Unlock()

	return len(m.calls.WriteConfig) > 0
}

// WriteConfigCalls returns the calls made to WriteConfig.
func (m *MockConfluentCurrent) WriteConfigCalls() []struct {
	Service string
	Config  []byte
} {
	m.lockWriteConfig.Lock()
	defer m.lockWriteConfig.Unlock()

	return m.calls.WriteConfig
}

// GetLogFile mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) GetLogFile(service string) (string, error) {
	m.lockGetLogFile.Lock()
	defer m.lockGetLogFile.Unlock()

	if m.GetLogFileFunc == nil {
		panic("mocker: MockConfluentCurrent.GetLogFileFunc is nil but MockConfluentCurrent.GetLogFile was called.")
	}

	call := struct {
		Service string
	}{
		Service: service,
	}

	m.calls.GetLogFile = append(m.calls.GetLogFile, call)

	return m.GetLogFileFunc(service)
}

// GetLogFileCalled returns true if GetLogFile was called at least once.
func (m *MockConfluentCurrent) GetLogFileCalled() bool {
	m.lockGetLogFile.Lock()
	defer m.lockGetLogFile.Unlock()

	return len(m.calls.GetLogFile) > 0
}

// GetLogFileCalls returns the calls made to GetLogFile.
func (m *MockConfluentCurrent) GetLogFileCalls() []struct {
	Service string
} {
	m.lockGetLogFile.Lock()
	defer m.lockGetLogFile.Unlock()

	return m.calls.GetLogFile
}

// GetPidFile mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) GetPidFile(service string) (string, error) {
	m.lockGetPidFile.Lock()
	defer m.lockGetPidFile.Unlock()

	if m.GetPidFileFunc == nil {
		panic("mocker: MockConfluentCurrent.GetPidFileFunc is nil but MockConfluentCurrent.GetPidFile was called.")
	}

	call := struct {
		Service string
	}{
		Service: service,
	}

	m.calls.GetPidFile = append(m.calls.GetPidFile, call)

	return m.GetPidFileFunc(service)
}

// GetPidFileCalled returns true if GetPidFile was called at least once.
func (m *MockConfluentCurrent) GetPidFileCalled() bool {
	m.lockGetPidFile.Lock()
	defer m.lockGetPidFile.Unlock()

	return len(m.calls.GetPidFile) > 0
}

// GetPidFileCalls returns the calls made to GetPidFile.
func (m *MockConfluentCurrent) GetPidFileCalls() []struct {
	Service string
} {
	m.lockGetPidFile.Lock()
	defer m.lockGetPidFile.Unlock()

	return m.calls.GetPidFile
}

// HasPidFile mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) HasPidFile(service string) (bool, error) {
	m.lockHasPidFile.Lock()
	defer m.lockHasPidFile.Unlock()

	if m.HasPidFileFunc == nil {
		panic("mocker: MockConfluentCurrent.HasPidFileFunc is nil but MockConfluentCurrent.HasPidFile was called.")
	}

	call := struct {
		Service string
	}{
		Service: service,
	}

	m.calls.HasPidFile = append(m.calls.HasPidFile, call)

	return m.HasPidFileFunc(service)
}

// HasPidFileCalled returns true if HasPidFile was called at least once.
func (m *MockConfluentCurrent) HasPidFileCalled() bool {
	m.lockHasPidFile.Lock()
	defer m.lockHasPidFile.Unlock()

	return len(m.calls.HasPidFile) > 0
}

// HasPidFileCalls returns the calls made to HasPidFile.
func (m *MockConfluentCurrent) HasPidFileCalls() []struct {
	Service string
} {
	m.lockHasPidFile.Lock()
	defer m.lockHasPidFile.Unlock()

	return m.calls.HasPidFile
}

// ReadPid mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) ReadPid(service string) (int, error) {
	m.lockReadPid.Lock()
	defer m.lockReadPid.Unlock()

	if m.ReadPidFunc == nil {
		panic("mocker: MockConfluentCurrent.ReadPidFunc is nil but MockConfluentCurrent.ReadPid was called.")
	}

	call := struct {
		Service string
	}{
		Service: service,
	}

	m.calls.ReadPid = append(m.calls.ReadPid, call)

	return m.ReadPidFunc(service)
}

// ReadPidCalled returns true if ReadPid was called at least once.
func (m *MockConfluentCurrent) ReadPidCalled() bool {
	m.lockReadPid.Lock()
	defer m.lockReadPid.Unlock()

	return len(m.calls.ReadPid) > 0
}

// ReadPidCalls returns the calls made to ReadPid.
func (m *MockConfluentCurrent) ReadPidCalls() []struct {
	Service string
} {
	m.lockReadPid.Lock()
	defer m.lockReadPid.Unlock()

	return m.calls.ReadPid
}

// WritePid mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) WritePid(service string, pid int) error {
	m.lockWritePid.Lock()
	defer m.lockWritePid.Unlock()

	if m.WritePidFunc == nil {
		panic("mocker: MockConfluentCurrent.WritePidFunc is nil but MockConfluentCurrent.WritePid was called.")
	}

	call := struct {
		Service string
		Pid     int
	}{
		Service: service,
		Pid:     pid,
	}

	m.calls.WritePid = append(m.calls.WritePid, call)

	return m.WritePidFunc(service, pid)
}

// WritePidCalled returns true if WritePid was called at least once.
func (m *MockConfluentCurrent) WritePidCalled() bool {
	m.lockWritePid.Lock()
	defer m.lockWritePid.Unlock()

	return len(m.calls.WritePid) > 0
}

// WritePidCalls returns the calls made to WritePid.
func (m *MockConfluentCurrent) WritePidCalls() []struct {
	Service string
	Pid     int
} {
	m.lockWritePid.Lock()
	defer m.lockWritePid.Unlock()

	return m.calls.WritePid
}

// RemovePidFile mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) RemovePidFile(service string) error {
	m.lockRemovePidFile.Lock()
	defer m.lockRemovePidFile.Unlock()

	if m.RemovePidFileFunc == nil {
		panic("mocker: MockConfluentCurrent.RemovePidFileFunc is nil but MockConfluentCurrent.RemovePidFile was called.")
	}

	call := struct {
		Service string
	}{
		Service: service,
	}

	m.calls.RemovePidFile = append(m.calls.RemovePidFile, call)

	return m.RemovePidFileFunc(service)
}

// RemovePidFileCalled returns true if RemovePidFile was called at least once.
func (m *MockConfluentCurrent) RemovePidFileCalled() bool {
	m.lockRemovePidFile.Lock()
	defer m.lockRemovePidFile.Unlock()

	return len(m.calls.RemovePidFile) > 0
}

// RemovePidFileCalls returns the calls made to RemovePidFile.
func (m *MockConfluentCurrent) RemovePidFileCalls() []struct {
	Service string
} {
	m.lockRemovePidFile.Lock()
	defer m.lockRemovePidFile.Unlock()

	return m.calls.RemovePidFile
}

// Reset resets the calls made to the mocked methods.
func (m *MockConfluentCurrent) Reset() {
	m.lockHasTrackingFile.Lock()
	m.calls.HasTrackingFile = nil
	m.lockHasTrackingFile.Unlock()
	m.lockRemoveTrackingFile.Lock()
	m.calls.RemoveTrackingFile = nil
	m.lockRemoveTrackingFile.Unlock()
	m.lockGetCurrentDir.Lock()
	m.calls.GetCurrentDir = nil
	m.lockGetCurrentDir.Unlock()
	m.lockRemoveCurrentDir.Lock()
	m.calls.RemoveCurrentDir = nil
	m.lockRemoveCurrentDir.Unlock()
	m.lockGetDataDir.Lock()
	m.calls.GetDataDir = nil
	m.lockGetDataDir.Unlock()
	m.lockGetLogsDir.Lock()
	m.calls.GetLogsDir = nil
	m.lockGetLogsDir.Unlock()
	m.lockGetConfigFile.Lock()
	m.calls.GetConfigFile = nil
	m.lockGetConfigFile.Unlock()
	m.lockWriteConfig.Lock()
	m.calls.WriteConfig = nil
	m.lockWriteConfig.Unlock()
	m.lockGetLogFile.Lock()
	m.calls.GetLogFile = nil
	m.lockGetLogFile.Unlock()
	m.lockGetPidFile.Lock()
	m.calls.GetPidFile = nil
	m.lockGetPidFile.Unlock()
	m.lockHasPidFile.Lock()
	m.calls.HasPidFile = nil
	m.lockHasPidFile.Unlock()
	m.lockReadPid.Lock()
	m.calls.ReadPid = nil
	m.lockReadPid.Unlock()
	m.lockWritePid.Lock()
	m.calls.WritePid = nil
	m.lockWritePid.Unlock()
	m.lockRemovePidFile.Lock()
	m.calls.RemovePidFile = nil
	m.lockRemovePidFile.Unlock()
}
