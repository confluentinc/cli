// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: confluent_current.go

package mock

import (
	sync "sync"
)

// MockConfluentCurrent is a mock of ConfluentCurrent interface
type MockConfluentCurrent struct {
	lockRemoveTrackingFile sync.Mutex
	RemoveTrackingFileFunc func() error

	lockGetCurrentDir sync.Mutex
	GetCurrentDirFunc func() (string, error)

	lockRemoveCurrentDir sync.Mutex
	RemoveCurrentDirFunc func() error

	lockGetServiceDir sync.Mutex
	GetServiceDirFunc func(service string) (string, error)

	lockGetDataDir sync.Mutex
	GetDataDirFunc func(service string) (string, error)

	lockGetConfigFile sync.Mutex
	GetConfigFileFunc func(service string) (string, error)

	lockSetConfig sync.Mutex
	SetConfigFunc func(service string, config []byte) error

	lockGetLogFile sync.Mutex
	GetLogFileFunc func(service string) (string, error)

	lockGetPidFile sync.Mutex
	GetPidFileFunc func(service string) (string, error)

	lockHasPidFile sync.Mutex
	HasPidFileFunc func(service string) (bool, error)

	lockGetPid sync.Mutex
	GetPidFunc func(service string) (int, error)

	lockSetPid sync.Mutex
	SetPidFunc func(service string, pid int) error

	lockRemovePidFile sync.Mutex
	RemovePidFileFunc func(service string) error

	calls struct {
		RemoveTrackingFile []struct {
		}
		GetCurrentDir []struct {
		}
		RemoveCurrentDir []struct {
		}
		GetServiceDir []struct {
			Service string
		}
		GetDataDir []struct {
			Service string
		}
		GetConfigFile []struct {
			Service string
		}
		SetConfig []struct {
			Service string
			Config  []byte
		}
		GetLogFile []struct {
			Service string
		}
		GetPidFile []struct {
			Service string
		}
		HasPidFile []struct {
			Service string
		}
		GetPid []struct {
			Service string
		}
		SetPid []struct {
			Service string
			Pid     int
		}
		RemovePidFile []struct {
			Service string
		}
	}
}

// RemoveTrackingFile mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) RemoveTrackingFile() error {
	m.lockRemoveTrackingFile.Lock()
	defer m.lockRemoveTrackingFile.Unlock()

	if m.RemoveTrackingFileFunc == nil {
		panic("mocker: MockConfluentCurrent.RemoveTrackingFileFunc is nil but MockConfluentCurrent.RemoveTrackingFile was called.")
	}

	call := struct {
	}{}

	m.calls.RemoveTrackingFile = append(m.calls.RemoveTrackingFile, call)

	return m.RemoveTrackingFileFunc()
}

// RemoveTrackingFileCalled returns true if RemoveTrackingFile was called at least once.
func (m *MockConfluentCurrent) RemoveTrackingFileCalled() bool {
	m.lockRemoveTrackingFile.Lock()
	defer m.lockRemoveTrackingFile.Unlock()

	return len(m.calls.RemoveTrackingFile) > 0
}

// RemoveTrackingFileCalls returns the calls made to RemoveTrackingFile.
func (m *MockConfluentCurrent) RemoveTrackingFileCalls() []struct {
} {
	m.lockRemoveTrackingFile.Lock()
	defer m.lockRemoveTrackingFile.Unlock()

	return m.calls.RemoveTrackingFile
}

// GetCurrentDir mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) GetCurrentDir() (string, error) {
	m.lockGetCurrentDir.Lock()
	defer m.lockGetCurrentDir.Unlock()

	if m.GetCurrentDirFunc == nil {
		panic("mocker: MockConfluentCurrent.GetCurrentDirFunc is nil but MockConfluentCurrent.GetCurrentDir was called.")
	}

	call := struct {
	}{}

	m.calls.GetCurrentDir = append(m.calls.GetCurrentDir, call)

	return m.GetCurrentDirFunc()
}

// GetCurrentDirCalled returns true if GetCurrentDir was called at least once.
func (m *MockConfluentCurrent) GetCurrentDirCalled() bool {
	m.lockGetCurrentDir.Lock()
	defer m.lockGetCurrentDir.Unlock()

	return len(m.calls.GetCurrentDir) > 0
}

// GetCurrentDirCalls returns the calls made to GetCurrentDir.
func (m *MockConfluentCurrent) GetCurrentDirCalls() []struct {
} {
	m.lockGetCurrentDir.Lock()
	defer m.lockGetCurrentDir.Unlock()

	return m.calls.GetCurrentDir
}

// RemoveCurrentDir mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) RemoveCurrentDir() error {
	m.lockRemoveCurrentDir.Lock()
	defer m.lockRemoveCurrentDir.Unlock()

	if m.RemoveCurrentDirFunc == nil {
		panic("mocker: MockConfluentCurrent.RemoveCurrentDirFunc is nil but MockConfluentCurrent.RemoveCurrentDir was called.")
	}

	call := struct {
	}{}

	m.calls.RemoveCurrentDir = append(m.calls.RemoveCurrentDir, call)

	return m.RemoveCurrentDirFunc()
}

// RemoveCurrentDirCalled returns true if RemoveCurrentDir was called at least once.
func (m *MockConfluentCurrent) RemoveCurrentDirCalled() bool {
	m.lockRemoveCurrentDir.Lock()
	defer m.lockRemoveCurrentDir.Unlock()

	return len(m.calls.RemoveCurrentDir) > 0
}

// RemoveCurrentDirCalls returns the calls made to RemoveCurrentDir.
func (m *MockConfluentCurrent) RemoveCurrentDirCalls() []struct {
} {
	m.lockRemoveCurrentDir.Lock()
	defer m.lockRemoveCurrentDir.Unlock()

	return m.calls.RemoveCurrentDir
}

// GetServiceDir mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) GetServiceDir(service string) (string, error) {
	m.lockGetServiceDir.Lock()
	defer m.lockGetServiceDir.Unlock()

	if m.GetServiceDirFunc == nil {
		panic("mocker: MockConfluentCurrent.GetServiceDirFunc is nil but MockConfluentCurrent.GetServiceDir was called.")
	}

	call := struct {
		Service string
	}{
		Service: service,
	}

	m.calls.GetServiceDir = append(m.calls.GetServiceDir, call)

	return m.GetServiceDirFunc(service)
}

// GetServiceDirCalled returns true if GetServiceDir was called at least once.
func (m *MockConfluentCurrent) GetServiceDirCalled() bool {
	m.lockGetServiceDir.Lock()
	defer m.lockGetServiceDir.Unlock()

	return len(m.calls.GetServiceDir) > 0
}

// GetServiceDirCalls returns the calls made to GetServiceDir.
func (m *MockConfluentCurrent) GetServiceDirCalls() []struct {
	Service string
} {
	m.lockGetServiceDir.Lock()
	defer m.lockGetServiceDir.Unlock()

	return m.calls.GetServiceDir
}

// GetDataDir mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) GetDataDir(service string) (string, error) {
	m.lockGetDataDir.Lock()
	defer m.lockGetDataDir.Unlock()

	if m.GetDataDirFunc == nil {
		panic("mocker: MockConfluentCurrent.GetDataDirFunc is nil but MockConfluentCurrent.GetDataDir was called.")
	}

	call := struct {
		Service string
	}{
		Service: service,
	}

	m.calls.GetDataDir = append(m.calls.GetDataDir, call)

	return m.GetDataDirFunc(service)
}

// GetDataDirCalled returns true if GetDataDir was called at least once.
func (m *MockConfluentCurrent) GetDataDirCalled() bool {
	m.lockGetDataDir.Lock()
	defer m.lockGetDataDir.Unlock()

	return len(m.calls.GetDataDir) > 0
}

// GetDataDirCalls returns the calls made to GetDataDir.
func (m *MockConfluentCurrent) GetDataDirCalls() []struct {
	Service string
} {
	m.lockGetDataDir.Lock()
	defer m.lockGetDataDir.Unlock()

	return m.calls.GetDataDir
}

// GetConfigFile mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) GetConfigFile(service string) (string, error) {
	m.lockGetConfigFile.Lock()
	defer m.lockGetConfigFile.Unlock()

	if m.GetConfigFileFunc == nil {
		panic("mocker: MockConfluentCurrent.GetConfigFileFunc is nil but MockConfluentCurrent.GetConfigFile was called.")
	}

	call := struct {
		Service string
	}{
		Service: service,
	}

	m.calls.GetConfigFile = append(m.calls.GetConfigFile, call)

	return m.GetConfigFileFunc(service)
}

// GetConfigFileCalled returns true if GetConfigFile was called at least once.
func (m *MockConfluentCurrent) GetConfigFileCalled() bool {
	m.lockGetConfigFile.Lock()
	defer m.lockGetConfigFile.Unlock()

	return len(m.calls.GetConfigFile) > 0
}

// GetConfigFileCalls returns the calls made to GetConfigFile.
func (m *MockConfluentCurrent) GetConfigFileCalls() []struct {
	Service string
} {
	m.lockGetConfigFile.Lock()
	defer m.lockGetConfigFile.Unlock()

	return m.calls.GetConfigFile
}

// SetConfig mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) SetConfig(service string, config []byte) error {
	m.lockSetConfig.Lock()
	defer m.lockSetConfig.Unlock()

	if m.SetConfigFunc == nil {
		panic("mocker: MockConfluentCurrent.SetConfigFunc is nil but MockConfluentCurrent.SetConfig was called.")
	}

	call := struct {
		Service string
		Config  []byte
	}{
		Service: service,
		Config:  config,
	}

	m.calls.SetConfig = append(m.calls.SetConfig, call)

	return m.SetConfigFunc(service, config)
}

// SetConfigCalled returns true if SetConfig was called at least once.
func (m *MockConfluentCurrent) SetConfigCalled() bool {
	m.lockSetConfig.Lock()
	defer m.lockSetConfig.Unlock()

	return len(m.calls.SetConfig) > 0
}

// SetConfigCalls returns the calls made to SetConfig.
func (m *MockConfluentCurrent) SetConfigCalls() []struct {
	Service string
	Config  []byte
} {
	m.lockSetConfig.Lock()
	defer m.lockSetConfig.Unlock()

	return m.calls.SetConfig
}

// GetLogFile mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) GetLogFile(service string) (string, error) {
	m.lockGetLogFile.Lock()
	defer m.lockGetLogFile.Unlock()

	if m.GetLogFileFunc == nil {
		panic("mocker: MockConfluentCurrent.GetLogFileFunc is nil but MockConfluentCurrent.GetLogFile was called.")
	}

	call := struct {
		Service string
	}{
		Service: service,
	}

	m.calls.GetLogFile = append(m.calls.GetLogFile, call)

	return m.GetLogFileFunc(service)
}

// GetLogFileCalled returns true if GetLogFile was called at least once.
func (m *MockConfluentCurrent) GetLogFileCalled() bool {
	m.lockGetLogFile.Lock()
	defer m.lockGetLogFile.Unlock()

	return len(m.calls.GetLogFile) > 0
}

// GetLogFileCalls returns the calls made to GetLogFile.
func (m *MockConfluentCurrent) GetLogFileCalls() []struct {
	Service string
} {
	m.lockGetLogFile.Lock()
	defer m.lockGetLogFile.Unlock()

	return m.calls.GetLogFile
}

// GetPidFile mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) GetPidFile(service string) (string, error) {
	m.lockGetPidFile.Lock()
	defer m.lockGetPidFile.Unlock()

	if m.GetPidFileFunc == nil {
		panic("mocker: MockConfluentCurrent.GetPidFileFunc is nil but MockConfluentCurrent.GetPidFile was called.")
	}

	call := struct {
		Service string
	}{
		Service: service,
	}

	m.calls.GetPidFile = append(m.calls.GetPidFile, call)

	return m.GetPidFileFunc(service)
}

// GetPidFileCalled returns true if GetPidFile was called at least once.
func (m *MockConfluentCurrent) GetPidFileCalled() bool {
	m.lockGetPidFile.Lock()
	defer m.lockGetPidFile.Unlock()

	return len(m.calls.GetPidFile) > 0
}

// GetPidFileCalls returns the calls made to GetPidFile.
func (m *MockConfluentCurrent) GetPidFileCalls() []struct {
	Service string
} {
	m.lockGetPidFile.Lock()
	defer m.lockGetPidFile.Unlock()

	return m.calls.GetPidFile
}

// HasPidFile mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) HasPidFile(service string) (bool, error) {
	m.lockHasPidFile.Lock()
	defer m.lockHasPidFile.Unlock()

	if m.HasPidFileFunc == nil {
		panic("mocker: MockConfluentCurrent.HasPidFileFunc is nil but MockConfluentCurrent.HasPidFile was called.")
	}

	call := struct {
		Service string
	}{
		Service: service,
	}

	m.calls.HasPidFile = append(m.calls.HasPidFile, call)

	return m.HasPidFileFunc(service)
}

// HasPidFileCalled returns true if HasPidFile was called at least once.
func (m *MockConfluentCurrent) HasPidFileCalled() bool {
	m.lockHasPidFile.Lock()
	defer m.lockHasPidFile.Unlock()

	return len(m.calls.HasPidFile) > 0
}

// HasPidFileCalls returns the calls made to HasPidFile.
func (m *MockConfluentCurrent) HasPidFileCalls() []struct {
	Service string
} {
	m.lockHasPidFile.Lock()
	defer m.lockHasPidFile.Unlock()

	return m.calls.HasPidFile
}

// GetPid mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) GetPid(service string) (int, error) {
	m.lockGetPid.Lock()
	defer m.lockGetPid.Unlock()

	if m.GetPidFunc == nil {
		panic("mocker: MockConfluentCurrent.GetPidFunc is nil but MockConfluentCurrent.GetPid was called.")
	}

	call := struct {
		Service string
	}{
		Service: service,
	}

	m.calls.GetPid = append(m.calls.GetPid, call)

	return m.GetPidFunc(service)
}

// GetPidCalled returns true if GetPid was called at least once.
func (m *MockConfluentCurrent) GetPidCalled() bool {
	m.lockGetPid.Lock()
	defer m.lockGetPid.Unlock()

	return len(m.calls.GetPid) > 0
}

// GetPidCalls returns the calls made to GetPid.
func (m *MockConfluentCurrent) GetPidCalls() []struct {
	Service string
} {
	m.lockGetPid.Lock()
	defer m.lockGetPid.Unlock()

	return m.calls.GetPid
}

// SetPid mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) SetPid(service string, pid int) error {
	m.lockSetPid.Lock()
	defer m.lockSetPid.Unlock()

	if m.SetPidFunc == nil {
		panic("mocker: MockConfluentCurrent.SetPidFunc is nil but MockConfluentCurrent.SetPid was called.")
	}

	call := struct {
		Service string
		Pid     int
	}{
		Service: service,
		Pid:     pid,
	}

	m.calls.SetPid = append(m.calls.SetPid, call)

	return m.SetPidFunc(service, pid)
}

// SetPidCalled returns true if SetPid was called at least once.
func (m *MockConfluentCurrent) SetPidCalled() bool {
	m.lockSetPid.Lock()
	defer m.lockSetPid.Unlock()

	return len(m.calls.SetPid) > 0
}

// SetPidCalls returns the calls made to SetPid.
func (m *MockConfluentCurrent) SetPidCalls() []struct {
	Service string
	Pid     int
} {
	m.lockSetPid.Lock()
	defer m.lockSetPid.Unlock()

	return m.calls.SetPid
}

// RemovePidFile mocks base method by wrapping the associated func.
func (m *MockConfluentCurrent) RemovePidFile(service string) error {
	m.lockRemovePidFile.Lock()
	defer m.lockRemovePidFile.Unlock()

	if m.RemovePidFileFunc == nil {
		panic("mocker: MockConfluentCurrent.RemovePidFileFunc is nil but MockConfluentCurrent.RemovePidFile was called.")
	}

	call := struct {
		Service string
	}{
		Service: service,
	}

	m.calls.RemovePidFile = append(m.calls.RemovePidFile, call)

	return m.RemovePidFileFunc(service)
}

// RemovePidFileCalled returns true if RemovePidFile was called at least once.
func (m *MockConfluentCurrent) RemovePidFileCalled() bool {
	m.lockRemovePidFile.Lock()
	defer m.lockRemovePidFile.Unlock()

	return len(m.calls.RemovePidFile) > 0
}

// RemovePidFileCalls returns the calls made to RemovePidFile.
func (m *MockConfluentCurrent) RemovePidFileCalls() []struct {
	Service string
} {
	m.lockRemovePidFile.Lock()
	defer m.lockRemovePidFile.Unlock()

	return m.calls.RemovePidFile
}

// Reset resets the calls made to the mocked methods.
func (m *MockConfluentCurrent) Reset() {
	m.lockRemoveTrackingFile.Lock()
	m.calls.RemoveTrackingFile = nil
	m.lockRemoveTrackingFile.Unlock()
	m.lockGetCurrentDir.Lock()
	m.calls.GetCurrentDir = nil
	m.lockGetCurrentDir.Unlock()
	m.lockRemoveCurrentDir.Lock()
	m.calls.RemoveCurrentDir = nil
	m.lockRemoveCurrentDir.Unlock()
	m.lockGetServiceDir.Lock()
	m.calls.GetServiceDir = nil
	m.lockGetServiceDir.Unlock()
	m.lockGetDataDir.Lock()
	m.calls.GetDataDir = nil
	m.lockGetDataDir.Unlock()
	m.lockGetConfigFile.Lock()
	m.calls.GetConfigFile = nil
	m.lockGetConfigFile.Unlock()
	m.lockSetConfig.Lock()
	m.calls.SetConfig = nil
	m.lockSetConfig.Unlock()
	m.lockGetLogFile.Lock()
	m.calls.GetLogFile = nil
	m.lockGetLogFile.Unlock()
	m.lockGetPidFile.Lock()
	m.calls.GetPidFile = nil
	m.lockGetPidFile.Unlock()
	m.lockHasPidFile.Lock()
	m.calls.HasPidFile = nil
	m.lockHasPidFile.Unlock()
	m.lockGetPid.Lock()
	m.calls.GetPid = nil
	m.lockGetPid.Unlock()
	m.lockSetPid.Lock()
	m.calls.SetPid = nil
	m.lockSetPid.Unlock()
	m.lockRemovePidFile.Lock()
	m.calls.RemovePidFile = nil
	m.lockRemovePidFile.Unlock()
}
