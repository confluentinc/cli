// Code generated by mocker; DO NOT EDIT
// github.com/travisjeffery/mocker
package mock

import (
	orgv1 "github.com/confluentinc/cc-structs/kafka/org/v1"
	"net/http"
	"sync"
)

var (
	lockUserDescribe sync.RWMutex
	lockUserList     sync.RWMutex
)

// User is a mock implementation of User.
//
//     func TestSomethingThatUsesUser(t *testing.T) {
//
//         // make and configure a mocked User
//         mockedUser := &User{
//             DescribeFunc: func(user *orgv1.User) (*orgv1.User, *http.Response, error) {
// 	               panic("TODO: mock out the Describe method")
//             },
//             ListFunc: func() ([]*orgv1.User, *http.Response, error) {
// 	               panic("TODO: mock out the List method")
//             },
//         }
//
//         // TODO: use mockedUser in code that requires User
//         //       and then make assertions.
//
//     }
type User struct {
	// DescribeFunc mocks the Describe method.
	DescribeFunc func(user *orgv1.User) (*orgv1.User, *http.Response, error)

	// ListFunc mocks the List method.
	ListFunc func() ([]*orgv1.User, *http.Response, error)

	// calls tracks calls to the methods.
	calls struct {
		// Describe holds details about calls to the Describe method.
		Describe []struct {
			// User is the user argument value.
			User *orgv1.User
		}
		// List holds details about calls to the List method.
		List []struct {
		}
	}
}

// Reset resets the calls made to the mocked APIs.
func (mock *User) Reset() {
	lockUserDescribe.Lock()
	mock.calls.Describe = nil
	lockUserDescribe.Unlock()
	lockUserList.Lock()
	mock.calls.List = nil
	lockUserList.Unlock()
}

// Describe calls DescribeFunc.
func (mock *User) Describe(user *orgv1.User) (*orgv1.User, *http.Response, error) {
	if mock.DescribeFunc == nil {
		panic("moq: User.DescribeFunc is nil but User.Describe was just called")
	}
	callInfo := struct {
		User *orgv1.User
	}{
		User: user,
	}
	lockUserDescribe.Lock()
	mock.calls.Describe = append(mock.calls.Describe, callInfo)
	lockUserDescribe.Unlock()
	return mock.DescribeFunc(user)
}

// DescribeCalled returns true if at least one call was made to Describe.
func (mock *User) DescribeCalled() bool {
	lockUserDescribe.RLock()
	defer lockUserDescribe.RUnlock()
	return len(mock.calls.Describe) > 0
}

// DescribeCalls gets all the calls that were made to Describe.
// Check the length with:
//     len(mockedUser.DescribeCalls())
func (mock *User) DescribeCalls() []struct {
	User *orgv1.User
} {
	var calls []struct {
		User *orgv1.User
	}
	lockUserDescribe.RLock()
	calls = mock.calls.Describe
	lockUserDescribe.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *User) List() ([]*orgv1.User, *http.Response, error) {
	if mock.ListFunc == nil {
		panic("moq: User.ListFunc is nil but User.List was just called")
	}
	callInfo := struct {
	}{}
	lockUserList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	lockUserList.Unlock()
	return mock.ListFunc()
}

// ListCalled returns true if at least one call was made to List.
func (mock *User) ListCalled() bool {
	lockUserList.RLock()
	defer lockUserList.RUnlock()
	return len(mock.calls.List) > 0
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//     len(mockedUser.ListCalls())
func (mock *User) ListCalls() []struct {
} {
	var calls []struct {
	}
	lockUserList.RLock()
	calls = mock.calls.List
	lockUserList.RUnlock()
	return calls
}
