// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: analytics.go

package mock

import (
	sync "sync"

	github_com_confluentinc_cli_internal_pkg_analytics "github.com/confluentinc/cli/internal/pkg/analytics"
	github_com_spf13_cobra "github.com/spf13/cobra"
)

// AnalyticsClient is a mock of Client interface
type AnalyticsClient struct {
	lockSetStartTime sync.Mutex
	SetStartTimeFunc func()

	lockTrackCommand sync.Mutex
	TrackCommandFunc func(cmd *github_com_spf13_cobra.Command, args []string)

	lockCatchHelpCall sync.Mutex
	CatchHelpCallFunc func(rootCmd *github_com_spf13_cobra.Command, args []string)

	lockSendCommandSucceeded sync.Mutex
	SendCommandSucceededFunc func() error

	lockSendCommandFailed sync.Mutex
	SendCommandFailedFunc func(e error) error

	lockSetCommandType sync.Mutex
	SetCommandTypeFunc func(commandType github_com_confluentinc_cli_internal_pkg_analytics.CommandType)

	lockSessionTimedOut sync.Mutex
	SessionTimedOutFunc func() error

	lockClose sync.Mutex
	CloseFunc func() error

	calls struct {
		SetStartTime []struct {
		}
		TrackCommand []struct {
			Cmd  *github_com_spf13_cobra.Command
			Args []string
		}
		CatchHelpCall []struct {
			RootCmd *github_com_spf13_cobra.Command
			Args    []string
		}
		SendCommandSucceeded []struct {
		}
		SendCommandFailed []struct {
			E error
		}
		SetCommandType []struct {
			CommandType github_com_confluentinc_cli_internal_pkg_analytics.CommandType
		}
		SessionTimedOut []struct {
		}
		Close []struct {
		}
	}
}

// SetStartTime mocks base method by wrapping the associated func.
func (m *AnalyticsClient) SetStartTime() {
	m.lockSetStartTime.Lock()
	defer m.lockSetStartTime.Unlock()

	if m.SetStartTimeFunc == nil {
		panic("mocker: AnalyticsClient.SetStartTimeFunc is nil but AnalyticsClient.SetStartTime was called.")
	}

	call := struct {
	}{}

	m.calls.SetStartTime = append(m.calls.SetStartTime, call)

	m.SetStartTimeFunc()
}

// SetStartTimeCalled returns true if SetStartTime was called at least once.
func (m *AnalyticsClient) SetStartTimeCalled() bool {
	m.lockSetStartTime.Lock()
	defer m.lockSetStartTime.Unlock()

	return len(m.calls.SetStartTime) > 0
}

// SetStartTimeCalls returns the calls made to SetStartTime.
func (m *AnalyticsClient) SetStartTimeCalls() []struct {
} {
	m.lockSetStartTime.Lock()
	defer m.lockSetStartTime.Unlock()

	return m.calls.SetStartTime
}

// TrackCommand mocks base method by wrapping the associated func.
func (m *AnalyticsClient) TrackCommand(cmd *github_com_spf13_cobra.Command, args []string) {
	m.lockTrackCommand.Lock()
	defer m.lockTrackCommand.Unlock()

	if m.TrackCommandFunc == nil {
		panic("mocker: AnalyticsClient.TrackCommandFunc is nil but AnalyticsClient.TrackCommand was called.")
	}

	call := struct {
		Cmd  *github_com_spf13_cobra.Command
		Args []string
	}{
		Cmd:  cmd,
		Args: args,
	}

	m.calls.TrackCommand = append(m.calls.TrackCommand, call)

	m.TrackCommandFunc(cmd, args)
}

// TrackCommandCalled returns true if TrackCommand was called at least once.
func (m *AnalyticsClient) TrackCommandCalled() bool {
	m.lockTrackCommand.Lock()
	defer m.lockTrackCommand.Unlock()

	return len(m.calls.TrackCommand) > 0
}

// TrackCommandCalls returns the calls made to TrackCommand.
func (m *AnalyticsClient) TrackCommandCalls() []struct {
	Cmd  *github_com_spf13_cobra.Command
	Args []string
} {
	m.lockTrackCommand.Lock()
	defer m.lockTrackCommand.Unlock()

	return m.calls.TrackCommand
}

// CatchHelpCall mocks base method by wrapping the associated func.
func (m *AnalyticsClient) CatchHelpCall(rootCmd *github_com_spf13_cobra.Command, args []string) {
	m.lockCatchHelpCall.Lock()
	defer m.lockCatchHelpCall.Unlock()

	if m.CatchHelpCallFunc == nil {
		panic("mocker: AnalyticsClient.CatchHelpCallFunc is nil but AnalyticsClient.CatchHelpCall was called.")
	}

	call := struct {
		RootCmd *github_com_spf13_cobra.Command
		Args    []string
	}{
		RootCmd: rootCmd,
		Args:    args,
	}

	m.calls.CatchHelpCall = append(m.calls.CatchHelpCall, call)

	m.CatchHelpCallFunc(rootCmd, args)
}

// CatchHelpCallCalled returns true if CatchHelpCall was called at least once.
func (m *AnalyticsClient) CatchHelpCallCalled() bool {
	m.lockCatchHelpCall.Lock()
	defer m.lockCatchHelpCall.Unlock()

	return len(m.calls.CatchHelpCall) > 0
}

// CatchHelpCallCalls returns the calls made to CatchHelpCall.
func (m *AnalyticsClient) CatchHelpCallCalls() []struct {
	RootCmd *github_com_spf13_cobra.Command
	Args    []string
} {
	m.lockCatchHelpCall.Lock()
	defer m.lockCatchHelpCall.Unlock()

	return m.calls.CatchHelpCall
}

// SendCommandSucceeded mocks base method by wrapping the associated func.
func (m *AnalyticsClient) SendCommandSucceeded() error {
	m.lockSendCommandSucceeded.Lock()
	defer m.lockSendCommandSucceeded.Unlock()

	if m.SendCommandSucceededFunc == nil {
		panic("mocker: AnalyticsClient.SendCommandSucceededFunc is nil but AnalyticsClient.SendCommandSucceeded was called.")
	}

	call := struct {
	}{}

	m.calls.SendCommandSucceeded = append(m.calls.SendCommandSucceeded, call)

	return m.SendCommandSucceededFunc()
}

// SendCommandSucceededCalled returns true if SendCommandSucceeded was called at least once.
func (m *AnalyticsClient) SendCommandSucceededCalled() bool {
	m.lockSendCommandSucceeded.Lock()
	defer m.lockSendCommandSucceeded.Unlock()

	return len(m.calls.SendCommandSucceeded) > 0
}

// SendCommandSucceededCalls returns the calls made to SendCommandSucceeded.
func (m *AnalyticsClient) SendCommandSucceededCalls() []struct {
} {
	m.lockSendCommandSucceeded.Lock()
	defer m.lockSendCommandSucceeded.Unlock()

	return m.calls.SendCommandSucceeded
}

// SendCommandFailed mocks base method by wrapping the associated func.
func (m *AnalyticsClient) SendCommandFailed(e error) error {
	m.lockSendCommandFailed.Lock()
	defer m.lockSendCommandFailed.Unlock()

	if m.SendCommandFailedFunc == nil {
		panic("mocker: AnalyticsClient.SendCommandFailedFunc is nil but AnalyticsClient.SendCommandFailed was called.")
	}

	call := struct {
		E error
	}{
		E: e,
	}

	m.calls.SendCommandFailed = append(m.calls.SendCommandFailed, call)

	return m.SendCommandFailedFunc(e)
}

// SendCommandFailedCalled returns true if SendCommandFailed was called at least once.
func (m *AnalyticsClient) SendCommandFailedCalled() bool {
	m.lockSendCommandFailed.Lock()
	defer m.lockSendCommandFailed.Unlock()

	return len(m.calls.SendCommandFailed) > 0
}

// SendCommandFailedCalls returns the calls made to SendCommandFailed.
func (m *AnalyticsClient) SendCommandFailedCalls() []struct {
	E error
} {
	m.lockSendCommandFailed.Lock()
	defer m.lockSendCommandFailed.Unlock()

	return m.calls.SendCommandFailed
}

// SetCommandType mocks base method by wrapping the associated func.
func (m *AnalyticsClient) SetCommandType(commandType github_com_confluentinc_cli_internal_pkg_analytics.CommandType) {
	m.lockSetCommandType.Lock()
	defer m.lockSetCommandType.Unlock()

	if m.SetCommandTypeFunc == nil {
		panic("mocker: AnalyticsClient.SetCommandTypeFunc is nil but AnalyticsClient.SetCommandType was called.")
	}

	call := struct {
		CommandType github_com_confluentinc_cli_internal_pkg_analytics.CommandType
	}{
		CommandType: commandType,
	}

	m.calls.SetCommandType = append(m.calls.SetCommandType, call)

	m.SetCommandTypeFunc(commandType)
}

// SetCommandTypeCalled returns true if SetCommandType was called at least once.
func (m *AnalyticsClient) SetCommandTypeCalled() bool {
	m.lockSetCommandType.Lock()
	defer m.lockSetCommandType.Unlock()

	return len(m.calls.SetCommandType) > 0
}

// SetCommandTypeCalls returns the calls made to SetCommandType.
func (m *AnalyticsClient) SetCommandTypeCalls() []struct {
	CommandType github_com_confluentinc_cli_internal_pkg_analytics.CommandType
} {
	m.lockSetCommandType.Lock()
	defer m.lockSetCommandType.Unlock()

	return m.calls.SetCommandType
}

// SessionTimedOut mocks base method by wrapping the associated func.
func (m *AnalyticsClient) SessionTimedOut() error {
	m.lockSessionTimedOut.Lock()
	defer m.lockSessionTimedOut.Unlock()

	if m.SessionTimedOutFunc == nil {
		panic("mocker: AnalyticsClient.SessionTimedOutFunc is nil but AnalyticsClient.SessionTimedOut was called.")
	}

	call := struct {
	}{}

	m.calls.SessionTimedOut = append(m.calls.SessionTimedOut, call)

	return m.SessionTimedOutFunc()
}

// SessionTimedOutCalled returns true if SessionTimedOut was called at least once.
func (m *AnalyticsClient) SessionTimedOutCalled() bool {
	m.lockSessionTimedOut.Lock()
	defer m.lockSessionTimedOut.Unlock()

	return len(m.calls.SessionTimedOut) > 0
}

// SessionTimedOutCalls returns the calls made to SessionTimedOut.
func (m *AnalyticsClient) SessionTimedOutCalls() []struct {
} {
	m.lockSessionTimedOut.Lock()
	defer m.lockSessionTimedOut.Unlock()

	return m.calls.SessionTimedOut
}

// Close mocks base method by wrapping the associated func.
func (m *AnalyticsClient) Close() error {
	m.lockClose.Lock()
	defer m.lockClose.Unlock()

	if m.CloseFunc == nil {
		panic("mocker: AnalyticsClient.CloseFunc is nil but AnalyticsClient.Close was called.")
	}

	call := struct {
	}{}

	m.calls.Close = append(m.calls.Close, call)

	return m.CloseFunc()
}

// CloseCalled returns true if Close was called at least once.
func (m *AnalyticsClient) CloseCalled() bool {
	m.lockClose.Lock()
	defer m.lockClose.Unlock()

	return len(m.calls.Close) > 0
}

// CloseCalls returns the calls made to Close.
func (m *AnalyticsClient) CloseCalls() []struct {
} {
	m.lockClose.Lock()
	defer m.lockClose.Unlock()

	return m.calls.Close
}

// Reset resets the calls made to the mocked methods.
func (m *AnalyticsClient) Reset() {
	m.lockSetStartTime.Lock()
	m.calls.SetStartTime = nil
	m.lockSetStartTime.Unlock()
	m.lockTrackCommand.Lock()
	m.calls.TrackCommand = nil
	m.lockTrackCommand.Unlock()
	m.lockCatchHelpCall.Lock()
	m.calls.CatchHelpCall = nil
	m.lockCatchHelpCall.Unlock()
	m.lockSendCommandSucceeded.Lock()
	m.calls.SendCommandSucceeded = nil
	m.lockSendCommandSucceeded.Unlock()
	m.lockSendCommandFailed.Lock()
	m.calls.SendCommandFailed = nil
	m.lockSendCommandFailed.Unlock()
	m.lockSetCommandType.Lock()
	m.calls.SetCommandType = nil
	m.lockSetCommandType.Unlock()
	m.lockSessionTimedOut.Lock()
	m.calls.SessionTimedOut = nil
	m.lockSessionTimedOut.Unlock()
	m.lockClose.Lock()
	m.calls.Close = nil
	m.lockClose.Unlock()
}
