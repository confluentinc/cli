// Code generated by mocker; DO NOT EDIT
// github.com/travisjeffery/mocker
package mock

import (
	schedv1 "github.com/confluentinc/cc-structs/kafka/scheduler/v1"
	"net/http"
	"sync"
)

var (
	lockConnectCreateS3Sink   sync.RWMutex
	lockConnectDelete         sync.RWMutex
	lockConnectDescribe       sync.RWMutex
	lockConnectDescribeS3Sink sync.RWMutex
	lockConnectList           sync.RWMutex
	lockConnectUpdateS3Sink   sync.RWMutex
)

// Connect is a mock implementation of Connect.
//
//     func TestSomethingThatUsesConnect(t *testing.T) {
//
//         // make and configure a mocked Connect
//         mockedConnect := &Connect{
//             CreateS3SinkFunc: func(config *schedv1.ConnectS3SinkClusterConfig) (*schedv1.ConnectS3SinkCluster, *http.Response, error) {
// 	               panic("TODO: mock out the CreateS3Sink method")
//             },
//             DeleteFunc: func(cluster *schedv1.ConnectCluster) (*http.Response, error) {
// 	               panic("TODO: mock out the Delete method")
//             },
//             DescribeFunc: func(cluster *schedv1.ConnectCluster) (*schedv1.ConnectCluster, *http.Response, error) {
// 	               panic("TODO: mock out the Describe method")
//             },
//             DescribeS3SinkFunc: func(cluster *schedv1.ConnectS3SinkCluster) (*schedv1.ConnectS3SinkCluster, *http.Response, error) {
// 	               panic("TODO: mock out the DescribeS3Sink method")
//             },
//             ListFunc: func(cluster *schedv1.ConnectCluster) ([]*schedv1.ConnectCluster, *http.Response, error) {
// 	               panic("TODO: mock out the List method")
//             },
//             UpdateS3SinkFunc: func(cluster *schedv1.ConnectS3SinkCluster) (*schedv1.ConnectS3SinkCluster, *http.Response, error) {
// 	               panic("TODO: mock out the UpdateS3Sink method")
//             },
//         }
//
//         // TODO: use mockedConnect in code that requires Connect
//         //       and then make assertions.
//
//     }
type Connect struct {
	// CreateS3SinkFunc mocks the CreateS3Sink method.
	CreateS3SinkFunc func(config *schedv1.ConnectS3SinkClusterConfig) (*schedv1.ConnectS3SinkCluster, *http.Response, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(cluster *schedv1.ConnectCluster) (*http.Response, error)

	// DescribeFunc mocks the Describe method.
	DescribeFunc func(cluster *schedv1.ConnectCluster) (*schedv1.ConnectCluster, *http.Response, error)

	// DescribeS3SinkFunc mocks the DescribeS3Sink method.
	DescribeS3SinkFunc func(cluster *schedv1.ConnectS3SinkCluster) (*schedv1.ConnectS3SinkCluster, *http.Response, error)

	// ListFunc mocks the List method.
	ListFunc func(cluster *schedv1.ConnectCluster) ([]*schedv1.ConnectCluster, *http.Response, error)

	// UpdateS3SinkFunc mocks the UpdateS3Sink method.
	UpdateS3SinkFunc func(cluster *schedv1.ConnectS3SinkCluster) (*schedv1.ConnectS3SinkCluster, *http.Response, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateS3Sink holds details about calls to the CreateS3Sink method.
		CreateS3Sink []struct {
			// Config is the config argument value.
			Config *schedv1.ConnectS3SinkClusterConfig
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Cluster is the cluster argument value.
			Cluster *schedv1.ConnectCluster
		}
		// Describe holds details about calls to the Describe method.
		Describe []struct {
			// Cluster is the cluster argument value.
			Cluster *schedv1.ConnectCluster
		}
		// DescribeS3Sink holds details about calls to the DescribeS3Sink method.
		DescribeS3Sink []struct {
			// Cluster is the cluster argument value.
			Cluster *schedv1.ConnectS3SinkCluster
		}
		// List holds details about calls to the List method.
		List []struct {
			// Cluster is the cluster argument value.
			Cluster *schedv1.ConnectCluster
		}
		// UpdateS3Sink holds details about calls to the UpdateS3Sink method.
		UpdateS3Sink []struct {
			// Cluster is the cluster argument value.
			Cluster *schedv1.ConnectS3SinkCluster
		}
	}
}

// Reset resets the calls made to the mocked APIs.
func (mock *Connect) Reset() {
	lockConnectCreateS3Sink.Lock()
	mock.calls.CreateS3Sink = nil
	lockConnectCreateS3Sink.Unlock()
	lockConnectDelete.Lock()
	mock.calls.Delete = nil
	lockConnectDelete.Unlock()
	lockConnectDescribe.Lock()
	mock.calls.Describe = nil
	lockConnectDescribe.Unlock()
	lockConnectDescribeS3Sink.Lock()
	mock.calls.DescribeS3Sink = nil
	lockConnectDescribeS3Sink.Unlock()
	lockConnectList.Lock()
	mock.calls.List = nil
	lockConnectList.Unlock()
	lockConnectUpdateS3Sink.Lock()
	mock.calls.UpdateS3Sink = nil
	lockConnectUpdateS3Sink.Unlock()
}

// CreateS3Sink calls CreateS3SinkFunc.
func (mock *Connect) CreateS3Sink(config *schedv1.ConnectS3SinkClusterConfig) (*schedv1.ConnectS3SinkCluster, *http.Response, error) {
	if mock.CreateS3SinkFunc == nil {
		panic("moq: Connect.CreateS3SinkFunc is nil but Connect.CreateS3Sink was just called")
	}
	callInfo := struct {
		Config *schedv1.ConnectS3SinkClusterConfig
	}{
		Config: config,
	}
	lockConnectCreateS3Sink.Lock()
	mock.calls.CreateS3Sink = append(mock.calls.CreateS3Sink, callInfo)
	lockConnectCreateS3Sink.Unlock()
	return mock.CreateS3SinkFunc(config)
}

// CreateS3SinkCalled returns true if at least one call was made to CreateS3Sink.
func (mock *Connect) CreateS3SinkCalled() bool {
	lockConnectCreateS3Sink.RLock()
	defer lockConnectCreateS3Sink.RUnlock()
	return len(mock.calls.CreateS3Sink) > 0
}

// CreateS3SinkCalls gets all the calls that were made to CreateS3Sink.
// Check the length with:
//     len(mockedConnect.CreateS3SinkCalls())
func (mock *Connect) CreateS3SinkCalls() []struct {
	Config *schedv1.ConnectS3SinkClusterConfig
} {
	var calls []struct {
		Config *schedv1.ConnectS3SinkClusterConfig
	}
	lockConnectCreateS3Sink.RLock()
	calls = mock.calls.CreateS3Sink
	lockConnectCreateS3Sink.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *Connect) Delete(cluster *schedv1.ConnectCluster) (*http.Response, error) {
	if mock.DeleteFunc == nil {
		panic("moq: Connect.DeleteFunc is nil but Connect.Delete was just called")
	}
	callInfo := struct {
		Cluster *schedv1.ConnectCluster
	}{
		Cluster: cluster,
	}
	lockConnectDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	lockConnectDelete.Unlock()
	return mock.DeleteFunc(cluster)
}

// DeleteCalled returns true if at least one call was made to Delete.
func (mock *Connect) DeleteCalled() bool {
	lockConnectDelete.RLock()
	defer lockConnectDelete.RUnlock()
	return len(mock.calls.Delete) > 0
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedConnect.DeleteCalls())
func (mock *Connect) DeleteCalls() []struct {
	Cluster *schedv1.ConnectCluster
} {
	var calls []struct {
		Cluster *schedv1.ConnectCluster
	}
	lockConnectDelete.RLock()
	calls = mock.calls.Delete
	lockConnectDelete.RUnlock()
	return calls
}

// Describe calls DescribeFunc.
func (mock *Connect) Describe(cluster *schedv1.ConnectCluster) (*schedv1.ConnectCluster, *http.Response, error) {
	if mock.DescribeFunc == nil {
		panic("moq: Connect.DescribeFunc is nil but Connect.Describe was just called")
	}
	callInfo := struct {
		Cluster *schedv1.ConnectCluster
	}{
		Cluster: cluster,
	}
	lockConnectDescribe.Lock()
	mock.calls.Describe = append(mock.calls.Describe, callInfo)
	lockConnectDescribe.Unlock()
	return mock.DescribeFunc(cluster)
}

// DescribeCalled returns true if at least one call was made to Describe.
func (mock *Connect) DescribeCalled() bool {
	lockConnectDescribe.RLock()
	defer lockConnectDescribe.RUnlock()
	return len(mock.calls.Describe) > 0
}

// DescribeCalls gets all the calls that were made to Describe.
// Check the length with:
//     len(mockedConnect.DescribeCalls())
func (mock *Connect) DescribeCalls() []struct {
	Cluster *schedv1.ConnectCluster
} {
	var calls []struct {
		Cluster *schedv1.ConnectCluster
	}
	lockConnectDescribe.RLock()
	calls = mock.calls.Describe
	lockConnectDescribe.RUnlock()
	return calls
}

// DescribeS3Sink calls DescribeS3SinkFunc.
func (mock *Connect) DescribeS3Sink(cluster *schedv1.ConnectS3SinkCluster) (*schedv1.ConnectS3SinkCluster, *http.Response, error) {
	if mock.DescribeS3SinkFunc == nil {
		panic("moq: Connect.DescribeS3SinkFunc is nil but Connect.DescribeS3Sink was just called")
	}
	callInfo := struct {
		Cluster *schedv1.ConnectS3SinkCluster
	}{
		Cluster: cluster,
	}
	lockConnectDescribeS3Sink.Lock()
	mock.calls.DescribeS3Sink = append(mock.calls.DescribeS3Sink, callInfo)
	lockConnectDescribeS3Sink.Unlock()
	return mock.DescribeS3SinkFunc(cluster)
}

// DescribeS3SinkCalled returns true if at least one call was made to DescribeS3Sink.
func (mock *Connect) DescribeS3SinkCalled() bool {
	lockConnectDescribeS3Sink.RLock()
	defer lockConnectDescribeS3Sink.RUnlock()
	return len(mock.calls.DescribeS3Sink) > 0
}

// DescribeS3SinkCalls gets all the calls that were made to DescribeS3Sink.
// Check the length with:
//     len(mockedConnect.DescribeS3SinkCalls())
func (mock *Connect) DescribeS3SinkCalls() []struct {
	Cluster *schedv1.ConnectS3SinkCluster
} {
	var calls []struct {
		Cluster *schedv1.ConnectS3SinkCluster
	}
	lockConnectDescribeS3Sink.RLock()
	calls = mock.calls.DescribeS3Sink
	lockConnectDescribeS3Sink.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *Connect) List(cluster *schedv1.ConnectCluster) ([]*schedv1.ConnectCluster, *http.Response, error) {
	if mock.ListFunc == nil {
		panic("moq: Connect.ListFunc is nil but Connect.List was just called")
	}
	callInfo := struct {
		Cluster *schedv1.ConnectCluster
	}{
		Cluster: cluster,
	}
	lockConnectList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	lockConnectList.Unlock()
	return mock.ListFunc(cluster)
}

// ListCalled returns true if at least one call was made to List.
func (mock *Connect) ListCalled() bool {
	lockConnectList.RLock()
	defer lockConnectList.RUnlock()
	return len(mock.calls.List) > 0
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//     len(mockedConnect.ListCalls())
func (mock *Connect) ListCalls() []struct {
	Cluster *schedv1.ConnectCluster
} {
	var calls []struct {
		Cluster *schedv1.ConnectCluster
	}
	lockConnectList.RLock()
	calls = mock.calls.List
	lockConnectList.RUnlock()
	return calls
}

// UpdateS3Sink calls UpdateS3SinkFunc.
func (mock *Connect) UpdateS3Sink(cluster *schedv1.ConnectS3SinkCluster) (*schedv1.ConnectS3SinkCluster, *http.Response, error) {
	if mock.UpdateS3SinkFunc == nil {
		panic("moq: Connect.UpdateS3SinkFunc is nil but Connect.UpdateS3Sink was just called")
	}
	callInfo := struct {
		Cluster *schedv1.ConnectS3SinkCluster
	}{
		Cluster: cluster,
	}
	lockConnectUpdateS3Sink.Lock()
	mock.calls.UpdateS3Sink = append(mock.calls.UpdateS3Sink, callInfo)
	lockConnectUpdateS3Sink.Unlock()
	return mock.UpdateS3SinkFunc(cluster)
}

// UpdateS3SinkCalled returns true if at least one call was made to UpdateS3Sink.
func (mock *Connect) UpdateS3SinkCalled() bool {
	lockConnectUpdateS3Sink.RLock()
	defer lockConnectUpdateS3Sink.RUnlock()
	return len(mock.calls.UpdateS3Sink) > 0
}

// UpdateS3SinkCalls gets all the calls that were made to UpdateS3Sink.
// Check the length with:
//     len(mockedConnect.UpdateS3SinkCalls())
func (mock *Connect) UpdateS3SinkCalls() []struct {
	Cluster *schedv1.ConnectS3SinkCluster
} {
	var calls []struct {
		Cluster *schedv1.ConnectS3SinkCluster
	}
	lockConnectUpdateS3Sink.RLock()
	calls = mock.calls.UpdateS3Sink
	lockConnectUpdateS3Sink.RUnlock()
	return calls
}
