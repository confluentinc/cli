// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: ./internal/pkg/cmd/prompt.go

package mock

import (
	sync "sync"
)

// Prompt is a mock of Prompt interface
type Prompt struct {
	lockReadString sync.Mutex
	ReadStringFunc func(delim byte) (string, error)

	lockReadPassword sync.Mutex
	ReadPasswordFunc func() ([]byte, error)

	lockIsPipe sync.Mutex
	IsPipeFunc func() (bool, error)

	calls struct {
		ReadString []struct {
			Delim byte
		}
		ReadPassword []struct {
		}
		IsPipe []struct {
		}
	}
}

// ReadString mocks base method by wrapping the associated func.
func (m *Prompt) ReadString(delim byte) (string, error) {
	m.lockReadString.Lock()
	defer m.lockReadString.Unlock()

	if m.ReadStringFunc == nil {
		panic("mocker: Prompt.ReadStringFunc is nil but Prompt.ReadString was called.")
	}

	call := struct {
		Delim byte
	}{
		Delim: delim,
	}

	m.calls.ReadString = append(m.calls.ReadString, call)

	return m.ReadStringFunc(delim)
}

// ReadStringCalled returns true if ReadString was called at least once.
func (m *Prompt) ReadStringCalled() bool {
	m.lockReadString.Lock()
	defer m.lockReadString.Unlock()

	return len(m.calls.ReadString) > 0
}

// ReadStringCalls returns the calls made to ReadString.
func (m *Prompt) ReadStringCalls() []struct {
	Delim byte
} {
	m.lockReadString.Lock()
	defer m.lockReadString.Unlock()

	return m.calls.ReadString
}

// ReadPassword mocks base method by wrapping the associated func.
func (m *Prompt) ReadPassword() ([]byte, error) {
	m.lockReadPassword.Lock()
	defer m.lockReadPassword.Unlock()

	if m.ReadPasswordFunc == nil {
		panic("mocker: Prompt.ReadPasswordFunc is nil but Prompt.ReadPassword was called.")
	}

	call := struct {
	}{}

	m.calls.ReadPassword = append(m.calls.ReadPassword, call)

	return m.ReadPasswordFunc()
}

// ReadPasswordCalled returns true if ReadPassword was called at least once.
func (m *Prompt) ReadPasswordCalled() bool {
	m.lockReadPassword.Lock()
	defer m.lockReadPassword.Unlock()

	return len(m.calls.ReadPassword) > 0
}

// ReadPasswordCalls returns the calls made to ReadPassword.
func (m *Prompt) ReadPasswordCalls() []struct {
} {
	m.lockReadPassword.Lock()
	defer m.lockReadPassword.Unlock()

	return m.calls.ReadPassword
}

// IsPipe mocks base method by wrapping the associated func.
func (m *Prompt) IsPipe() (bool, error) {
	m.lockIsPipe.Lock()
	defer m.lockIsPipe.Unlock()

	if m.IsPipeFunc == nil {
		panic("mocker: Prompt.IsPipeFunc is nil but Prompt.IsPipe was called.")
	}

	call := struct {
	}{}

	m.calls.IsPipe = append(m.calls.IsPipe, call)

	return m.IsPipeFunc()
}

// IsPipeCalled returns true if IsPipe was called at least once.
func (m *Prompt) IsPipeCalled() bool {
	m.lockIsPipe.Lock()
	defer m.lockIsPipe.Unlock()

	return len(m.calls.IsPipe) > 0
}

// IsPipeCalls returns the calls made to IsPipe.
func (m *Prompt) IsPipeCalls() []struct {
} {
	m.lockIsPipe.Lock()
	defer m.lockIsPipe.Unlock()

	return m.calls.IsPipe
}

// Reset resets the calls made to the mocked methods.
func (m *Prompt) Reset() {
	m.lockReadString.Lock()
	m.calls.ReadString = nil
	m.lockReadString.Unlock()
	m.lockReadPassword.Lock()
	m.calls.ReadPassword = nil
	m.lockReadPassword.Unlock()
	m.lockIsPipe.Lock()
	m.calls.IsPipe = nil
	m.lockIsPipe.Unlock()
}
