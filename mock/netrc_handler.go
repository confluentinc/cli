// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: netrc_handler.go

package mock

import (
	sync "sync"

	github_com_confluentinc_cli_internal_pkg_netrc "github.com/confluentinc/cli/internal/pkg/netrc"
)

// MockNetrcHandler is a mock of NetrcHandler interface
type MockNetrcHandler struct {
	lockWriteNetrcCredentials sync.Mutex
	WriteNetrcCredentialsFunc func(cliName string, isSSO bool, ctxName, username, password string) error

	lockGetMatchingNetrcCredentials sync.Mutex
	GetMatchingNetrcCredentialsFunc func(params github_com_confluentinc_cli_internal_pkg_netrc.GetMatchingNetrcCredentialsParams) (string, string, error)

	lockGetFileName sync.Mutex
	GetFileNameFunc func() string

	calls struct {
		WriteNetrcCredentials []struct {
			CliName  string
			IsSSO    bool
			CtxName  string
			Username string
			Password string
		}
		GetMatchingNetrcCredentials []struct {
			Params github_com_confluentinc_cli_internal_pkg_netrc.GetMatchingNetrcCredentialsParams
		}
		GetFileName []struct {
		}
	}
}

// WriteNetrcCredentials mocks base method by wrapping the associated func.
func (m *MockNetrcHandler) WriteNetrcCredentials(cliName string, isSSO bool, ctxName, username, password string) error {
	m.lockWriteNetrcCredentials.Lock()
	defer m.lockWriteNetrcCredentials.Unlock()

	if m.WriteNetrcCredentialsFunc == nil {
		panic("mocker: MockNetrcHandler.WriteNetrcCredentialsFunc is nil but MockNetrcHandler.WriteNetrcCredentials was called.")
	}

	call := struct {
		CliName  string
		IsSSO    bool
		CtxName  string
		Username string
		Password string
	}{
		CliName:  cliName,
		IsSSO:    isSSO,
		CtxName:  ctxName,
		Username: username,
		Password: password,
	}

	m.calls.WriteNetrcCredentials = append(m.calls.WriteNetrcCredentials, call)

	return m.WriteNetrcCredentialsFunc(cliName, isSSO, ctxName, username, password)
}

// WriteNetrcCredentialsCalled returns true if WriteNetrcCredentials was called at least once.
func (m *MockNetrcHandler) WriteNetrcCredentialsCalled() bool {
	m.lockWriteNetrcCredentials.Lock()
	defer m.lockWriteNetrcCredentials.Unlock()

	return len(m.calls.WriteNetrcCredentials) > 0
}

// WriteNetrcCredentialsCalls returns the calls made to WriteNetrcCredentials.
func (m *MockNetrcHandler) WriteNetrcCredentialsCalls() []struct {
	CliName  string
	IsSSO    bool
	CtxName  string
	Username string
	Password string
} {
	m.lockWriteNetrcCredentials.Lock()
	defer m.lockWriteNetrcCredentials.Unlock()

	return m.calls.WriteNetrcCredentials
}

// GetMatchingNetrcCredentials mocks base method by wrapping the associated func.
func (m *MockNetrcHandler) GetMatchingNetrcCredentials(params github_com_confluentinc_cli_internal_pkg_netrc.GetMatchingNetrcCredentialsParams) (string, string, error) {
	m.lockGetMatchingNetrcCredentials.Lock()
	defer m.lockGetMatchingNetrcCredentials.Unlock()

	if m.GetMatchingNetrcCredentialsFunc == nil {
		panic("mocker: MockNetrcHandler.GetMatchingNetrcCredentialsFunc is nil but MockNetrcHandler.GetMatchingNetrcCredentials was called.")
	}

	call := struct {
		Params github_com_confluentinc_cli_internal_pkg_netrc.GetMatchingNetrcCredentialsParams
	}{
		Params: params,
	}

	m.calls.GetMatchingNetrcCredentials = append(m.calls.GetMatchingNetrcCredentials, call)

	return m.GetMatchingNetrcCredentialsFunc(params)
}

// GetMatchingNetrcCredentialsCalled returns true if GetMatchingNetrcCredentials was called at least once.
func (m *MockNetrcHandler) GetMatchingNetrcCredentialsCalled() bool {
	m.lockGetMatchingNetrcCredentials.Lock()
	defer m.lockGetMatchingNetrcCredentials.Unlock()

	return len(m.calls.GetMatchingNetrcCredentials) > 0
}

// GetMatchingNetrcCredentialsCalls returns the calls made to GetMatchingNetrcCredentials.
func (m *MockNetrcHandler) GetMatchingNetrcCredentialsCalls() []struct {
	Params github_com_confluentinc_cli_internal_pkg_netrc.GetMatchingNetrcCredentialsParams
} {
	m.lockGetMatchingNetrcCredentials.Lock()
	defer m.lockGetMatchingNetrcCredentials.Unlock()

	return m.calls.GetMatchingNetrcCredentials
}

// GetFileName mocks base method by wrapping the associated func.
func (m *MockNetrcHandler) GetFileName() string {
	m.lockGetFileName.Lock()
	defer m.lockGetFileName.Unlock()

	if m.GetFileNameFunc == nil {
		panic("mocker: MockNetrcHandler.GetFileNameFunc is nil but MockNetrcHandler.GetFileName was called.")
	}

	call := struct {
	}{}

	m.calls.GetFileName = append(m.calls.GetFileName, call)

	return m.GetFileNameFunc()
}

// GetFileNameCalled returns true if GetFileName was called at least once.
func (m *MockNetrcHandler) GetFileNameCalled() bool {
	m.lockGetFileName.Lock()
	defer m.lockGetFileName.Unlock()

	return len(m.calls.GetFileName) > 0
}

// GetFileNameCalls returns the calls made to GetFileName.
func (m *MockNetrcHandler) GetFileNameCalls() []struct {
} {
	m.lockGetFileName.Lock()
	defer m.lockGetFileName.Unlock()

	return m.calls.GetFileName
}

// Reset resets the calls made to the mocked methods.
func (m *MockNetrcHandler) Reset() {
	m.lockWriteNetrcCredentials.Lock()
	m.calls.WriteNetrcCredentials = nil
	m.lockWriteNetrcCredentials.Unlock()
	m.lockGetMatchingNetrcCredentials.Lock()
	m.calls.GetMatchingNetrcCredentials = nil
	m.lockGetMatchingNetrcCredentials.Unlock()
	m.lockGetFileName.Lock()
	m.calls.GetFileName = nil
	m.lockGetFileName.Unlock()
}
