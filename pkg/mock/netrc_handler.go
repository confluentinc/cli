// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: internal/pkg/netrc/netrc_handler.go

package mock

import (
	sync "sync"

	github_com_confluentinc_cli_internal_pkg_netrc "github.com/confluentinc/cli/v3/pkg/netrc"
)

// NetrcHandler is a mock of NetrcHandler interface
type NetrcHandler struct {
	lockRemoveNetrcCredentials sync.Mutex
	RemoveNetrcCredentialsFunc func(isCloud bool, ctxName string) (string, error)

	lockCheckCredentialExist sync.Mutex
	CheckCredentialExistFunc func(isCloud bool, ctxName string) (bool, error)

	lockGetMatchingNetrcMachine sync.Mutex
	GetMatchingNetrcMachineFunc func(params github_com_confluentinc_cli_internal_pkg_netrc.NetrcMachineParams) (*github_com_confluentinc_cli_internal_pkg_netrc.Machine, error)

	lockGetFileName sync.Mutex
	GetFileNameFunc func() string

	calls struct {
		RemoveNetrcCredentials []struct {
			IsCloud bool
			CtxName string
		}
		CheckCredentialExist []struct {
			IsCloud bool
			CtxName string
		}
		GetMatchingNetrcMachine []struct {
			Params github_com_confluentinc_cli_internal_pkg_netrc.NetrcMachineParams
		}
		GetFileName []struct {
		}
	}
}

// RemoveNetrcCredentials mocks base method by wrapping the associated func.
func (m *NetrcHandler) RemoveNetrcCredentials(isCloud bool, ctxName string) (string, error) {
	m.lockRemoveNetrcCredentials.Lock()
	defer m.lockRemoveNetrcCredentials.Unlock()

	if m.RemoveNetrcCredentialsFunc == nil {
		panic("mocker: NetrcHandler.RemoveNetrcCredentialsFunc is nil but NetrcHandler.RemoveNetrcCredentials was called.")
	}

	call := struct {
		IsCloud bool
		CtxName string
	}{
		IsCloud: isCloud,
		CtxName: ctxName,
	}

	m.calls.RemoveNetrcCredentials = append(m.calls.RemoveNetrcCredentials, call)

	return m.RemoveNetrcCredentialsFunc(isCloud, ctxName)
}

// RemoveNetrcCredentialsCalled returns true if RemoveNetrcCredentials was called at least once.
func (m *NetrcHandler) RemoveNetrcCredentialsCalled() bool {
	m.lockRemoveNetrcCredentials.Lock()
	defer m.lockRemoveNetrcCredentials.Unlock()

	return len(m.calls.RemoveNetrcCredentials) > 0
}

// RemoveNetrcCredentialsCalls returns the calls made to RemoveNetrcCredentials.
func (m *NetrcHandler) RemoveNetrcCredentialsCalls() []struct {
	IsCloud bool
	CtxName string
} {
	m.lockRemoveNetrcCredentials.Lock()
	defer m.lockRemoveNetrcCredentials.Unlock()

	return m.calls.RemoveNetrcCredentials
}

// CheckCredentialExist mocks base method by wrapping the associated func.
func (m *NetrcHandler) CheckCredentialExist(isCloud bool, ctxName string) (bool, error) {
	m.lockCheckCredentialExist.Lock()
	defer m.lockCheckCredentialExist.Unlock()

	if m.CheckCredentialExistFunc == nil {
		panic("mocker: NetrcHandler.CheckCredentialExistFunc is nil but NetrcHandler.CheckCredentialExist was called.")
	}

	call := struct {
		IsCloud bool
		CtxName string
	}{
		IsCloud: isCloud,
		CtxName: ctxName,
	}

	m.calls.CheckCredentialExist = append(m.calls.CheckCredentialExist, call)

	return m.CheckCredentialExistFunc(isCloud, ctxName)
}

// CheckCredentialExistCalled returns true if CheckCredentialExist was called at least once.
func (m *NetrcHandler) CheckCredentialExistCalled() bool {
	m.lockCheckCredentialExist.Lock()
	defer m.lockCheckCredentialExist.Unlock()

	return len(m.calls.CheckCredentialExist) > 0
}

// CheckCredentialExistCalls returns the calls made to CheckCredentialExist.
func (m *NetrcHandler) CheckCredentialExistCalls() []struct {
	IsCloud bool
	CtxName string
} {
	m.lockCheckCredentialExist.Lock()
	defer m.lockCheckCredentialExist.Unlock()

	return m.calls.CheckCredentialExist
}

// GetMatchingNetrcMachine mocks base method by wrapping the associated func.
func (m *NetrcHandler) GetMatchingNetrcMachine(params github_com_confluentinc_cli_internal_pkg_netrc.NetrcMachineParams) (*github_com_confluentinc_cli_internal_pkg_netrc.Machine, error) {
	m.lockGetMatchingNetrcMachine.Lock()
	defer m.lockGetMatchingNetrcMachine.Unlock()

	if m.GetMatchingNetrcMachineFunc == nil {
		panic("mocker: NetrcHandler.GetMatchingNetrcMachineFunc is nil but NetrcHandler.GetMatchingNetrcMachine was called.")
	}

	call := struct {
		Params github_com_confluentinc_cli_internal_pkg_netrc.NetrcMachineParams
	}{
		Params: params,
	}

	m.calls.GetMatchingNetrcMachine = append(m.calls.GetMatchingNetrcMachine, call)

	return m.GetMatchingNetrcMachineFunc(params)
}

// GetMatchingNetrcMachineCalled returns true if GetMatchingNetrcMachine was called at least once.
func (m *NetrcHandler) GetMatchingNetrcMachineCalled() bool {
	m.lockGetMatchingNetrcMachine.Lock()
	defer m.lockGetMatchingNetrcMachine.Unlock()

	return len(m.calls.GetMatchingNetrcMachine) > 0
}

// GetMatchingNetrcMachineCalls returns the calls made to GetMatchingNetrcMachine.
func (m *NetrcHandler) GetMatchingNetrcMachineCalls() []struct {
	Params github_com_confluentinc_cli_internal_pkg_netrc.NetrcMachineParams
} {
	m.lockGetMatchingNetrcMachine.Lock()
	defer m.lockGetMatchingNetrcMachine.Unlock()

	return m.calls.GetMatchingNetrcMachine
}

// GetFileName mocks base method by wrapping the associated func.
func (m *NetrcHandler) GetFileName() string {
	m.lockGetFileName.Lock()
	defer m.lockGetFileName.Unlock()

	if m.GetFileNameFunc == nil {
		panic("mocker: NetrcHandler.GetFileNameFunc is nil but NetrcHandler.GetFileName was called.")
	}

	call := struct {
	}{}

	m.calls.GetFileName = append(m.calls.GetFileName, call)

	return m.GetFileNameFunc()
}

// GetFileNameCalled returns true if GetFileName was called at least once.
func (m *NetrcHandler) GetFileNameCalled() bool {
	m.lockGetFileName.Lock()
	defer m.lockGetFileName.Unlock()

	return len(m.calls.GetFileName) > 0
}

// GetFileNameCalls returns the calls made to GetFileName.
func (m *NetrcHandler) GetFileNameCalls() []struct {
} {
	m.lockGetFileName.Lock()
	defer m.lockGetFileName.Unlock()

	return m.calls.GetFileName
}

// Reset resets the calls made to the mocked methods.
func (m *NetrcHandler) Reset() {
	m.lockRemoveNetrcCredentials.Lock()
	m.calls.RemoveNetrcCredentials = nil
	m.lockRemoveNetrcCredentials.Unlock()
	m.lockCheckCredentialExist.Lock()
	m.calls.CheckCredentialExist = nil
	m.lockCheckCredentialExist.Unlock()
	m.lockGetMatchingNetrcMachine.Lock()
	m.calls.GetMatchingNetrcMachine = nil
	m.lockGetMatchingNetrcMachine.Unlock()
	m.lockGetFileName.Lock()
	m.calls.GetFileName = nil
	m.lockGetFileName.Unlock()
}
