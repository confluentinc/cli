package mocker

import (
	"bytes"
	"fmt"
	"go/token"
	"log"
	"log/syslog"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"unicode"

	"github.com/golang/mock/mockgen/model"
	format "golang.org/x/tools/imports"
)

type Config struct {
	Src string
	Dst string
	Pre string
	Suf string
	Pkg string
	Slf string
	Itf []string
}

func Run(c Config) error {
	pkg, err := ParseFile(c.Src)
	if err != nil {
		return err
	}

	if c.Pkg == "" {
		// if generated mock package name wasn't set, we default to the package name in the source file.
		c.Pkg = pkg.Name
	}

	dst := os.Stdout
	if len(c.Dst) > 0 {
		if err := os.MkdirAll(filepath.Dir(c.Dst), os.ModePerm); err != nil {
			log.Fatalf("Unable to create directory: %v", err)
		}
		f, err := os.Create(c.Dst)
		if err != nil {
			log.Fatalf("Failed opening destination file: %v", err)
		}
		defer f.Close()
		dst = f
	}

	l, err := syslog.New(syslog.LOG_DEBUG, "mocker")
	if err != nil {
		return err
	}

	l.Debug("pkg path: " + pkg.PkgPath)

	g := &Generator{
		c:      c,
		pkg:    pkg,
		logger: l,
	}

	if err := g.Generate(); err != nil {
		return nil
	}

	_, err = dst.Write(g.Output())
	return err
}

type Generator struct {
	c       Config
	pkg     *Package
	buf     bytes.Buffer
	imports map[string]string // import path to pkg name
	types   map[string]string // interface type name to name used in generated code
	indent  string
	logger  *syslog.Writer
}

// Output returns the Generator's output, formatted in the standard Go style.
func (g *Generator) Output() []byte {
	options := &format.Options{
		TabWidth:  8,
		TabIndent: true,
		Comments:  true,
		Fragment:  true,
	}
	src, err := format.Process(g.c.Src, g.buf.Bytes(), options)
	if err != nil {
		log.Fatalf("Failed to format generated source code: %s\n%s", err, g.buf.String())
	}
	return src
}

func (g *Generator) Generate() error {
	g.p("// Code generated by mocker. DO NOT EDIT.")
	g.p("// github.com/travisjeffery/mocker")
	if g.c.Src != "" {
		g.p("// Source: %v", g.c.Src)
	}
	g.p("")

	g.setupImports()

	g.p("package %v", g.c.Pkg)
	g.p("")

	g.GenerateImports()
	for _, intf := range g.pkg.Interfaces {
		if !contains(g.c.Itf, intf.Name) {
			g.logger.Debug("skipped interface: " + intf.Name)
			continue
		}
		if err := g.GenerateInterface(intf); err != nil {
			return err
		}
	}
	return nil
}

func (g *Generator) setupImports() {
	imports := g.pkg.Imports()
	sortedPaths := make([]string, len(imports), len(imports))
	sortedPaths = append(sortedPaths, "sync")
	i := 0
	for path := range imports {
		sortedPaths[i] = path
		i++
	}
	sort.Strings(sortedPaths)
	g.imports = make(map[string]string, len(imports))
	names := make(map[string]bool, len(imports))
	for _, path := range sortedPaths {
		base := sanitize(path)
		pkgName := base
		i := 0
		for names[pkgName] || token.Lookup(pkgName).IsKeyword() {
			pkgName = base + strconv.Itoa(i)
			i++
		}
		g.imports[path] = pkgName
		names[pkgName] = true
	}
}

func (g *Generator) GenerateImports() {
	g.p("import (")
	g.in()
	for path, pkg := range g.imports {
		if path == g.c.Slf {
			g.logger.Debug("skipped import: " + path + ": " + pkg)
			continue
		}
		g.logger.Debug("import: " + path + ": " + pkg)
		g.p("%v %q", pkg, path)
	}
	g.out()
	g.p(")")
}

func (g *Generator) GenerateInterface(intf *model.Interface) error {
	g.logger.Debug("generate interface: " + intf.Name)

	mockType := g.typeName(intf.Name)

	g.p("")
	g.p("// %v is a mock of %v interface", mockType, intf.Name)
	g.p("type %v struct {", mockType)
	g.in()

	for _, m := range intf.Methods {
		g.p("lock%v sync.Mutex", m.Name)

		argNames := g.getArgNames(m)
		argTypes := g.getArgTypes(m)
		argString := makeArgString(argNames, argTypes)

		rets := make([]string, len(m.Out))
		for i, p := range m.Out {
			rets[i] = p.Type.String(g.imports, g.c.Slf)
		}
		retString := strings.Join(rets, ", ")
		if len(rets) > 1 {
			retString = "(" + retString + ")"
		}
		if retString != "" {
			retString = " " + retString
		}

		g.p("%vFunc func(%v) %v", m.Name, argString, retString)
		g.p("")
	}

	g.p("calls struct {")
	g.in()
	for _, m := range intf.Methods {
		g.p("%v []struct {", m.Name)
		g.in()

		argNames := g.getArgNames(m)
		argTypes := g.getArgTypes(m)

		for i, name := range argNames {
			s := fmt.Sprintf("%v %v", strings.Title(name), argTypes[i])
			s = strings.Replace(s, "...", "[]", -1)
			g.p(s)
		}

		g.out()
		g.p("}")
	}
	g.out()
	g.p("}")

	g.out()
	g.p("}")
	g.p("")

	return g.GenerateMethods(mockType, intf)
}

func (g *Generator) GenerateMethods(mockType string, intf *model.Interface) error {
	for _, m := range intf.Methods {
		g.p("")
		if err := g.GenerateMethod(mockType, m); err != nil {
			return err
		}
		g.p("")
	}

	g.p("// Reset resets the calls made to the mocked methods.")
	g.p("func (m *%v) Reset() {", mockType)
	g.in()
	for _, m := range intf.Methods {
		g.p("m.lock%v.Lock()", m.Name)
		g.p("m.calls.%v = nil", m.Name)
		g.p("m.lock%v.Unlock()", m.Name)
	}
	g.out()
	g.p("}")

	return nil
}

func (g *Generator) GenerateMethod(mockType string, m *model.Method) error {
	g.logger.Debug("generate method: " + m.Name)

	argNames := g.getArgNames(m)
	argTypes := g.getArgTypes(m)
	argString := makeArgString(argNames, argTypes)

	rets := make([]string, len(m.Out))
	for i, p := range m.Out {
		rets[i] = p.Type.String(g.imports, g.c.Slf)
	}
	retString := strings.Join(rets, ", ")
	if len(rets) > 1 {
		retString = "(" + retString + ")"
	}
	if retString != "" {
		retString = " " + retString
	}

	ia := newIdentifierAllocator(argNames)
	idRecv := ia.allocateIdentifier("m")

	g.p("// %v mocks base method by wrapping the associated func.", m.Name)
	g.p("func (%v *%v) %v(%v)%v {", idRecv, mockType, m.Name, argString, retString)
	g.in()
	g.p("%s.lock%s.Lock()", idRecv, m.Name)
	g.p("defer %s.lock%s.Unlock()", idRecv, m.Name)

	g.p("")
	g.p("if %v.%vFunc == nil {", idRecv, m.Name)
	g.in()
	g.p("panic(\"mocker: %v.%vFunc is nil but %v.%v was called.\")", mockType, m.Name, mockType, m.Name)
	g.out()
	g.p("}")
	g.p("")

	g.p("call := struct {")
	g.in()
	for i, name := range argNames {
		s := fmt.Sprintf("%v %v", strings.Title(name), argTypes[i])
		s = strings.Replace(s, "...", "[]", -1)
		g.p(s)
	}
	g.out()
	g.p("}{")
	g.in()
	for _, name := range argNames {
		g.p("%v: %v,", strings.Title(name), name)
	}
	g.out()
	g.p("}")
	g.p("")

	g.p("%v.calls.%v = append(%v.calls.%v, call)", idRecv, m.Name, idRecv, m.Name)
	g.p("")

	var callArgs string
	if len(argNames) > 0 {
		callArgs = strings.Join(argNames, ", ")
	}

	if m.Variadic != nil {
		callArgs += "..."
	}

	if len(m.Out) == 0 {
		g.p(`%v.%vFunc(%v)`, idRecv, m.Name, callArgs)
	} else {
		g.p(`return %v.%vFunc(%v)`, idRecv, m.Name, callArgs)
	}

	g.out()
	g.p("}")
	g.p("")

	g.p("// %vCalled returns true if %v was called at least once.", m.Name, m.Name)
	g.p("func (%v *%v) %vCalled() bool {", idRecv, mockType, m.Name)
	g.in()
	g.p("%s.lock%s.Lock()", idRecv, m.Name)
	g.p("defer %s.lock%s.Unlock()", idRecv, m.Name)
	g.p("")
	g.p("return len(%v.calls.%v) > 0", idRecv, m.Name)
	g.out()
	g.p("}")

	g.p("// %vCalls returns the calls made to %v.", m.Name, m.Name)
	g.p("func (%v *%v) %vCalls() []struct {", idRecv, mockType, m.Name)

	g.in()
	for i, name := range argNames {
		s := fmt.Sprintf("%v %v", strings.Title(name), argTypes[i])
		s = strings.Replace(s, "...", "[]", -1)
		g.p(s)
	}
	g.out()
	g.p("} {")

	g.in()
	g.p("%s.lock%s.Lock()", idRecv, m.Name)
	g.p("defer %s.lock%s.Unlock()", idRecv, m.Name)
	g.p("")
	g.p("return %v.calls.%v", idRecv, m.Name)
	g.out()
	g.p("}")

	return nil
}

func makeArgString(argNames, argTypes []string) string {
	args := make([]string, len(argNames))
	for i, name := range argNames {
		// specify the type only once for consecutive args of the same type
		if i+1 < len(argTypes) && argTypes[i] == argTypes[i+1] {
			args[i] = name
		} else {
			args[i] = name + " " + argTypes[i]
		}
	}
	return strings.Join(args, ", ")
}

func (g *Generator) getArgNames(m *model.Method) []string {
	argNames := make([]string, len(m.In))
	for i, p := range m.In {
		name := p.Name
		if name == "" {
			name = fmt.Sprintf("arg%d", i)
		}
		argNames[i] = name
	}
	if m.Variadic != nil {
		name := m.Variadic.Name
		if name == "" {
			name = fmt.Sprintf("arg%d", len(m.In))
		}
		argNames = append(argNames, name)
	}
	return argNames
}

func (g *Generator) getArgTypes(m *model.Method) []string {
	argTypes := make([]string, len(m.In))
	for i, p := range m.In {
		argTypes[i] = p.Type.String(g.imports, g.c.Slf)
	}
	if m.Variadic != nil {
		argTypes = append(argTypes, "..."+m.Variadic.Type.String(g.imports, g.c.Slf))
	}
	return argTypes
}

// The name of the mock type to use for the given interface identifier.
func (g *Generator) typeName(in string) string {
	if out, ok := g.types[in]; ok {
		return out
	}
	return g.c.Pre + in + g.c.Suf
}

func (g *Generator) p(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, g.indent+format+"\n", args...)
}

func (g *Generator) in() {
	g.indent += "\t"
}

func (g *Generator) out() {
	if len(g.indent) > 0 {
		g.indent = g.indent[0 : len(g.indent)-1]
	}
}

type identifierAllocator map[string]struct{}

func newIdentifierAllocator(taken []string) identifierAllocator {
	a := make(identifierAllocator, len(taken))
	for _, s := range taken {
		a[s] = struct{}{}
	}
	return a
}

func (o identifierAllocator) allocateIdentifier(want string) string {
	id := want
	for i := 2; ; i++ {
		if _, ok := o[id]; !ok {
			o[id] = struct{}{}
			return id
		}
		id = want + "_" + strconv.Itoa(i)
	}
}

// sanitize cleans up a string to make a suitable package name.
func sanitize(s string) string {
	t := ""
	for _, r := range s {
		if t == "" {
			if unicode.IsLetter(r) || r == '_' {
				t += string(r)
				continue
			}
		} else {
			if unicode.IsLetter(r) || unicode.IsDigit(r) || r == '_' {
				t += string(r)
				continue
			}
		}
		t += "_"
	}
	if t == "_" {
		t = "x"
	}
	return t
}

func contains(sl []string, s string) bool {
	for _, e := range sl {
		if e == s {
			return true
		}
	}
	return false
}
