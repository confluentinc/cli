// Copyright 2021 Confluent Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*
Confluent Schema Registry

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package schemaregistry

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

type DefaultApi interface {

	/*
	AsyncapiParsePut Method for AsyncapiParsePut

	Get number of times the cli tool is used to import and parse the spec file

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiAsyncapiParsePutRequest
	*/
	AsyncapiParsePut(ctx _context.Context) ApiAsyncapiParsePutRequest

	// AsyncapiParsePutExecute executes the request
	AsyncapiParsePutExecute(r ApiAsyncapiParsePutRequest) (*_nethttp.Response, error)

	/*
	AsyncapiPut Method for AsyncapiPut

	Get number of times the cli tool is used to export/produce the spec file

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiAsyncapiPutRequest
	*/
	AsyncapiPut(ctx _context.Context) ApiAsyncapiPutRequest

	// AsyncapiPutExecute executes the request
	AsyncapiPutExecute(r ApiAsyncapiPutRequest) (*_nethttp.Response, error)

	/*
	CreateBusinessMetadata Bulk API to create multiple business metadata.

	Bulk API to create multiple business metadata.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiCreateBusinessMetadataRequest
	*/
	CreateBusinessMetadata(ctx _context.Context) ApiCreateBusinessMetadataRequest

	// CreateBusinessMetadataExecute executes the request
	//  @return []BusinessMetadataResponse
	CreateBusinessMetadataExecute(r ApiCreateBusinessMetadataRequest) ([]BusinessMetadataResponse, *_nethttp.Response, error)

	/*
	CreateBusinessMetadataDefs Bulk create API for business metadata definitions.

	Bulk create API for business metadata definitions.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiCreateBusinessMetadataDefsRequest
	*/
	CreateBusinessMetadataDefs(ctx _context.Context) ApiCreateBusinessMetadataDefsRequest

	// CreateBusinessMetadataDefsExecute executes the request
	//  @return []BusinessMetadataDefResponse
	CreateBusinessMetadataDefsExecute(r ApiCreateBusinessMetadataDefsRequest) ([]BusinessMetadataDefResponse, *_nethttp.Response, error)

	/*
	CreateDek Create a dek.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name Name of the kek
	 @return ApiCreateDekRequest
	*/
	CreateDek(ctx _context.Context, name string) ApiCreateDekRequest

	// CreateDekExecute executes the request
	//  @return Dek
	CreateDekExecute(r ApiCreateDekRequest) (Dek, *_nethttp.Response, error)

	/*
	CreateExporter Create an exporter.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiCreateExporterRequest
	*/
	CreateExporter(ctx _context.Context) ApiCreateExporterRequest

	// CreateExporterExecute executes the request
	//  @return CreateExporterResponse
	CreateExporterExecute(r ApiCreateExporterRequest) (CreateExporterResponse, *_nethttp.Response, error)

	/*
	CreateKek Create a kek.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiCreateKekRequest
	*/
	CreateKek(ctx _context.Context) ApiCreateKekRequest

	// CreateKekExecute executes the request
	//  @return Kek
	CreateKekExecute(r ApiCreateKekRequest) (Kek, *_nethttp.Response, error)

	/*
	CreateOrUpdate Method for CreateOrUpdate

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiCreateOrUpdateRequest
	*/
	CreateOrUpdate(ctx _context.Context) ApiCreateOrUpdateRequest

	// CreateOrUpdateExecute executes the request
	CreateOrUpdateExecute(r ApiCreateOrUpdateRequest) (*_nethttp.Response, error)

	/*
	CreateTagDefs Bulk create API for tag definitions.

	Bulk create API for tag definitions.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiCreateTagDefsRequest
	*/
	CreateTagDefs(ctx _context.Context) ApiCreateTagDefsRequest

	// CreateTagDefsExecute executes the request
	//  @return []TagDefResponse
	CreateTagDefsExecute(r ApiCreateTagDefsRequest) ([]TagDefResponse, *_nethttp.Response, error)

	/*
	CreateTags Bulk API to create multiple tags.

	Bulk API to create multiple tags.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiCreateTagsRequest
	*/
	CreateTags(ctx _context.Context) ApiCreateTagsRequest

	// CreateTagsExecute executes the request
	//  @return []TagResponse
	CreateTagsExecute(r ApiCreateTagsRequest) ([]TagResponse, *_nethttp.Response, error)

	/*
	DeleteBusinessMetadata Delete a business metadata on an entity.

	Delete a business metadata on an entity.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param typeName The type of the entity
	 @param qualifiedName The qualified name of the entity
	 @param bmName The name of the business metadata
	 @return ApiDeleteBusinessMetadataRequest
	*/
	DeleteBusinessMetadata(ctx _context.Context, typeName string, qualifiedName string, bmName string) ApiDeleteBusinessMetadataRequest

	// DeleteBusinessMetadataExecute executes the request
	DeleteBusinessMetadataExecute(r ApiDeleteBusinessMetadataRequest) (*_nethttp.Response, error)

	/*
	DeleteBusinessMetadataDef Delete API for business metadata definition identified by its name.

	Delete API for business metadata definition identified by its name.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param bmName The name of the business metadata definition
	 @return ApiDeleteBusinessMetadataDefRequest
	*/
	DeleteBusinessMetadataDef(ctx _context.Context, bmName string) ApiDeleteBusinessMetadataDefRequest

	// DeleteBusinessMetadataDefExecute executes the request
	DeleteBusinessMetadataDefExecute(r ApiDeleteBusinessMetadataDefRequest) (*_nethttp.Response, error)

	/*
	DeleteByUniqueAttributes Method for DeleteByUniqueAttributes

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param typeName
	 @param qualifiedName
	 @return ApiDeleteByUniqueAttributesRequest
	*/
	DeleteByUniqueAttributes(ctx _context.Context, typeName string, qualifiedName string) ApiDeleteByUniqueAttributesRequest

	// DeleteByUniqueAttributesExecute executes the request
	DeleteByUniqueAttributesExecute(r ApiDeleteByUniqueAttributesRequest) (*_nethttp.Response, error)

	/*
	DeleteDekVersion Delete a dek version.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name Name of the kek
	 @param subject Subject of the dek
	 @param version Version of the dek
	 @return ApiDeleteDekVersionRequest
	*/
	DeleteDekVersion(ctx _context.Context, name string, subject string, version string) ApiDeleteDekVersionRequest

	// DeleteDekVersionExecute executes the request
	DeleteDekVersionExecute(r ApiDeleteDekVersionRequest) (*_nethttp.Response, error)

	/*
	DeleteDekVersions Delete all versions of a dek.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name Name of the kek
	 @param subject Subject of the dek
	 @return ApiDeleteDekVersionsRequest
	*/
	DeleteDekVersions(ctx _context.Context, name string, subject string) ApiDeleteDekVersionsRequest

	// DeleteDekVersionsExecute executes the request
	DeleteDekVersionsExecute(r ApiDeleteDekVersionsRequest) (*_nethttp.Response, error)

	/*
	DeleteExporter Delete an exporter.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name Name of the exporter
	 @return ApiDeleteExporterRequest
	*/
	DeleteExporter(ctx _context.Context, name string) ApiDeleteExporterRequest

	// DeleteExporterExecute executes the request
	DeleteExporterExecute(r ApiDeleteExporterRequest) (*_nethttp.Response, error)

	/*
	DeleteKek Delete a kek.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name Name of the kek
	 @return ApiDeleteKekRequest
	*/
	DeleteKek(ctx _context.Context, name string) ApiDeleteKekRequest

	// DeleteKekExecute executes the request
	DeleteKekExecute(r ApiDeleteKekRequest) (*_nethttp.Response, error)

	/*
	DeleteSchemaVersion Deletes a specific version of the schema registered under this subject. This only deletes the version and the schema ID remains intact making it still possible to decode data using the schema ID. This API is recommended to be used only in development environments or under extreme circumstances where-in, its required to delete a previously registered schema for compatibility purposes or re-register previously registered schema.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param subject Name of the Subject
	 @param version Version of the schema to be returned. Valid values for versionId are between [1,2^31-1] or the string \"latest\". \"latest\" returns the last registered schema under the specified subject. Note that there may be a new latest schema that gets registered right after this request is served.
	 @return ApiDeleteSchemaVersionRequest
	*/
	DeleteSchemaVersion(ctx _context.Context, subject string, version string) ApiDeleteSchemaVersionRequest

	// DeleteSchemaVersionExecute executes the request
	//  @return int32
	DeleteSchemaVersionExecute(r ApiDeleteSchemaVersionRequest) (int32, *_nethttp.Response, error)

	/*
	DeleteSubject Deletes the specified subject and its associated compatibility level if registered. It is recommended to use this API only when a topic needs to be recycled or in development environment.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param subject the name of the subject
	 @return ApiDeleteSubjectRequest
	*/
	DeleteSubject(ctx _context.Context, subject string) ApiDeleteSubjectRequest

	// DeleteSubjectExecute executes the request
	//  @return []int32
	DeleteSubjectExecute(r ApiDeleteSubjectRequest) ([]int32, *_nethttp.Response, error)

	/*
	DeleteSubjectConfig Deletes the specified subject-level compatibility level config and revert to the global default.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param subject the name of the subject
	 @return ApiDeleteSubjectConfigRequest
	*/
	DeleteSubjectConfig(ctx _context.Context, subject string) ApiDeleteSubjectConfigRequest

	// DeleteSubjectConfigExecute executes the request
	//  @return string
	DeleteSubjectConfigExecute(r ApiDeleteSubjectConfigRequest) (string, *_nethttp.Response, error)

	/*
	DeleteSubjectMode Deletes the specified subject-level mode and revert to the global default.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param subject the name of the subject
	 @return ApiDeleteSubjectModeRequest
	*/
	DeleteSubjectMode(ctx _context.Context, subject string) ApiDeleteSubjectModeRequest

	// DeleteSubjectModeExecute executes the request
	//  @return string
	DeleteSubjectModeExecute(r ApiDeleteSubjectModeRequest) (string, *_nethttp.Response, error)

	/*
	DeleteTag Delete a tag on an entity.

	Delete a tag on an entity.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param typeName The type of the entity
	 @param qualifiedName The qualified name of the entity
	 @param tagName The name of the tag
	 @return ApiDeleteTagRequest
	*/
	DeleteTag(ctx _context.Context, typeName string, qualifiedName string, tagName string) ApiDeleteTagRequest

	// DeleteTagExecute executes the request
	DeleteTagExecute(r ApiDeleteTagRequest) (*_nethttp.Response, error)

	/*
	DeleteTagDef Delete API for tag definition identified by its name.

	Delete API for tag definition identified by its name.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param tagName The name of the tag definition
	 @return ApiDeleteTagDefRequest
	*/
	DeleteTagDef(ctx _context.Context, tagName string) ApiDeleteTagDefRequest

	// DeleteTagDefExecute executes the request
	DeleteTagDefExecute(r ApiDeleteTagDefRequest) (*_nethttp.Response, error)

	/*
	DeleteTopLevelConfig Delete global compatibility level

	Deletes the global compatibility level config and reverts to the default.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiDeleteTopLevelConfigRequest
	*/
	DeleteTopLevelConfig(ctx _context.Context) ApiDeleteTopLevelConfigRequest

	// DeleteTopLevelConfigExecute executes the request
	//  @return string
	DeleteTopLevelConfigExecute(r ApiDeleteTopLevelConfigRequest) (string, *_nethttp.Response, error)

	/*
	Get Schema Registry Root Resource

	The Root resource is a no-op.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiGetRequest
	*/
	Get(ctx _context.Context) ApiGetRequest

	// GetExecute executes the request
	//  @return map[string]map[string]interface{}
	GetExecute(r ApiGetRequest) (map[string]map[string]interface{}, *_nethttp.Response, error)

	/*
	GetAllBusinessMetadataDefs Bulk retrieval API for retrieving business metadata definitions.

	Bulk retrieval API for retrieving business metadata definitions.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiGetAllBusinessMetadataDefsRequest
	*/
	GetAllBusinessMetadataDefs(ctx _context.Context) ApiGetAllBusinessMetadataDefsRequest

	// GetAllBusinessMetadataDefsExecute executes the request
	//  @return []BusinessMetadataDefResponse
	GetAllBusinessMetadataDefsExecute(r ApiGetAllBusinessMetadataDefsRequest) ([]BusinessMetadataDefResponse, *_nethttp.Response, error)

	/*
	GetAllTagDefs Bulk retrieval API for retrieving tag definitions.

	Bulk retrieval API for retrieving tag definitions.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiGetAllTagDefsRequest
	*/
	GetAllTagDefs(ctx _context.Context) ApiGetAllTagDefsRequest

	// GetAllTagDefsExecute executes the request
	//  @return []TagDefResponse
	GetAllTagDefsExecute(r ApiGetAllTagDefsRequest) ([]TagDefResponse, *_nethttp.Response, error)

	/*
	GetBusinessMetadata Gets the list of business metadata for a given entity represented by a qualified name.

	Gets the list of business metadata for a given entity represented by a qualified name.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param typeName The type of the entity
	 @param qualifiedName The qualified name of the entity
	 @return ApiGetBusinessMetadataRequest
	*/
	GetBusinessMetadata(ctx _context.Context, typeName string, qualifiedName string) ApiGetBusinessMetadataRequest

	// GetBusinessMetadataExecute executes the request
	//  @return []BusinessMetadataResponse
	GetBusinessMetadataExecute(r ApiGetBusinessMetadataRequest) ([]BusinessMetadataResponse, *_nethttp.Response, error)

	/*
	GetBusinessMetadataDefByName Get the business metadata definition with the given name.

	Get the business metadata definition with the given name.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param bmName The name of the business metadata definition
	 @return ApiGetBusinessMetadataDefByNameRequest
	*/
	GetBusinessMetadataDefByName(ctx _context.Context, bmName string) ApiGetBusinessMetadataDefByNameRequest

	// GetBusinessMetadataDefByNameExecute executes the request
	//  @return AtlasBusinessMetadataDef
	GetBusinessMetadataDefByNameExecute(r ApiGetBusinessMetadataDefByNameRequest) (AtlasBusinessMetadataDef, *_nethttp.Response, error)

	/*
	GetByUniqueAttributes Fetch complete definition of an entity given its type and unique attribute.

	Fetch complete definition of an entity given its type and unique attribute.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param typeName The type of the entity
	 @param qualifiedName The qualified name of the entity
	 @return ApiGetByUniqueAttributesRequest
	*/
	GetByUniqueAttributes(ctx _context.Context, typeName string, qualifiedName string) ApiGetByUniqueAttributesRequest

	// GetByUniqueAttributesExecute executes the request
	//  @return AtlasEntityWithExtInfo
	GetByUniqueAttributesExecute(r ApiGetByUniqueAttributesRequest) (AtlasEntityWithExtInfo, *_nethttp.Response, error)

	/*
	GetClusterId Get the server metadata

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiGetClusterIdRequest
	*/
	GetClusterId(ctx _context.Context) ApiGetClusterIdRequest

	// GetClusterIdExecute executes the request
	//  @return ServerClusterId
	GetClusterIdExecute(r ApiGetClusterIdRequest) (ServerClusterId, *_nethttp.Response, error)

	/*
	GetDek Get a dek by subject.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name Name of the kek
	 @param subject Subject of the dek
	 @return ApiGetDekRequest
	*/
	GetDek(ctx _context.Context, name string, subject string) ApiGetDekRequest

	// GetDekExecute executes the request
	//  @return Dek
	GetDekExecute(r ApiGetDekRequest) (Dek, *_nethttp.Response, error)

	/*
	GetDekByVersion Get a dek by subject and version.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name Name of the kek
	 @param subject Subject of the dek
	 @param version Version of the dek
	 @return ApiGetDekByVersionRequest
	*/
	GetDekByVersion(ctx _context.Context, name string, subject string, version string) ApiGetDekByVersionRequest

	// GetDekByVersionExecute executes the request
	//  @return Dek
	GetDekByVersionExecute(r ApiGetDekByVersionRequest) (Dek, *_nethttp.Response, error)

	/*
	GetDekSubjects Get a list of dek subjects.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name Name of the kek
	 @return ApiGetDekSubjectsRequest
	*/
	GetDekSubjects(ctx _context.Context, name string) ApiGetDekSubjectsRequest

	// GetDekSubjectsExecute executes the request
	//  @return []string
	GetDekSubjectsExecute(r ApiGetDekSubjectsRequest) ([]string, *_nethttp.Response, error)

	/*
	GetDekVersions List versions of dek.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name Name of the kek
	 @param subject Subject of the dek
	 @return ApiGetDekVersionsRequest
	*/
	GetDekVersions(ctx _context.Context, name string, subject string) ApiGetDekVersionsRequest

	// GetDekVersionsExecute executes the request
	//  @return []int32
	GetDekVersionsExecute(r ApiGetDekVersionsRequest) ([]int32, *_nethttp.Response, error)

	/*
	GetExporterConfig Get the config for an exporter.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name
	 @return ApiGetExporterConfigRequest
	*/
	GetExporterConfig(ctx _context.Context, name string) ApiGetExporterConfigRequest

	// GetExporterConfigExecute executes the request
	//  @return map[string]string
	GetExporterConfigExecute(r ApiGetExporterConfigRequest) (map[string]string, *_nethttp.Response, error)

	/*
	GetExporterInfo Get the info for an exporter.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name
	 @return ApiGetExporterInfoRequest
	*/
	GetExporterInfo(ctx _context.Context, name string) ApiGetExporterInfoRequest

	// GetExporterInfoExecute executes the request
	//  @return ExporterInfo
	GetExporterInfoExecute(r ApiGetExporterInfoRequest) (ExporterInfo, *_nethttp.Response, error)

	/*
	GetExporterStatus Get the status for an exporter.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name
	 @return ApiGetExporterStatusRequest
	*/
	GetExporterStatus(ctx _context.Context, name string) ApiGetExporterStatusRequest

	// GetExporterStatusExecute executes the request
	//  @return ExporterStatus
	GetExporterStatusExecute(r ApiGetExporterStatusRequest) (ExporterStatus, *_nethttp.Response, error)

	/*
	GetExporters Get a list of exporter names.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiGetExportersRequest
	*/
	GetExporters(ctx _context.Context) ApiGetExportersRequest

	// GetExportersExecute executes the request
	//  @return []string
	GetExportersExecute(r ApiGetExportersRequest) ([]string, *_nethttp.Response, error)

	/*
	GetKek Get a kek by name.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name Name of the kek
	 @return ApiGetKekRequest
	*/
	GetKek(ctx _context.Context, name string) ApiGetKekRequest

	// GetKekExecute executes the request
	//  @return Kek
	GetKekExecute(r ApiGetKekRequest) (Kek, *_nethttp.Response, error)

	/*
	GetKekNames Get a list of kek names.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiGetKekNamesRequest
	*/
	GetKekNames(ctx _context.Context) ApiGetKekNamesRequest

	// GetKekNamesExecute executes the request
	//  @return []string
	GetKekNamesExecute(r ApiGetKekNamesRequest) ([]string, *_nethttp.Response, error)

	/*
	GetMode Get mode for a subject.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param subject Name of the Subject
	 @return ApiGetModeRequest
	*/
	GetMode(ctx _context.Context, subject string) ApiGetModeRequest

	// GetModeExecute executes the request
	//  @return Mode
	GetModeExecute(r ApiGetModeRequest) (Mode, *_nethttp.Response, error)

	/*
	GetReferencedBy Get the schemas that reference the specified schema.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param subject Name of the Subject
	 @param version Version of the schema to be returned. Valid values for versionId are between [1,2^31-1] or the string \"latest\". \"latest\" returns the last registered schema under the specified subject. Note that there may be a new latest schema that gets registered right after this request is served.
	 @return ApiGetReferencedByRequest
	*/
	GetReferencedBy(ctx _context.Context, subject string, version string) ApiGetReferencedByRequest

	// GetReferencedByExecute executes the request
	//  @return []int32
	GetReferencedByExecute(r ApiGetReferencedByRequest) ([]int32, *_nethttp.Response, error)

	/*
	GetSchema Get the schema string identified by the input ID.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param id Globally unique identifier of the schema
	 @return ApiGetSchemaRequest
	*/
	GetSchema(ctx _context.Context, id int32) ApiGetSchemaRequest

	// GetSchemaExecute executes the request
	//  @return SchemaString
	GetSchemaExecute(r ApiGetSchemaRequest) (SchemaString, *_nethttp.Response, error)

	/*
	GetSchemaByVersion Get a specific version of the schema registered under this subject.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param subject Name of the Subject
	 @param version Version of the schema to be returned. Valid values for versionId are between [1,2^31-1] or the string \"latest\". \"latest\" returns the last registered schema under the specified subject. Note that there may be a new latest schema that gets registered right after this request is served.
	 @return ApiGetSchemaByVersionRequest
	*/
	GetSchemaByVersion(ctx _context.Context, subject string, version string) ApiGetSchemaByVersionRequest

	// GetSchemaByVersionExecute executes the request
	//  @return Schema
	GetSchemaByVersionExecute(r ApiGetSchemaByVersionRequest) (Schema, *_nethttp.Response, error)

	/*
	GetSchemaOnly Get the schema for the specified version of this subject. The unescaped schema only is returned.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param subject Name of the Subject
	 @param version Version of the schema to be returned. Valid values for versionId are between [1,2^31-1] or the string \"latest\". \"latest\" returns the last registered schema under the specified subject. Note that there may be a new latest schema that gets registered right after this request is served.
	 @return ApiGetSchemaOnlyRequest
	*/
	GetSchemaOnly(ctx _context.Context, subject string, version string) ApiGetSchemaOnlyRequest

	// GetSchemaOnlyExecute executes the request
	//  @return string
	GetSchemaOnlyExecute(r ApiGetSchemaOnlyRequest) (string, *_nethttp.Response, error)

	/*
	GetSchemaTypes Get the schema types supported by this registry.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiGetSchemaTypesRequest
	*/
	GetSchemaTypes(ctx _context.Context) ApiGetSchemaTypesRequest

	// GetSchemaTypesExecute executes the request
	//  @return []string
	GetSchemaTypesExecute(r ApiGetSchemaTypesRequest) ([]string, *_nethttp.Response, error)

	/*
	GetSchemas Get the schemas.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiGetSchemasRequest
	*/
	GetSchemas(ctx _context.Context) ApiGetSchemasRequest

	// GetSchemasExecute executes the request
	//  @return []Schema
	GetSchemasExecute(r ApiGetSchemasRequest) ([]Schema, *_nethttp.Response, error)

	/*
	GetSubjectLevelConfig Get compatibility level for a subject.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param subject
	 @return ApiGetSubjectLevelConfigRequest
	*/
	GetSubjectLevelConfig(ctx _context.Context, subject string) ApiGetSubjectLevelConfigRequest

	// GetSubjectLevelConfigExecute executes the request
	//  @return Config
	GetSubjectLevelConfigExecute(r ApiGetSubjectLevelConfigRequest) (Config, *_nethttp.Response, error)

	/*
	GetSubjects Get all the subjects associated with the input ID.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param id Globally unique identifier of the schema
	 @return ApiGetSubjectsRequest
	*/
	GetSubjects(ctx _context.Context, id int32) ApiGetSubjectsRequest

	// GetSubjectsExecute executes the request
	//  @return []string
	GetSubjectsExecute(r ApiGetSubjectsRequest) ([]string, *_nethttp.Response, error)

	/*
	GetTagDefByName Get the tag definition with the given name.

	Get the tag definition with the given name.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param tagName The name of the tag definiton
	 @return ApiGetTagDefByNameRequest
	*/
	GetTagDefByName(ctx _context.Context, tagName string) ApiGetTagDefByNameRequest

	// GetTagDefByNameExecute executes the request
	//  @return TagDef
	GetTagDefByNameExecute(r ApiGetTagDefByNameRequest) (TagDef, *_nethttp.Response, error)

	/*
	GetTags Gets the list of classifications for a given entity represented by a qualifed name.

	Gets the list of classifications for a given entity represented by a qualifed name.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param typeName The type of the entity
	 @param qualifiedName The qualified name of the entity
	 @return ApiGetTagsRequest
	*/
	GetTags(ctx _context.Context, typeName string, qualifiedName string) ApiGetTagsRequest

	// GetTagsExecute executes the request
	//  @return []TagResponse
	GetTagsExecute(r ApiGetTagsRequest) ([]TagResponse, *_nethttp.Response, error)

	/*
	GetTopLevelConfig Get global compatibility level

	Retrieves the global compatibility level.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiGetTopLevelConfigRequest
	*/
	GetTopLevelConfig(ctx _context.Context) ApiGetTopLevelConfigRequest

	// GetTopLevelConfigExecute executes the request
	//  @return Config
	GetTopLevelConfigExecute(r ApiGetTopLevelConfigRequest) (Config, *_nethttp.Response, error)

	/*
	GetTopLevelMode Get global mode.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiGetTopLevelModeRequest
	*/
	GetTopLevelMode(ctx _context.Context) ApiGetTopLevelModeRequest

	// GetTopLevelModeExecute executes the request
	//  @return Mode
	GetTopLevelModeExecute(r ApiGetTopLevelModeRequest) (Mode, *_nethttp.Response, error)

	/*
	GetVersions Get all the subject-version pairs associated with the input ID.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param id Globally unique identifier of the schema
	 @return ApiGetVersionsRequest
	*/
	GetVersions(ctx _context.Context, id int32) ApiGetVersionsRequest

	// GetVersionsExecute executes the request
	//  @return []SubjectVersion
	GetVersionsExecute(r ApiGetVersionsRequest) ([]SubjectVersion, *_nethttp.Response, error)

	/*
	List Get a list of registered subjects.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListRequest
	*/
	List(ctx _context.Context) ApiListRequest

	// ListExecute executes the request
	//  @return []string
	ListExecute(r ApiListRequest) ([]string, *_nethttp.Response, error)

	/*
	ListContexts Get a list of contexts.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListContextsRequest
	*/
	ListContexts(ctx _context.Context) ApiListContextsRequest

	// ListContextsExecute executes the request
	//  @return []string
	ListContextsExecute(r ApiListContextsRequest) ([]string, *_nethttp.Response, error)

	/*
	ListVersions Get a list of versions registered under the specified subject.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param subject Name of the Subject
	 @return ApiListVersionsRequest
	*/
	ListVersions(ctx _context.Context, subject string) ApiListVersionsRequest

	// ListVersionsExecute executes the request
	//  @return []int32
	ListVersionsExecute(r ApiListVersionsRequest) ([]int32, *_nethttp.Response, error)

	/*
	LookUpSchemaUnderSubject Check if a schema has already been registered under the specified subject. If so, this returns the schema string along with its globally unique identifier, its version under this subject and the subject name.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param subject Subject under which the schema will be registered
	 @return ApiLookUpSchemaUnderSubjectRequest
	*/
	LookUpSchemaUnderSubject(ctx _context.Context, subject string) ApiLookUpSchemaUnderSubjectRequest

	// LookUpSchemaUnderSubjectExecute executes the request
	LookUpSchemaUnderSubjectExecute(r ApiLookUpSchemaUnderSubjectRequest) (*_nethttp.Response, error)

	/*
	PartialUpdateByUniqueAttributes Method for PartialUpdateByUniqueAttributes

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiPartialUpdateByUniqueAttributesRequest
	*/
	PartialUpdateByUniqueAttributes(ctx _context.Context) ApiPartialUpdateByUniqueAttributesRequest

	// PartialUpdateByUniqueAttributesExecute executes the request
	PartialUpdateByUniqueAttributesExecute(r ApiPartialUpdateByUniqueAttributesRequest) (*_nethttp.Response, error)

	/*
	PauseExporter Pause an exporter.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name Name of the exporter
	 @return ApiPauseExporterRequest
	*/
	PauseExporter(ctx _context.Context, name string) ApiPauseExporterRequest

	// PauseExporterExecute executes the request
	//  @return UpdateExporterResponse
	PauseExporterExecute(r ApiPauseExporterRequest) (UpdateExporterResponse, *_nethttp.Response, error)

	/*
	Post Method for Post

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiPostRequest
	*/
	Post(ctx _context.Context) ApiPostRequest

	// PostExecute executes the request
	//  @return map[string]string
	PostExecute(r ApiPostRequest) (map[string]string, *_nethttp.Response, error)

	/*
	PutExporter Alters an exporter.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name Name of the exporter
	 @return ApiPutExporterRequest
	*/
	PutExporter(ctx _context.Context, name string) ApiPutExporterRequest

	// PutExporterExecute executes the request
	//  @return UpdateExporterResponse
	PutExporterExecute(r ApiPutExporterRequest) (UpdateExporterResponse, *_nethttp.Response, error)

	/*
	PutExporterConfig Alters the config of an exporter.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name Name of the exporter
	 @return ApiPutExporterConfigRequest
	*/
	PutExporterConfig(ctx _context.Context, name string) ApiPutExporterConfigRequest

	// PutExporterConfigExecute executes the request
	//  @return UpdateExporterResponse
	PutExporterConfigExecute(r ApiPutExporterConfigRequest) (UpdateExporterResponse, *_nethttp.Response, error)

	/*
	PutKek Alters a kek.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name Name of the kek
	 @return ApiPutKekRequest
	*/
	PutKek(ctx _context.Context, name string) ApiPutKekRequest

	// PutKekExecute executes the request
	//  @return Kek
	PutKekExecute(r ApiPutKekRequest) (Kek, *_nethttp.Response, error)

	/*
	Register Register schema under a subject

	Register a new schema under the specified subject. If successfully registered, this returns the unique identifier of this schema in the registry. The returned identifier should be used to retrieve this schema from the schemas resource and is different from the schema's version which is associated with the subject. If the same schema is registered under a different subject, the same identifier will be returned. However, the version of the schema may be different under different subjects.
A schema should be compatible with the previously registered schema or schemas (if there are any) as per the configured compatibility level. The configured compatibility level can be obtained by issuing a GET http:get:: /config/(string: subject). If that returns null, then GET http:get:: /config
When there are multiple instances of Schema Registry running in the same cluster, the schema registration request will be forwarded to one of the instances designated as the primary. If the primary is not available, the client will get an error code indicating that the forwarding has failed.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param subject Name of the subject
	 @return ApiRegisterRequest
	*/
	Register(ctx _context.Context, subject string) ApiRegisterRequest

	// RegisterExecute executes the request
	//  @return RegisterSchemaResponse
	RegisterExecute(r ApiRegisterRequest) (RegisterSchemaResponse, *_nethttp.Response, error)

	/*
	ResetExporter Reset an exporter.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name Name of the exporter
	 @return ApiResetExporterRequest
	*/
	ResetExporter(ctx _context.Context, name string) ApiResetExporterRequest

	// ResetExporterExecute executes the request
	//  @return UpdateExporterResponse
	ResetExporterExecute(r ApiResetExporterRequest) (UpdateExporterResponse, *_nethttp.Response, error)

	/*
	ResumeExporter Resume an exporter.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name Name of the exporter
	 @return ApiResumeExporterRequest
	*/
	ResumeExporter(ctx _context.Context, name string) ApiResumeExporterRequest

	// ResumeExporterExecute executes the request
	//  @return UpdateExporterResponse
	ResumeExporterExecute(r ApiResumeExporterRequest) (UpdateExporterResponse, *_nethttp.Response, error)

	/*
	SearchUsingAttribute Retrieve data for the specified attribute search query.

	Retrieve data for the specified attribute search query.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiSearchUsingAttributeRequest
	*/
	SearchUsingAttribute(ctx _context.Context) ApiSearchUsingAttributeRequest

	// SearchUsingAttributeExecute executes the request
	//  @return SearchResult
	SearchUsingAttributeExecute(r ApiSearchUsingAttributeRequest) (SearchResult, *_nethttp.Response, error)

	/*
	SearchUsingBasic Retrieve data for the specified fulltext query.

	Retrieve data for the specified fulltext query.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiSearchUsingBasicRequest
	*/
	SearchUsingBasic(ctx _context.Context) ApiSearchUsingBasicRequest

	// SearchUsingBasicExecute executes the request
	//  @return SearchResult
	SearchUsingBasicExecute(r ApiSearchUsingBasicRequest) (SearchResult, *_nethttp.Response, error)

	/*
	TestCompatibilityBySubjectName Test input schema against a particular version of a subject's schema for compatibility.

	the compatibility level applied for the check is the configured compatibility level for the subject (http:get:: /config/(string: subject)). If this subject's compatibility level was never changed, then the global compatibility level applies (http:get:: /config).

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param subject Subject of the schema version against which compatibility is to be tested
	 @param version Version of the subject's schema against which compatibility is to be tested. Valid values for versionId are between [1,2^31-1] or the string \"latest\".\"latest\" checks compatibility of the input schema with the last registered schema under the specified subject
	 @return ApiTestCompatibilityBySubjectNameRequest
	*/
	TestCompatibilityBySubjectName(ctx _context.Context, subject string, version string) ApiTestCompatibilityBySubjectNameRequest

	// TestCompatibilityBySubjectNameExecute executes the request
	//  @return CompatibilityCheckResponse
	TestCompatibilityBySubjectNameExecute(r ApiTestCompatibilityBySubjectNameRequest) (CompatibilityCheckResponse, *_nethttp.Response, error)

	/*
	TestCompatibilityForSubject Test input schema against a subject's schemas for compatibility, based on the compatibility level of the subject configured. In other word, it will perform the same compatibility check as register for that subject

	the compatibility level applied for the check is the configured compatibility level for the subject (http:get:: /config/(string: subject)). If this subject's compatibility level was never changed, then the global compatibility level applies (http:get:: /config).

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param subject Subject of the schema version against which compatibility is to be tested
	 @return ApiTestCompatibilityForSubjectRequest
	*/
	TestCompatibilityForSubject(ctx _context.Context, subject string) ApiTestCompatibilityForSubjectRequest

	// TestCompatibilityForSubjectExecute executes the request
	//  @return CompatibilityCheckResponse
	TestCompatibilityForSubjectExecute(r ApiTestCompatibilityForSubjectRequest) (CompatibilityCheckResponse, *_nethttp.Response, error)

	/*
	UndeleteDekVersion Undelete a dek version.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name Name of the kek
	 @param subject Subject of the dek
	 @param version Version of the dek
	 @return ApiUndeleteDekVersionRequest
	*/
	UndeleteDekVersion(ctx _context.Context, name string, subject string, version string) ApiUndeleteDekVersionRequest

	// UndeleteDekVersionExecute executes the request
	UndeleteDekVersionExecute(r ApiUndeleteDekVersionRequest) (*_nethttp.Response, error)

	/*
	UndeleteDekVersions Undelete all versions of a dek.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name Name of the kek
	 @param subject Subject of the dek
	 @return ApiUndeleteDekVersionsRequest
	*/
	UndeleteDekVersions(ctx _context.Context, name string, subject string) ApiUndeleteDekVersionsRequest

	// UndeleteDekVersionsExecute executes the request
	UndeleteDekVersionsExecute(r ApiUndeleteDekVersionsRequest) (*_nethttp.Response, error)

	/*
	UndeleteKek Undelete a kek.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name Name of the kek
	 @return ApiUndeleteKekRequest
	*/
	UndeleteKek(ctx _context.Context, name string) ApiUndeleteKekRequest

	// UndeleteKekExecute executes the request
	UndeleteKekExecute(r ApiUndeleteKekRequest) (*_nethttp.Response, error)

	/*
	UpdateBusinessMetadata Bulk API to update multiple business metadata.

	Bulk API to update multiple business metadata.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiUpdateBusinessMetadataRequest
	*/
	UpdateBusinessMetadata(ctx _context.Context) ApiUpdateBusinessMetadataRequest

	// UpdateBusinessMetadataExecute executes the request
	//  @return []BusinessMetadataResponse
	UpdateBusinessMetadataExecute(r ApiUpdateBusinessMetadataRequest) ([]BusinessMetadataResponse, *_nethttp.Response, error)

	/*
	UpdateBusinessMetadataDefs Bulk update API for business metadata definitions.

	Bulk update API for business metadata definitions.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiUpdateBusinessMetadataDefsRequest
	*/
	UpdateBusinessMetadataDefs(ctx _context.Context) ApiUpdateBusinessMetadataDefsRequest

	// UpdateBusinessMetadataDefsExecute executes the request
	//  @return []BusinessMetadataDefResponse
	UpdateBusinessMetadataDefsExecute(r ApiUpdateBusinessMetadataDefsRequest) ([]BusinessMetadataDefResponse, *_nethttp.Response, error)

	/*
	UpdateMode Update mode for the specified subject.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param subject Name of the Subject
	 @return ApiUpdateModeRequest
	*/
	UpdateMode(ctx _context.Context, subject string) ApiUpdateModeRequest

	// UpdateModeExecute executes the request
	//  @return ModeUpdateRequest
	UpdateModeExecute(r ApiUpdateModeRequest) (ModeUpdateRequest, *_nethttp.Response, error)

	/*
	UpdateSubjectLevelConfig Update compatibility level for the specified subject.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param subject Name of the Subject
	 @return ApiUpdateSubjectLevelConfigRequest
	*/
	UpdateSubjectLevelConfig(ctx _context.Context, subject string) ApiUpdateSubjectLevelConfigRequest

	// UpdateSubjectLevelConfigExecute executes the request
	//  @return ConfigUpdateRequest
	UpdateSubjectLevelConfigExecute(r ApiUpdateSubjectLevelConfigRequest) (ConfigUpdateRequest, *_nethttp.Response, error)

	/*
	UpdateTagDefs Bulk update API for tag definitions.

	Bulk update API for tag definitions.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiUpdateTagDefsRequest
	*/
	UpdateTagDefs(ctx _context.Context) ApiUpdateTagDefsRequest

	// UpdateTagDefsExecute executes the request
	//  @return []TagDefResponse
	UpdateTagDefsExecute(r ApiUpdateTagDefsRequest) ([]TagDefResponse, *_nethttp.Response, error)

	/*
	UpdateTags Bulk API to update multiple tags.

	Bulk API to update multiple tags.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiUpdateTagsRequest
	*/
	UpdateTags(ctx _context.Context) ApiUpdateTagsRequest

	// UpdateTagsExecute executes the request
	//  @return []TagResponse
	UpdateTagsExecute(r ApiUpdateTagsRequest) ([]TagResponse, *_nethttp.Response, error)

	/*
	UpdateTopLevelConfig Update global compatibility level

	Updates the global compatibility level. On success, echoes the original request back to the client.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiUpdateTopLevelConfigRequest
	*/
	UpdateTopLevelConfig(ctx _context.Context) ApiUpdateTopLevelConfigRequest

	// UpdateTopLevelConfigExecute executes the request
	//  @return ConfigUpdateRequest
	UpdateTopLevelConfigExecute(r ApiUpdateTopLevelConfigRequest) (ConfigUpdateRequest, *_nethttp.Response, error)

	/*
	UpdateTopLevelMode Update global mode.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiUpdateTopLevelModeRequest
	*/
	UpdateTopLevelMode(ctx _context.Context) ApiUpdateTopLevelModeRequest

	// UpdateTopLevelModeExecute executes the request
	//  @return ModeUpdateRequest
	UpdateTopLevelModeExecute(r ApiUpdateTopLevelModeRequest) (ModeUpdateRequest, *_nethttp.Response, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiAsyncapiParsePutRequest struct {
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiAsyncapiParsePutRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AsyncapiParsePutExecute(r)
}

/*
AsyncapiParsePut Method for AsyncapiParsePut

Get number of times the cli tool is used to import and parse the spec file

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAsyncapiParsePutRequest
*/
func (a *DefaultApiService) AsyncapiParsePut(ctx _context.Context) ApiAsyncapiParsePutRequest {
	return ApiAsyncapiParsePutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) AsyncapiParsePutExecute(r ApiAsyncapiParsePutRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AsyncapiParsePut")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asyncapi/parse"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAsyncapiPutRequest struct {
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiAsyncapiPutRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AsyncapiPutExecute(r)
}

/*
AsyncapiPut Method for AsyncapiPut

Get number of times the cli tool is used to export/produce the spec file

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAsyncapiPutRequest
*/
func (a *DefaultApiService) AsyncapiPut(ctx _context.Context) ApiAsyncapiPutRequest {
	return ApiAsyncapiPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) AsyncapiPutExecute(r ApiAsyncapiPutRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AsyncapiPut")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asyncapi"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateBusinessMetadataRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	businessMetadata *[]BusinessMetadata
}

// The business metadata
func (r ApiCreateBusinessMetadataRequest) BusinessMetadata(businessMetadata []BusinessMetadata) ApiCreateBusinessMetadataRequest {
	r.businessMetadata = &businessMetadata
	return r
}

func (r ApiCreateBusinessMetadataRequest) Execute() ([]BusinessMetadataResponse, *_nethttp.Response, error) {
	return r.ApiService.CreateBusinessMetadataExecute(r)
}

/*
CreateBusinessMetadata Bulk API to create multiple business metadata.

Bulk API to create multiple business metadata.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBusinessMetadataRequest
*/
func (a *DefaultApiService) CreateBusinessMetadata(ctx _context.Context) ApiCreateBusinessMetadataRequest {
	return ApiCreateBusinessMetadataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BusinessMetadataResponse
func (a *DefaultApiService) CreateBusinessMetadataExecute(r ApiCreateBusinessMetadataRequest) ([]BusinessMetadataResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BusinessMetadataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateBusinessMetadata")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/entity/businessmetadata"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.businessMetadata
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBusinessMetadataDefsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	atlasBusinessMetadataDef *[]AtlasBusinessMetadataDef
}

// The business metadata definitions to create
func (r ApiCreateBusinessMetadataDefsRequest) AtlasBusinessMetadataDef(atlasBusinessMetadataDef []AtlasBusinessMetadataDef) ApiCreateBusinessMetadataDefsRequest {
	r.atlasBusinessMetadataDef = &atlasBusinessMetadataDef
	return r
}

func (r ApiCreateBusinessMetadataDefsRequest) Execute() ([]BusinessMetadataDefResponse, *_nethttp.Response, error) {
	return r.ApiService.CreateBusinessMetadataDefsExecute(r)
}

/*
CreateBusinessMetadataDefs Bulk create API for business metadata definitions.

Bulk create API for business metadata definitions.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBusinessMetadataDefsRequest
*/
func (a *DefaultApiService) CreateBusinessMetadataDefs(ctx _context.Context) ApiCreateBusinessMetadataDefsRequest {
	return ApiCreateBusinessMetadataDefsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BusinessMetadataDefResponse
func (a *DefaultApiService) CreateBusinessMetadataDefsExecute(r ApiCreateBusinessMetadataDefsRequest) ([]BusinessMetadataDefResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BusinessMetadataDefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateBusinessMetadataDefs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/types/businessmetadatadefs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.atlasBusinessMetadataDef
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDekRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
	createDekRequest *CreateDekRequest
}

// The create request
func (r ApiCreateDekRequest) CreateDekRequest(createDekRequest CreateDekRequest) ApiCreateDekRequest {
	r.createDekRequest = &createDekRequest
	return r
}

func (r ApiCreateDekRequest) Execute() (Dek, *_nethttp.Response, error) {
	return r.ApiService.CreateDekExecute(r)
}

/*
CreateDek Create a dek.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the kek
 @return ApiCreateDekRequest
*/
func (a *DefaultApiService) CreateDek(ctx _context.Context, name string) ApiCreateDekRequest {
	return ApiCreateDekRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return Dek
func (a *DefaultApiService) CreateDekExecute(r ApiCreateDekRequest) (Dek, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Dek
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateDek")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dek-registry/v1/keks/{name}/deks"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.createDekRequest == nil {
		return localVarReturnValue, nil, reportError("createDekRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json", "application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createDekRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateExporterRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	body *CreateExporterRequest
}

// Info
func (r ApiCreateExporterRequest) Body(body CreateExporterRequest) ApiCreateExporterRequest {
	r.body = &body
	return r
}

func (r ApiCreateExporterRequest) Execute() (CreateExporterResponse, *_nethttp.Response, error) {
	return r.ApiService.CreateExporterExecute(r)
}

/*
CreateExporter Create an exporter.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateExporterRequest
*/
func (a *DefaultApiService) CreateExporter(ctx _context.Context) ApiCreateExporterRequest {
	return ApiCreateExporterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateExporterResponse
func (a *DefaultApiService) CreateExporterExecute(r ApiCreateExporterRequest) (CreateExporterResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CreateExporterResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateExporter")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exporters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json", "application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateKekRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	createKekRequest *CreateKekRequest
}

// The create request
func (r ApiCreateKekRequest) CreateKekRequest(createKekRequest CreateKekRequest) ApiCreateKekRequest {
	r.createKekRequest = &createKekRequest
	return r
}

func (r ApiCreateKekRequest) Execute() (Kek, *_nethttp.Response, error) {
	return r.ApiService.CreateKekExecute(r)
}

/*
CreateKek Create a kek.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateKekRequest
*/
func (a *DefaultApiService) CreateKek(ctx _context.Context) ApiCreateKekRequest {
	return ApiCreateKekRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Kek
func (a *DefaultApiService) CreateKekExecute(r ApiCreateKekRequest) (Kek, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Kek
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateKek")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dek-registry/v1/keks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.createKekRequest == nil {
		return localVarReturnValue, nil, reportError("createKekRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json", "application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createKekRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOrUpdateRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	atlasEntityWithExtInfo *AtlasEntityWithExtInfo
}

func (r ApiCreateOrUpdateRequest) AtlasEntityWithExtInfo(atlasEntityWithExtInfo AtlasEntityWithExtInfo) ApiCreateOrUpdateRequest {
	r.atlasEntityWithExtInfo = &atlasEntityWithExtInfo
	return r
}

func (r ApiCreateOrUpdateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateOrUpdateExecute(r)
}

/*
CreateOrUpdate Method for CreateOrUpdate

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOrUpdateRequest
*/
func (a *DefaultApiService) CreateOrUpdate(ctx _context.Context) ApiCreateOrUpdateRequest {
	return ApiCreateOrUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) CreateOrUpdateExecute(r ApiCreateOrUpdateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateOrUpdate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/entity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.atlasEntityWithExtInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateTagDefsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	tagDef *[]TagDef
}

// The tag definitions to create
func (r ApiCreateTagDefsRequest) TagDef(tagDef []TagDef) ApiCreateTagDefsRequest {
	r.tagDef = &tagDef
	return r
}

func (r ApiCreateTagDefsRequest) Execute() ([]TagDefResponse, *_nethttp.Response, error) {
	return r.ApiService.CreateTagDefsExecute(r)
}

/*
CreateTagDefs Bulk create API for tag definitions.

Bulk create API for tag definitions.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTagDefsRequest
*/
func (a *DefaultApiService) CreateTagDefs(ctx _context.Context) ApiCreateTagDefsRequest {
	return ApiCreateTagDefsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TagDefResponse
func (a *DefaultApiService) CreateTagDefsExecute(r ApiCreateTagDefsRequest) ([]TagDefResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []TagDefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateTagDefs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/types/tagdefs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagDef
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTagsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	tag *[]Tag
}

// The tags
func (r ApiCreateTagsRequest) Tag(tag []Tag) ApiCreateTagsRequest {
	r.tag = &tag
	return r
}

func (r ApiCreateTagsRequest) Execute() ([]TagResponse, *_nethttp.Response, error) {
	return r.ApiService.CreateTagsExecute(r)
}

/*
CreateTags Bulk API to create multiple tags.

Bulk API to create multiple tags.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTagsRequest
*/
func (a *DefaultApiService) CreateTags(ctx _context.Context) ApiCreateTagsRequest {
	return ApiCreateTagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TagResponse
func (a *DefaultApiService) CreateTagsExecute(r ApiCreateTagsRequest) ([]TagResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []TagResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateTags")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/entity/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tag
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBusinessMetadataRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	typeName string
	qualifiedName string
	bmName string
}


func (r ApiDeleteBusinessMetadataRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteBusinessMetadataExecute(r)
}

/*
DeleteBusinessMetadata Delete a business metadata on an entity.

Delete a business metadata on an entity.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param typeName The type of the entity
 @param qualifiedName The qualified name of the entity
 @param bmName The name of the business metadata
 @return ApiDeleteBusinessMetadataRequest
*/
func (a *DefaultApiService) DeleteBusinessMetadata(ctx _context.Context, typeName string, qualifiedName string, bmName string) ApiDeleteBusinessMetadataRequest {
	return ApiDeleteBusinessMetadataRequest{
		ApiService: a,
		ctx: ctx,
		typeName: typeName,
		qualifiedName: qualifiedName,
		bmName: bmName,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteBusinessMetadataExecute(r ApiDeleteBusinessMetadataRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteBusinessMetadata")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/entity/type/{typeName}/name/{qualifiedName}/businessmetadata/{bmName}"
	localVarPath = strings.Replace(localVarPath, "{"+"typeName"+"}", _neturl.PathEscape(parameterToString(r.typeName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"qualifiedName"+"}", _neturl.PathEscape(parameterToString(r.qualifiedName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bmName"+"}", _neturl.PathEscape(parameterToString(r.bmName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteBusinessMetadataDefRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	bmName string
}


func (r ApiDeleteBusinessMetadataDefRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteBusinessMetadataDefExecute(r)
}

/*
DeleteBusinessMetadataDef Delete API for business metadata definition identified by its name.

Delete API for business metadata definition identified by its name.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bmName The name of the business metadata definition
 @return ApiDeleteBusinessMetadataDefRequest
*/
func (a *DefaultApiService) DeleteBusinessMetadataDef(ctx _context.Context, bmName string) ApiDeleteBusinessMetadataDefRequest {
	return ApiDeleteBusinessMetadataDefRequest{
		ApiService: a,
		ctx: ctx,
		bmName: bmName,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteBusinessMetadataDefExecute(r ApiDeleteBusinessMetadataDefRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteBusinessMetadataDef")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/types/businessmetadatadefs/{bmName}"
	localVarPath = strings.Replace(localVarPath, "{"+"bmName"+"}", _neturl.PathEscape(parameterToString(r.bmName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteByUniqueAttributesRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	typeName string
	qualifiedName string
}


func (r ApiDeleteByUniqueAttributesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteByUniqueAttributesExecute(r)
}

/*
DeleteByUniqueAttributes Method for DeleteByUniqueAttributes

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param typeName
 @param qualifiedName
 @return ApiDeleteByUniqueAttributesRequest
*/
func (a *DefaultApiService) DeleteByUniqueAttributes(ctx _context.Context, typeName string, qualifiedName string) ApiDeleteByUniqueAttributesRequest {
	return ApiDeleteByUniqueAttributesRequest{
		ApiService: a,
		ctx: ctx,
		typeName: typeName,
		qualifiedName: qualifiedName,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteByUniqueAttributesExecute(r ApiDeleteByUniqueAttributesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteByUniqueAttributes")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/entity/type/{typeName}/name/{qualifiedName}"
	localVarPath = strings.Replace(localVarPath, "{"+"typeName"+"}", _neturl.PathEscape(parameterToString(r.typeName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"qualifiedName"+"}", _neturl.PathEscape(parameterToString(r.qualifiedName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteDekVersionRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
	subject string
	version string
	algorithm *string
	permanent *bool
}

// Algorithm of the dek
func (r ApiDeleteDekVersionRequest) Algorithm(algorithm string) ApiDeleteDekVersionRequest {
	r.algorithm = &algorithm
	return r
}
// Whether to perform a permanent delete
func (r ApiDeleteDekVersionRequest) Permanent(permanent bool) ApiDeleteDekVersionRequest {
	r.permanent = &permanent
	return r
}

func (r ApiDeleteDekVersionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteDekVersionExecute(r)
}

/*
DeleteDekVersion Delete a dek version.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the kek
 @param subject Subject of the dek
 @param version Version of the dek
 @return ApiDeleteDekVersionRequest
*/
func (a *DefaultApiService) DeleteDekVersion(ctx _context.Context, name string, subject string, version string) ApiDeleteDekVersionRequest {
	return ApiDeleteDekVersionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		subject: subject,
		version: version,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteDekVersionExecute(r ApiDeleteDekVersionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteDekVersion")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dek-registry/v1/keks/{name}/deks/{subject}/versions/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.algorithm != nil {
		localVarQueryParams.Add("algorithm", parameterToString(*r.algorithm, ""))
	}
	if r.permanent != nil {
		localVarQueryParams.Add("permanent", parameterToString(*r.permanent, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteDekVersionsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
	subject string
	algorithm *string
	permanent *bool
}

// Algorithm of the dek
func (r ApiDeleteDekVersionsRequest) Algorithm(algorithm string) ApiDeleteDekVersionsRequest {
	r.algorithm = &algorithm
	return r
}
// Whether to perform a permanent delete
func (r ApiDeleteDekVersionsRequest) Permanent(permanent bool) ApiDeleteDekVersionsRequest {
	r.permanent = &permanent
	return r
}

func (r ApiDeleteDekVersionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteDekVersionsExecute(r)
}

/*
DeleteDekVersions Delete all versions of a dek.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the kek
 @param subject Subject of the dek
 @return ApiDeleteDekVersionsRequest
*/
func (a *DefaultApiService) DeleteDekVersions(ctx _context.Context, name string, subject string) ApiDeleteDekVersionsRequest {
	return ApiDeleteDekVersionsRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		subject: subject,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteDekVersionsExecute(r ApiDeleteDekVersionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteDekVersions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dek-registry/v1/keks/{name}/deks/{subject}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.algorithm != nil {
		localVarQueryParams.Add("algorithm", parameterToString(*r.algorithm, ""))
	}
	if r.permanent != nil {
		localVarQueryParams.Add("permanent", parameterToString(*r.permanent, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteExporterRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
}


func (r ApiDeleteExporterRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteExporterExecute(r)
}

/*
DeleteExporter Delete an exporter.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the exporter
 @return ApiDeleteExporterRequest
*/
func (a *DefaultApiService) DeleteExporter(ctx _context.Context, name string) ApiDeleteExporterRequest {
	return ApiDeleteExporterRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteExporterExecute(r ApiDeleteExporterRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteExporter")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exporters/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteKekRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
	permanent *bool
}

// Whether to perform a permanent delete
func (r ApiDeleteKekRequest) Permanent(permanent bool) ApiDeleteKekRequest {
	r.permanent = &permanent
	return r
}

func (r ApiDeleteKekRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKekExecute(r)
}

/*
DeleteKek Delete a kek.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the kek
 @return ApiDeleteKekRequest
*/
func (a *DefaultApiService) DeleteKek(ctx _context.Context, name string) ApiDeleteKekRequest {
	return ApiDeleteKekRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteKekExecute(r ApiDeleteKekRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteKek")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dek-registry/v1/keks/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.permanent != nil {
		localVarQueryParams.Add("permanent", parameterToString(*r.permanent, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSchemaVersionRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subject string
	version string
	permanent *bool
}

func (r ApiDeleteSchemaVersionRequest) Permanent(permanent bool) ApiDeleteSchemaVersionRequest {
	r.permanent = &permanent
	return r
}

func (r ApiDeleteSchemaVersionRequest) Execute() (int32, *_nethttp.Response, error) {
	return r.ApiService.DeleteSchemaVersionExecute(r)
}

/*
DeleteSchemaVersion Deletes a specific version of the schema registered under this subject. This only deletes the version and the schema ID remains intact making it still possible to decode data using the schema ID. This API is recommended to be used only in development environments or under extreme circumstances where-in, its required to delete a previously registered schema for compatibility purposes or re-register previously registered schema.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subject Name of the Subject
 @param version Version of the schema to be returned. Valid values for versionId are between [1,2^31-1] or the string \"latest\". \"latest\" returns the last registered schema under the specified subject. Note that there may be a new latest schema that gets registered right after this request is served.
 @return ApiDeleteSchemaVersionRequest
*/
func (a *DefaultApiService) DeleteSchemaVersion(ctx _context.Context, subject string, version string) ApiDeleteSchemaVersionRequest {
	return ApiDeleteSchemaVersionRequest{
		ApiService: a,
		ctx: ctx,
		subject: subject,
		version: version,
	}
}

// Execute executes the request
//  @return int32
func (a *DefaultApiService) DeleteSchemaVersionExecute(r ApiDeleteSchemaVersionRequest) (int32, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSchemaVersion")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subjects/{subject}/versions/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.permanent != nil {
		localVarQueryParams.Add("permanent", parameterToString(*r.permanent, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSubjectRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subject string
	permanent *bool
}

func (r ApiDeleteSubjectRequest) Permanent(permanent bool) ApiDeleteSubjectRequest {
	r.permanent = &permanent
	return r
}

func (r ApiDeleteSubjectRequest) Execute() ([]int32, *_nethttp.Response, error) {
	return r.ApiService.DeleteSubjectExecute(r)
}

/*
DeleteSubject Deletes the specified subject and its associated compatibility level if registered. It is recommended to use this API only when a topic needs to be recycled or in development environment.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subject the name of the subject
 @return ApiDeleteSubjectRequest
*/
func (a *DefaultApiService) DeleteSubject(ctx _context.Context, subject string) ApiDeleteSubjectRequest {
	return ApiDeleteSubjectRequest{
		ApiService: a,
		ctx: ctx,
		subject: subject,
	}
}

// Execute executes the request
//  @return []int32
func (a *DefaultApiService) DeleteSubjectExecute(r ApiDeleteSubjectRequest) ([]int32, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSubject")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subjects/{subject}"
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.permanent != nil {
		localVarQueryParams.Add("permanent", parameterToString(*r.permanent, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSubjectConfigRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subject string
}


func (r ApiDeleteSubjectConfigRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DeleteSubjectConfigExecute(r)
}

/*
DeleteSubjectConfig Deletes the specified subject-level compatibility level config and revert to the global default.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subject the name of the subject
 @return ApiDeleteSubjectConfigRequest
*/
func (a *DefaultApiService) DeleteSubjectConfig(ctx _context.Context, subject string) ApiDeleteSubjectConfigRequest {
	return ApiDeleteSubjectConfigRequest{
		ApiService: a,
		ctx: ctx,
		subject: subject,
	}
}

// Execute executes the request
//  @return string
func (a *DefaultApiService) DeleteSubjectConfigExecute(r ApiDeleteSubjectConfigRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSubjectConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/{subject}"
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSubjectModeRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subject string
}


func (r ApiDeleteSubjectModeRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DeleteSubjectModeExecute(r)
}

/*
DeleteSubjectMode Deletes the specified subject-level mode and revert to the global default.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subject the name of the subject
 @return ApiDeleteSubjectModeRequest
*/
func (a *DefaultApiService) DeleteSubjectMode(ctx _context.Context, subject string) ApiDeleteSubjectModeRequest {
	return ApiDeleteSubjectModeRequest{
		ApiService: a,
		ctx: ctx,
		subject: subject,
	}
}

// Execute executes the request
//  @return string
func (a *DefaultApiService) DeleteSubjectModeExecute(r ApiDeleteSubjectModeRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSubjectMode")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mode/{subject}"
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteTagRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	typeName string
	qualifiedName string
	tagName string
}


func (r ApiDeleteTagRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteTagExecute(r)
}

/*
DeleteTag Delete a tag on an entity.

Delete a tag on an entity.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param typeName The type of the entity
 @param qualifiedName The qualified name of the entity
 @param tagName The name of the tag
 @return ApiDeleteTagRequest
*/
func (a *DefaultApiService) DeleteTag(ctx _context.Context, typeName string, qualifiedName string, tagName string) ApiDeleteTagRequest {
	return ApiDeleteTagRequest{
		ApiService: a,
		ctx: ctx,
		typeName: typeName,
		qualifiedName: qualifiedName,
		tagName: tagName,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteTagExecute(r ApiDeleteTagRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteTag")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/entity/type/{typeName}/name/{qualifiedName}/tags/{tagName}"
	localVarPath = strings.Replace(localVarPath, "{"+"typeName"+"}", _neturl.PathEscape(parameterToString(r.typeName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"qualifiedName"+"}", _neturl.PathEscape(parameterToString(r.qualifiedName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagName"+"}", _neturl.PathEscape(parameterToString(r.tagName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTagDefRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	tagName string
}


func (r ApiDeleteTagDefRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteTagDefExecute(r)
}

/*
DeleteTagDef Delete API for tag definition identified by its name.

Delete API for tag definition identified by its name.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tagName The name of the tag definition
 @return ApiDeleteTagDefRequest
*/
func (a *DefaultApiService) DeleteTagDef(ctx _context.Context, tagName string) ApiDeleteTagDefRequest {
	return ApiDeleteTagDefRequest{
		ApiService: a,
		ctx: ctx,
		tagName: tagName,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteTagDefExecute(r ApiDeleteTagDefRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteTagDef")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/types/tagdefs/{tagName}"
	localVarPath = strings.Replace(localVarPath, "{"+"tagName"+"}", _neturl.PathEscape(parameterToString(r.tagName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTopLevelConfigRequest struct {
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiDeleteTopLevelConfigRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.DeleteTopLevelConfigExecute(r)
}

/*
DeleteTopLevelConfig Delete global compatibility level

Deletes the global compatibility level config and reverts to the default.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteTopLevelConfigRequest
*/
func (a *DefaultApiService) DeleteTopLevelConfig(ctx _context.Context) ApiDeleteTopLevelConfigRequest {
	return ApiDeleteTopLevelConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DefaultApiService) DeleteTopLevelConfigExecute(r ApiDeleteTopLevelConfigRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteTopLevelConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiGetRequest) Execute() (map[string]map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GetExecute(r)
}

/*
Get Schema Registry Root Resource

The Root resource is a no-op.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRequest
*/
func (a *DefaultApiService) Get(ctx _context.Context) ApiGetRequest {
	return ApiGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]map[string]interface{}
func (a *DefaultApiService) GetExecute(r ApiGetRequest) (map[string]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Get")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllBusinessMetadataDefsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	prefix *string
}

// The prefix of a business metadata definition name
func (r ApiGetAllBusinessMetadataDefsRequest) Prefix(prefix string) ApiGetAllBusinessMetadataDefsRequest {
	r.prefix = &prefix
	return r
}

func (r ApiGetAllBusinessMetadataDefsRequest) Execute() ([]BusinessMetadataDefResponse, *_nethttp.Response, error) {
	return r.ApiService.GetAllBusinessMetadataDefsExecute(r)
}

/*
GetAllBusinessMetadataDefs Bulk retrieval API for retrieving business metadata definitions.

Bulk retrieval API for retrieving business metadata definitions.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllBusinessMetadataDefsRequest
*/
func (a *DefaultApiService) GetAllBusinessMetadataDefs(ctx _context.Context) ApiGetAllBusinessMetadataDefsRequest {
	return ApiGetAllBusinessMetadataDefsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BusinessMetadataDefResponse
func (a *DefaultApiService) GetAllBusinessMetadataDefsExecute(r ApiGetAllBusinessMetadataDefsRequest) ([]BusinessMetadataDefResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BusinessMetadataDefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAllBusinessMetadataDefs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/types/businessmetadatadefs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllTagDefsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	prefix *string
}

// The prefix of a tag definition name
func (r ApiGetAllTagDefsRequest) Prefix(prefix string) ApiGetAllTagDefsRequest {
	r.prefix = &prefix
	return r
}

func (r ApiGetAllTagDefsRequest) Execute() ([]TagDefResponse, *_nethttp.Response, error) {
	return r.ApiService.GetAllTagDefsExecute(r)
}

/*
GetAllTagDefs Bulk retrieval API for retrieving tag definitions.

Bulk retrieval API for retrieving tag definitions.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllTagDefsRequest
*/
func (a *DefaultApiService) GetAllTagDefs(ctx _context.Context) ApiGetAllTagDefsRequest {
	return ApiGetAllTagDefsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TagDefResponse
func (a *DefaultApiService) GetAllTagDefsExecute(r ApiGetAllTagDefsRequest) ([]TagDefResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []TagDefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAllTagDefs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/types/tagdefs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBusinessMetadataRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	typeName string
	qualifiedName string
}


func (r ApiGetBusinessMetadataRequest) Execute() ([]BusinessMetadataResponse, *_nethttp.Response, error) {
	return r.ApiService.GetBusinessMetadataExecute(r)
}

/*
GetBusinessMetadata Gets the list of business metadata for a given entity represented by a qualified name.

Gets the list of business metadata for a given entity represented by a qualified name.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param typeName The type of the entity
 @param qualifiedName The qualified name of the entity
 @return ApiGetBusinessMetadataRequest
*/
func (a *DefaultApiService) GetBusinessMetadata(ctx _context.Context, typeName string, qualifiedName string) ApiGetBusinessMetadataRequest {
	return ApiGetBusinessMetadataRequest{
		ApiService: a,
		ctx: ctx,
		typeName: typeName,
		qualifiedName: qualifiedName,
	}
}

// Execute executes the request
//  @return []BusinessMetadataResponse
func (a *DefaultApiService) GetBusinessMetadataExecute(r ApiGetBusinessMetadataRequest) ([]BusinessMetadataResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BusinessMetadataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetBusinessMetadata")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/entity/type/{typeName}/name/{qualifiedName}/businessmetadata"
	localVarPath = strings.Replace(localVarPath, "{"+"typeName"+"}", _neturl.PathEscape(parameterToString(r.typeName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"qualifiedName"+"}", _neturl.PathEscape(parameterToString(r.qualifiedName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBusinessMetadataDefByNameRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	bmName string
}


func (r ApiGetBusinessMetadataDefByNameRequest) Execute() (AtlasBusinessMetadataDef, *_nethttp.Response, error) {
	return r.ApiService.GetBusinessMetadataDefByNameExecute(r)
}

/*
GetBusinessMetadataDefByName Get the business metadata definition with the given name.

Get the business metadata definition with the given name.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bmName The name of the business metadata definition
 @return ApiGetBusinessMetadataDefByNameRequest
*/
func (a *DefaultApiService) GetBusinessMetadataDefByName(ctx _context.Context, bmName string) ApiGetBusinessMetadataDefByNameRequest {
	return ApiGetBusinessMetadataDefByNameRequest{
		ApiService: a,
		ctx: ctx,
		bmName: bmName,
	}
}

// Execute executes the request
//  @return AtlasBusinessMetadataDef
func (a *DefaultApiService) GetBusinessMetadataDefByNameExecute(r ApiGetBusinessMetadataDefByNameRequest) (AtlasBusinessMetadataDef, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AtlasBusinessMetadataDef
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetBusinessMetadataDefByName")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/types/businessmetadatadefs/{bmName}"
	localVarPath = strings.Replace(localVarPath, "{"+"bmName"+"}", _neturl.PathEscape(parameterToString(r.bmName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetByUniqueAttributesRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	typeName string
	qualifiedName string
	minExtInfo *bool
	ignoreRelationships *bool
	includeInternalPrefix *string
}

// Whether to only populate header and schema attributes
func (r ApiGetByUniqueAttributesRequest) MinExtInfo(minExtInfo bool) ApiGetByUniqueAttributesRequest {
	r.minExtInfo = &minExtInfo
	return r
}
// Whether to ignore relationships
func (r ApiGetByUniqueAttributesRequest) IgnoreRelationships(ignoreRelationships bool) ApiGetByUniqueAttributesRequest {
	r.ignoreRelationships = &ignoreRelationships
	return r
}
// If not null, include internal attributes that start with this prefix
func (r ApiGetByUniqueAttributesRequest) IncludeInternalPrefix(includeInternalPrefix string) ApiGetByUniqueAttributesRequest {
	r.includeInternalPrefix = &includeInternalPrefix
	return r
}

func (r ApiGetByUniqueAttributesRequest) Execute() (AtlasEntityWithExtInfo, *_nethttp.Response, error) {
	return r.ApiService.GetByUniqueAttributesExecute(r)
}

/*
GetByUniqueAttributes Fetch complete definition of an entity given its type and unique attribute.

Fetch complete definition of an entity given its type and unique attribute.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param typeName The type of the entity
 @param qualifiedName The qualified name of the entity
 @return ApiGetByUniqueAttributesRequest
*/
func (a *DefaultApiService) GetByUniqueAttributes(ctx _context.Context, typeName string, qualifiedName string) ApiGetByUniqueAttributesRequest {
	return ApiGetByUniqueAttributesRequest{
		ApiService: a,
		ctx: ctx,
		typeName: typeName,
		qualifiedName: qualifiedName,
	}
}

// Execute executes the request
//  @return AtlasEntityWithExtInfo
func (a *DefaultApiService) GetByUniqueAttributesExecute(r ApiGetByUniqueAttributesRequest) (AtlasEntityWithExtInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AtlasEntityWithExtInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetByUniqueAttributes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/entity/type/{typeName}/name/{qualifiedName}"
	localVarPath = strings.Replace(localVarPath, "{"+"typeName"+"}", _neturl.PathEscape(parameterToString(r.typeName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"qualifiedName"+"}", _neturl.PathEscape(parameterToString(r.qualifiedName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.minExtInfo != nil {
		localVarQueryParams.Add("minExtInfo", parameterToString(*r.minExtInfo, ""))
	}
	if r.ignoreRelationships != nil {
		localVarQueryParams.Add("ignoreRelationships", parameterToString(*r.ignoreRelationships, ""))
	}
	if r.includeInternalPrefix != nil {
		localVarQueryParams.Add("includeInternalPrefix", parameterToString(*r.includeInternalPrefix, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClusterIdRequest struct {
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiGetClusterIdRequest) Execute() (ServerClusterId, *_nethttp.Response, error) {
	return r.ApiService.GetClusterIdExecute(r)
}

/*
GetClusterId Get the server metadata

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetClusterIdRequest
*/
func (a *DefaultApiService) GetClusterId(ctx _context.Context) ApiGetClusterIdRequest {
	return ApiGetClusterIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServerClusterId
func (a *DefaultApiService) GetClusterIdExecute(r ApiGetClusterIdRequest) (ServerClusterId, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ServerClusterId
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetClusterId")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metadata/id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDekRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
	subject string
	algorithm *string
	deleted *bool
}

// Algorithm of the dek
func (r ApiGetDekRequest) Algorithm(algorithm string) ApiGetDekRequest {
	r.algorithm = &algorithm
	return r
}
// Whether to include deleted keys
func (r ApiGetDekRequest) Deleted(deleted bool) ApiGetDekRequest {
	r.deleted = &deleted
	return r
}

func (r ApiGetDekRequest) Execute() (Dek, *_nethttp.Response, error) {
	return r.ApiService.GetDekExecute(r)
}

/*
GetDek Get a dek by subject.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the kek
 @param subject Subject of the dek
 @return ApiGetDekRequest
*/
func (a *DefaultApiService) GetDek(ctx _context.Context, name string, subject string) ApiGetDekRequest {
	return ApiGetDekRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		subject: subject,
	}
}

// Execute executes the request
//  @return Dek
func (a *DefaultApiService) GetDekExecute(r ApiGetDekRequest) (Dek, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Dek
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetDek")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dek-registry/v1/keks/{name}/deks/{subject}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.algorithm != nil {
		localVarQueryParams.Add("algorithm", parameterToString(*r.algorithm, ""))
	}
	if r.deleted != nil {
		localVarQueryParams.Add("deleted", parameterToString(*r.deleted, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDekByVersionRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
	subject string
	version string
	algorithm *string
	deleted *bool
}

// Algorithm of the dek
func (r ApiGetDekByVersionRequest) Algorithm(algorithm string) ApiGetDekByVersionRequest {
	r.algorithm = &algorithm
	return r
}
// Whether to include deleted keys
func (r ApiGetDekByVersionRequest) Deleted(deleted bool) ApiGetDekByVersionRequest {
	r.deleted = &deleted
	return r
}

func (r ApiGetDekByVersionRequest) Execute() (Dek, *_nethttp.Response, error) {
	return r.ApiService.GetDekByVersionExecute(r)
}

/*
GetDekByVersion Get a dek by subject and version.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the kek
 @param subject Subject of the dek
 @param version Version of the dek
 @return ApiGetDekByVersionRequest
*/
func (a *DefaultApiService) GetDekByVersion(ctx _context.Context, name string, subject string, version string) ApiGetDekByVersionRequest {
	return ApiGetDekByVersionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		subject: subject,
		version: version,
	}
}

// Execute executes the request
//  @return Dek
func (a *DefaultApiService) GetDekByVersionExecute(r ApiGetDekByVersionRequest) (Dek, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Dek
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetDekByVersion")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dek-registry/v1/keks/{name}/deks/{subject}/versions/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.algorithm != nil {
		localVarQueryParams.Add("algorithm", parameterToString(*r.algorithm, ""))
	}
	if r.deleted != nil {
		localVarQueryParams.Add("deleted", parameterToString(*r.deleted, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDekSubjectsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
	deleted *bool
}

// Whether to include deleted keys
func (r ApiGetDekSubjectsRequest) Deleted(deleted bool) ApiGetDekSubjectsRequest {
	r.deleted = &deleted
	return r
}

func (r ApiGetDekSubjectsRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.GetDekSubjectsExecute(r)
}

/*
GetDekSubjects Get a list of dek subjects.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the kek
 @return ApiGetDekSubjectsRequest
*/
func (a *DefaultApiService) GetDekSubjects(ctx _context.Context, name string) ApiGetDekSubjectsRequest {
	return ApiGetDekSubjectsRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return []string
func (a *DefaultApiService) GetDekSubjectsExecute(r ApiGetDekSubjectsRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetDekSubjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dek-registry/v1/keks/{name}/deks"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.deleted != nil {
		localVarQueryParams.Add("deleted", parameterToString(*r.deleted, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDekVersionsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
	subject string
	algorithm *string
	deleted *bool
}

// Algorithm of the dek
func (r ApiGetDekVersionsRequest) Algorithm(algorithm string) ApiGetDekVersionsRequest {
	r.algorithm = &algorithm
	return r
}
// Whether to include deleted keys
func (r ApiGetDekVersionsRequest) Deleted(deleted bool) ApiGetDekVersionsRequest {
	r.deleted = &deleted
	return r
}

func (r ApiGetDekVersionsRequest) Execute() ([]int32, *_nethttp.Response, error) {
	return r.ApiService.GetDekVersionsExecute(r)
}

/*
GetDekVersions List versions of dek.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the kek
 @param subject Subject of the dek
 @return ApiGetDekVersionsRequest
*/
func (a *DefaultApiService) GetDekVersions(ctx _context.Context, name string, subject string) ApiGetDekVersionsRequest {
	return ApiGetDekVersionsRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		subject: subject,
	}
}

// Execute executes the request
//  @return []int32
func (a *DefaultApiService) GetDekVersionsExecute(r ApiGetDekVersionsRequest) ([]int32, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetDekVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dek-registry/v1/keks/{name}/deks/{subject}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.algorithm != nil {
		localVarQueryParams.Add("algorithm", parameterToString(*r.algorithm, ""))
	}
	if r.deleted != nil {
		localVarQueryParams.Add("deleted", parameterToString(*r.deleted, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExporterConfigRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
}


func (r ApiGetExporterConfigRequest) Execute() (map[string]string, *_nethttp.Response, error) {
	return r.ApiService.GetExporterConfigExecute(r)
}

/*
GetExporterConfig Get the config for an exporter.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiGetExporterConfigRequest
*/
func (a *DefaultApiService) GetExporterConfig(ctx _context.Context, name string) ApiGetExporterConfigRequest {
	return ApiGetExporterConfigRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return map[string]string
func (a *DefaultApiService) GetExporterConfigExecute(r ApiGetExporterConfigRequest) (map[string]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetExporterConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exporters/{name}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExporterInfoRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
}


func (r ApiGetExporterInfoRequest) Execute() (ExporterInfo, *_nethttp.Response, error) {
	return r.ApiService.GetExporterInfoExecute(r)
}

/*
GetExporterInfo Get the info for an exporter.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiGetExporterInfoRequest
*/
func (a *DefaultApiService) GetExporterInfo(ctx _context.Context, name string) ApiGetExporterInfoRequest {
	return ApiGetExporterInfoRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ExporterInfo
func (a *DefaultApiService) GetExporterInfoExecute(r ApiGetExporterInfoRequest) (ExporterInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ExporterInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetExporterInfo")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exporters/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExporterStatusRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
}


func (r ApiGetExporterStatusRequest) Execute() (ExporterStatus, *_nethttp.Response, error) {
	return r.ApiService.GetExporterStatusExecute(r)
}

/*
GetExporterStatus Get the status for an exporter.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiGetExporterStatusRequest
*/
func (a *DefaultApiService) GetExporterStatus(ctx _context.Context, name string) ApiGetExporterStatusRequest {
	return ApiGetExporterStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ExporterStatus
func (a *DefaultApiService) GetExporterStatusExecute(r ApiGetExporterStatusRequest) (ExporterStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ExporterStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetExporterStatus")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exporters/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExportersRequest struct {
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiGetExportersRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.GetExportersExecute(r)
}

/*
GetExporters Get a list of exporter names.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetExportersRequest
*/
func (a *DefaultApiService) GetExporters(ctx _context.Context) ApiGetExportersRequest {
	return ApiGetExportersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []string
func (a *DefaultApiService) GetExportersExecute(r ApiGetExportersRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetExporters")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exporters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetKekRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
	deleted *bool
}

// Whether to include deleted keys
func (r ApiGetKekRequest) Deleted(deleted bool) ApiGetKekRequest {
	r.deleted = &deleted
	return r
}

func (r ApiGetKekRequest) Execute() (Kek, *_nethttp.Response, error) {
	return r.ApiService.GetKekExecute(r)
}

/*
GetKek Get a kek by name.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the kek
 @return ApiGetKekRequest
*/
func (a *DefaultApiService) GetKek(ctx _context.Context, name string) ApiGetKekRequest {
	return ApiGetKekRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return Kek
func (a *DefaultApiService) GetKekExecute(r ApiGetKekRequest) (Kek, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Kek
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetKek")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dek-registry/v1/keks/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.deleted != nil {
		localVarQueryParams.Add("deleted", parameterToString(*r.deleted, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetKekNamesRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	deleted *bool
}

// Whether to include deleted keys
func (r ApiGetKekNamesRequest) Deleted(deleted bool) ApiGetKekNamesRequest {
	r.deleted = &deleted
	return r
}

func (r ApiGetKekNamesRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.GetKekNamesExecute(r)
}

/*
GetKekNames Get a list of kek names.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetKekNamesRequest
*/
func (a *DefaultApiService) GetKekNames(ctx _context.Context) ApiGetKekNamesRequest {
	return ApiGetKekNamesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []string
func (a *DefaultApiService) GetKekNamesExecute(r ApiGetKekNamesRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetKekNames")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dek-registry/v1/keks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.deleted != nil {
		localVarQueryParams.Add("deleted", parameterToString(*r.deleted, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetModeRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subject string
	defaultToGlobal *bool
}

func (r ApiGetModeRequest) DefaultToGlobal(defaultToGlobal bool) ApiGetModeRequest {
	r.defaultToGlobal = &defaultToGlobal
	return r
}

func (r ApiGetModeRequest) Execute() (Mode, *_nethttp.Response, error) {
	return r.ApiService.GetModeExecute(r)
}

/*
GetMode Get mode for a subject.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subject Name of the Subject
 @return ApiGetModeRequest
*/
func (a *DefaultApiService) GetMode(ctx _context.Context, subject string) ApiGetModeRequest {
	return ApiGetModeRequest{
		ApiService: a,
		ctx: ctx,
		subject: subject,
	}
}

// Execute executes the request
//  @return Mode
func (a *DefaultApiService) GetModeExecute(r ApiGetModeRequest) (Mode, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Mode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetMode")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mode/{subject}"
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.defaultToGlobal != nil {
		localVarQueryParams.Add("defaultToGlobal", parameterToString(*r.defaultToGlobal, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReferencedByRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subject string
	version string
}


func (r ApiGetReferencedByRequest) Execute() ([]int32, *_nethttp.Response, error) {
	return r.ApiService.GetReferencedByExecute(r)
}

/*
GetReferencedBy Get the schemas that reference the specified schema.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subject Name of the Subject
 @param version Version of the schema to be returned. Valid values for versionId are between [1,2^31-1] or the string \"latest\". \"latest\" returns the last registered schema under the specified subject. Note that there may be a new latest schema that gets registered right after this request is served.
 @return ApiGetReferencedByRequest
*/
func (a *DefaultApiService) GetReferencedBy(ctx _context.Context, subject string, version string) ApiGetReferencedByRequest {
	return ApiGetReferencedByRequest{
		ApiService: a,
		ctx: ctx,
		subject: subject,
		version: version,
	}
}

// Execute executes the request
//  @return []int32
func (a *DefaultApiService) GetReferencedByExecute(r ApiGetReferencedByRequest) ([]int32, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetReferencedBy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subjects/{subject}/versions/{version}/referencedby"
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSchemaRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id int32
	subject *string
	format *string
	fetchMaxId *bool
}

func (r ApiGetSchemaRequest) Subject(subject string) ApiGetSchemaRequest {
	r.subject = &subject
	return r
}
func (r ApiGetSchemaRequest) Format(format string) ApiGetSchemaRequest {
	r.format = &format
	return r
}
func (r ApiGetSchemaRequest) FetchMaxId(fetchMaxId bool) ApiGetSchemaRequest {
	r.fetchMaxId = &fetchMaxId
	return r
}

func (r ApiGetSchemaRequest) Execute() (SchemaString, *_nethttp.Response, error) {
	return r.ApiService.GetSchemaExecute(r)
}

/*
GetSchema Get the schema string identified by the input ID.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Globally unique identifier of the schema
 @return ApiGetSchemaRequest
*/
func (a *DefaultApiService) GetSchema(ctx _context.Context, id int32) ApiGetSchemaRequest {
	return ApiGetSchemaRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SchemaString
func (a *DefaultApiService) GetSchemaExecute(r ApiGetSchemaRequest) (SchemaString, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SchemaString
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSchema")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/schemas/ids/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.subject != nil {
		localVarQueryParams.Add("subject", parameterToString(*r.subject, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.fetchMaxId != nil {
		localVarQueryParams.Add("fetchMaxId", parameterToString(*r.fetchMaxId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSchemaByVersionRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subject string
	version string
	deleted *bool
}

func (r ApiGetSchemaByVersionRequest) Deleted(deleted bool) ApiGetSchemaByVersionRequest {
	r.deleted = &deleted
	return r
}

func (r ApiGetSchemaByVersionRequest) Execute() (Schema, *_nethttp.Response, error) {
	return r.ApiService.GetSchemaByVersionExecute(r)
}

/*
GetSchemaByVersion Get a specific version of the schema registered under this subject.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subject Name of the Subject
 @param version Version of the schema to be returned. Valid values for versionId are between [1,2^31-1] or the string \"latest\". \"latest\" returns the last registered schema under the specified subject. Note that there may be a new latest schema that gets registered right after this request is served.
 @return ApiGetSchemaByVersionRequest
*/
func (a *DefaultApiService) GetSchemaByVersion(ctx _context.Context, subject string, version string) ApiGetSchemaByVersionRequest {
	return ApiGetSchemaByVersionRequest{
		ApiService: a,
		ctx: ctx,
		subject: subject,
		version: version,
	}
}

// Execute executes the request
//  @return Schema
func (a *DefaultApiService) GetSchemaByVersionExecute(r ApiGetSchemaByVersionRequest) (Schema, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Schema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSchemaByVersion")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subjects/{subject}/versions/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.deleted != nil {
		localVarQueryParams.Add("deleted", parameterToString(*r.deleted, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSchemaOnlyRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subject string
	version string
	deleted *bool
}

func (r ApiGetSchemaOnlyRequest) Deleted(deleted bool) ApiGetSchemaOnlyRequest {
	r.deleted = &deleted
	return r
}

func (r ApiGetSchemaOnlyRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.GetSchemaOnlyExecute(r)
}

/*
GetSchemaOnly Get the schema for the specified version of this subject. The unescaped schema only is returned.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subject Name of the Subject
 @param version Version of the schema to be returned. Valid values for versionId are between [1,2^31-1] or the string \"latest\". \"latest\" returns the last registered schema under the specified subject. Note that there may be a new latest schema that gets registered right after this request is served.
 @return ApiGetSchemaOnlyRequest
*/
func (a *DefaultApiService) GetSchemaOnly(ctx _context.Context, subject string, version string) ApiGetSchemaOnlyRequest {
	return ApiGetSchemaOnlyRequest{
		ApiService: a,
		ctx: ctx,
		subject: subject,
		version: version,
	}
}

// Execute executes the request
//  @return string
func (a *DefaultApiService) GetSchemaOnlyExecute(r ApiGetSchemaOnlyRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSchemaOnly")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subjects/{subject}/versions/{version}/schema"
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.deleted != nil {
		localVarQueryParams.Add("deleted", parameterToString(*r.deleted, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSchemaTypesRequest struct {
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiGetSchemaTypesRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.GetSchemaTypesExecute(r)
}

/*
GetSchemaTypes Get the schema types supported by this registry.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSchemaTypesRequest
*/
func (a *DefaultApiService) GetSchemaTypes(ctx _context.Context) ApiGetSchemaTypesRequest {
	return ApiGetSchemaTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []string
func (a *DefaultApiService) GetSchemaTypesExecute(r ApiGetSchemaTypesRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSchemaTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/schemas/types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSchemasRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subjectPrefix *string
	deleted *bool
	latestOnly *bool
	offset *int32
	limit *int32
}

func (r ApiGetSchemasRequest) SubjectPrefix(subjectPrefix string) ApiGetSchemasRequest {
	r.subjectPrefix = &subjectPrefix
	return r
}
func (r ApiGetSchemasRequest) Deleted(deleted bool) ApiGetSchemasRequest {
	r.deleted = &deleted
	return r
}
func (r ApiGetSchemasRequest) LatestOnly(latestOnly bool) ApiGetSchemasRequest {
	r.latestOnly = &latestOnly
	return r
}
func (r ApiGetSchemasRequest) Offset(offset int32) ApiGetSchemasRequest {
	r.offset = &offset
	return r
}
func (r ApiGetSchemasRequest) Limit(limit int32) ApiGetSchemasRequest {
	r.limit = &limit
	return r
}

func (r ApiGetSchemasRequest) Execute() ([]Schema, *_nethttp.Response, error) {
	return r.ApiService.GetSchemasExecute(r)
}

/*
GetSchemas Get the schemas.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSchemasRequest
*/
func (a *DefaultApiService) GetSchemas(ctx _context.Context) ApiGetSchemasRequest {
	return ApiGetSchemasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Schema
func (a *DefaultApiService) GetSchemasExecute(r ApiGetSchemasRequest) ([]Schema, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Schema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSchemas")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/schemas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.subjectPrefix != nil {
		localVarQueryParams.Add("subjectPrefix", parameterToString(*r.subjectPrefix, ""))
	}
	if r.deleted != nil {
		localVarQueryParams.Add("deleted", parameterToString(*r.deleted, ""))
	}
	if r.latestOnly != nil {
		localVarQueryParams.Add("latestOnly", parameterToString(*r.latestOnly, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubjectLevelConfigRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subject string
	defaultToGlobal *bool
}

func (r ApiGetSubjectLevelConfigRequest) DefaultToGlobal(defaultToGlobal bool) ApiGetSubjectLevelConfigRequest {
	r.defaultToGlobal = &defaultToGlobal
	return r
}

func (r ApiGetSubjectLevelConfigRequest) Execute() (Config, *_nethttp.Response, error) {
	return r.ApiService.GetSubjectLevelConfigExecute(r)
}

/*
GetSubjectLevelConfig Get compatibility level for a subject.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subject
 @return ApiGetSubjectLevelConfigRequest
*/
func (a *DefaultApiService) GetSubjectLevelConfig(ctx _context.Context, subject string) ApiGetSubjectLevelConfigRequest {
	return ApiGetSubjectLevelConfigRequest{
		ApiService: a,
		ctx: ctx,
		subject: subject,
	}
}

// Execute executes the request
//  @return Config
func (a *DefaultApiService) GetSubjectLevelConfigExecute(r ApiGetSubjectLevelConfigRequest) (Config, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Config
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSubjectLevelConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/{subject}"
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.defaultToGlobal != nil {
		localVarQueryParams.Add("defaultToGlobal", parameterToString(*r.defaultToGlobal, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubjectsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id int32
	subject *string
	deleted *bool
}

func (r ApiGetSubjectsRequest) Subject(subject string) ApiGetSubjectsRequest {
	r.subject = &subject
	return r
}
func (r ApiGetSubjectsRequest) Deleted(deleted bool) ApiGetSubjectsRequest {
	r.deleted = &deleted
	return r
}

func (r ApiGetSubjectsRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.GetSubjectsExecute(r)
}

/*
GetSubjects Get all the subjects associated with the input ID.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Globally unique identifier of the schema
 @return ApiGetSubjectsRequest
*/
func (a *DefaultApiService) GetSubjects(ctx _context.Context, id int32) ApiGetSubjectsRequest {
	return ApiGetSubjectsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []string
func (a *DefaultApiService) GetSubjectsExecute(r ApiGetSubjectsRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSubjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/schemas/ids/{id}/subjects"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.subject != nil {
		localVarQueryParams.Add("subject", parameterToString(*r.subject, ""))
	}
	if r.deleted != nil {
		localVarQueryParams.Add("deleted", parameterToString(*r.deleted, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTagDefByNameRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	tagName string
}


func (r ApiGetTagDefByNameRequest) Execute() (TagDef, *_nethttp.Response, error) {
	return r.ApiService.GetTagDefByNameExecute(r)
}

/*
GetTagDefByName Get the tag definition with the given name.

Get the tag definition with the given name.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tagName The name of the tag definiton
 @return ApiGetTagDefByNameRequest
*/
func (a *DefaultApiService) GetTagDefByName(ctx _context.Context, tagName string) ApiGetTagDefByNameRequest {
	return ApiGetTagDefByNameRequest{
		ApiService: a,
		ctx: ctx,
		tagName: tagName,
	}
}

// Execute executes the request
//  @return TagDef
func (a *DefaultApiService) GetTagDefByNameExecute(r ApiGetTagDefByNameRequest) (TagDef, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TagDef
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTagDefByName")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/types/tagdefs/{tagName}"
	localVarPath = strings.Replace(localVarPath, "{"+"tagName"+"}", _neturl.PathEscape(parameterToString(r.tagName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTagsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	typeName string
	qualifiedName string
}


func (r ApiGetTagsRequest) Execute() ([]TagResponse, *_nethttp.Response, error) {
	return r.ApiService.GetTagsExecute(r)
}

/*
GetTags Gets the list of classifications for a given entity represented by a qualifed name.

Gets the list of classifications for a given entity represented by a qualifed name.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param typeName The type of the entity
 @param qualifiedName The qualified name of the entity
 @return ApiGetTagsRequest
*/
func (a *DefaultApiService) GetTags(ctx _context.Context, typeName string, qualifiedName string) ApiGetTagsRequest {
	return ApiGetTagsRequest{
		ApiService: a,
		ctx: ctx,
		typeName: typeName,
		qualifiedName: qualifiedName,
	}
}

// Execute executes the request
//  @return []TagResponse
func (a *DefaultApiService) GetTagsExecute(r ApiGetTagsRequest) ([]TagResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []TagResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTags")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/entity/type/{typeName}/name/{qualifiedName}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"typeName"+"}", _neturl.PathEscape(parameterToString(r.typeName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"qualifiedName"+"}", _neturl.PathEscape(parameterToString(r.qualifiedName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTopLevelConfigRequest struct {
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiGetTopLevelConfigRequest) Execute() (Config, *_nethttp.Response, error) {
	return r.ApiService.GetTopLevelConfigExecute(r)
}

/*
GetTopLevelConfig Get global compatibility level

Retrieves the global compatibility level.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTopLevelConfigRequest
*/
func (a *DefaultApiService) GetTopLevelConfig(ctx _context.Context) ApiGetTopLevelConfigRequest {
	return ApiGetTopLevelConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Config
func (a *DefaultApiService) GetTopLevelConfigExecute(r ApiGetTopLevelConfigRequest) (Config, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Config
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTopLevelConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTopLevelModeRequest struct {
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiGetTopLevelModeRequest) Execute() (Mode, *_nethttp.Response, error) {
	return r.ApiService.GetTopLevelModeExecute(r)
}

/*
GetTopLevelMode Get global mode.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTopLevelModeRequest
*/
func (a *DefaultApiService) GetTopLevelMode(ctx _context.Context) ApiGetTopLevelModeRequest {
	return ApiGetTopLevelModeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Mode
func (a *DefaultApiService) GetTopLevelModeExecute(r ApiGetTopLevelModeRequest) (Mode, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Mode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTopLevelMode")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVersionsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	id int32
	subject *string
	deleted *bool
}

func (r ApiGetVersionsRequest) Subject(subject string) ApiGetVersionsRequest {
	r.subject = &subject
	return r
}
func (r ApiGetVersionsRequest) Deleted(deleted bool) ApiGetVersionsRequest {
	r.deleted = &deleted
	return r
}

func (r ApiGetVersionsRequest) Execute() ([]SubjectVersion, *_nethttp.Response, error) {
	return r.ApiService.GetVersionsExecute(r)
}

/*
GetVersions Get all the subject-version pairs associated with the input ID.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Globally unique identifier of the schema
 @return ApiGetVersionsRequest
*/
func (a *DefaultApiService) GetVersions(ctx _context.Context, id int32) ApiGetVersionsRequest {
	return ApiGetVersionsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []SubjectVersion
func (a *DefaultApiService) GetVersionsExecute(r ApiGetVersionsRequest) ([]SubjectVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []SubjectVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/schemas/ids/{id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.subject != nil {
		localVarQueryParams.Add("subject", parameterToString(*r.subject, ""))
	}
	if r.deleted != nil {
		localVarQueryParams.Add("deleted", parameterToString(*r.deleted, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subjectPrefix *string
	deleted *bool
	deletedOnly *bool
}

func (r ApiListRequest) SubjectPrefix(subjectPrefix string) ApiListRequest {
	r.subjectPrefix = &subjectPrefix
	return r
}
func (r ApiListRequest) Deleted(deleted bool) ApiListRequest {
	r.deleted = &deleted
	return r
}
// Whether to return deleted subjects only
func (r ApiListRequest) DeletedOnly(deletedOnly bool) ApiListRequest {
	r.deletedOnly = &deletedOnly
	return r
}

func (r ApiListRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.ListExecute(r)
}

/*
List Get a list of registered subjects.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListRequest
*/
func (a *DefaultApiService) List(ctx _context.Context) ApiListRequest {
	return ApiListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []string
func (a *DefaultApiService) ListExecute(r ApiListRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.List")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subjects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.subjectPrefix != nil {
		localVarQueryParams.Add("subjectPrefix", parameterToString(*r.subjectPrefix, ""))
	}
	if r.deleted != nil {
		localVarQueryParams.Add("deleted", parameterToString(*r.deleted, ""))
	}
	if r.deletedOnly != nil {
		localVarQueryParams.Add("deletedOnly", parameterToString(*r.deletedOnly, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListContextsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiListContextsRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.ListContextsExecute(r)
}

/*
ListContexts Get a list of contexts.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListContextsRequest
*/
func (a *DefaultApiService) ListContexts(ctx _context.Context) ApiListContextsRequest {
	return ApiListContextsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []string
func (a *DefaultApiService) ListContextsExecute(r ApiListContextsRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListContexts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contexts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVersionsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subject string
	deleted *bool
	deletedOnly *bool
}

func (r ApiListVersionsRequest) Deleted(deleted bool) ApiListVersionsRequest {
	r.deleted = &deleted
	return r
}
// Whether to return deleted schemas only
func (r ApiListVersionsRequest) DeletedOnly(deletedOnly bool) ApiListVersionsRequest {
	r.deletedOnly = &deletedOnly
	return r
}

func (r ApiListVersionsRequest) Execute() ([]int32, *_nethttp.Response, error) {
	return r.ApiService.ListVersionsExecute(r)
}

/*
ListVersions Get a list of versions registered under the specified subject.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subject Name of the Subject
 @return ApiListVersionsRequest
*/
func (a *DefaultApiService) ListVersions(ctx _context.Context, subject string) ApiListVersionsRequest {
	return ApiListVersionsRequest{
		ApiService: a,
		ctx: ctx,
		subject: subject,
	}
}

// Execute executes the request
//  @return []int32
func (a *DefaultApiService) ListVersionsExecute(r ApiListVersionsRequest) ([]int32, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subjects/{subject}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.deleted != nil {
		localVarQueryParams.Add("deleted", parameterToString(*r.deleted, ""))
	}
	if r.deletedOnly != nil {
		localVarQueryParams.Add("deletedOnly", parameterToString(*r.deletedOnly, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLookUpSchemaUnderSubjectRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subject string
	body *RegisterSchemaRequest
	deleted *bool
}

// Schema
func (r ApiLookUpSchemaUnderSubjectRequest) Body(body RegisterSchemaRequest) ApiLookUpSchemaUnderSubjectRequest {
	r.body = &body
	return r
}
func (r ApiLookUpSchemaUnderSubjectRequest) Deleted(deleted bool) ApiLookUpSchemaUnderSubjectRequest {
	r.deleted = &deleted
	return r
}

func (r ApiLookUpSchemaUnderSubjectRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.LookUpSchemaUnderSubjectExecute(r)
}

/*
LookUpSchemaUnderSubject Check if a schema has already been registered under the specified subject. If so, this returns the schema string along with its globally unique identifier, its version under this subject and the subject name.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subject Subject under which the schema will be registered
 @return ApiLookUpSchemaUnderSubjectRequest
*/
func (a *DefaultApiService) LookUpSchemaUnderSubject(ctx _context.Context, subject string) ApiLookUpSchemaUnderSubjectRequest {
	return ApiLookUpSchemaUnderSubjectRequest{
		ApiService: a,
		ctx: ctx,
		subject: subject,
	}
}

// Execute executes the request
func (a *DefaultApiService) LookUpSchemaUnderSubjectExecute(r ApiLookUpSchemaUnderSubjectRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.LookUpSchemaUnderSubject")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subjects/{subject}"
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.deleted != nil {
		localVarQueryParams.Add("deleted", parameterToString(*r.deleted, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json", "application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Schema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPartialUpdateByUniqueAttributesRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	atlasEntityWithExtInfo *AtlasEntityWithExtInfo
}

func (r ApiPartialUpdateByUniqueAttributesRequest) AtlasEntityWithExtInfo(atlasEntityWithExtInfo AtlasEntityWithExtInfo) ApiPartialUpdateByUniqueAttributesRequest {
	r.atlasEntityWithExtInfo = &atlasEntityWithExtInfo
	return r
}

func (r ApiPartialUpdateByUniqueAttributesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PartialUpdateByUniqueAttributesExecute(r)
}

/*
PartialUpdateByUniqueAttributes Method for PartialUpdateByUniqueAttributes

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPartialUpdateByUniqueAttributesRequest
*/
func (a *DefaultApiService) PartialUpdateByUniqueAttributes(ctx _context.Context) ApiPartialUpdateByUniqueAttributesRequest {
	return ApiPartialUpdateByUniqueAttributesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) PartialUpdateByUniqueAttributesExecute(r ApiPartialUpdateByUniqueAttributesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PartialUpdateByUniqueAttributes")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/entity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.atlasEntityWithExtInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPauseExporterRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
}


func (r ApiPauseExporterRequest) Execute() (UpdateExporterResponse, *_nethttp.Response, error) {
	return r.ApiService.PauseExporterExecute(r)
}

/*
PauseExporter Pause an exporter.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the exporter
 @return ApiPauseExporterRequest
*/
func (a *DefaultApiService) PauseExporter(ctx _context.Context, name string) ApiPauseExporterRequest {
	return ApiPauseExporterRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return UpdateExporterResponse
func (a *DefaultApiService) PauseExporterExecute(r ApiPauseExporterRequest) (UpdateExporterResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UpdateExporterResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PauseExporter")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exporters/{name}/pause"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRequest struct {
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiPostRequest) Execute() (map[string]string, *_nethttp.Response, error) {
	return r.ApiService.PostExecute(r)
}

/*
Post Method for Post

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostRequest
*/
func (a *DefaultApiService) Post(ctx _context.Context) ApiPostRequest {
	return ApiPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]string
func (a *DefaultApiService) PostExecute(r ApiPostRequest) (map[string]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Post")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutExporterRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
	body *UpdateExporterRequest
}

// Info
func (r ApiPutExporterRequest) Body(body UpdateExporterRequest) ApiPutExporterRequest {
	r.body = &body
	return r
}

func (r ApiPutExporterRequest) Execute() (UpdateExporterResponse, *_nethttp.Response, error) {
	return r.ApiService.PutExporterExecute(r)
}

/*
PutExporter Alters an exporter.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the exporter
 @return ApiPutExporterRequest
*/
func (a *DefaultApiService) PutExporter(ctx _context.Context, name string) ApiPutExporterRequest {
	return ApiPutExporterRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return UpdateExporterResponse
func (a *DefaultApiService) PutExporterExecute(r ApiPutExporterRequest) (UpdateExporterResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UpdateExporterResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PutExporter")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exporters/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json", "application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutExporterConfigRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
	body *map[string]string
}

// Config
func (r ApiPutExporterConfigRequest) Body(body map[string]string) ApiPutExporterConfigRequest {
	r.body = &body
	return r
}

func (r ApiPutExporterConfigRequest) Execute() (UpdateExporterResponse, *_nethttp.Response, error) {
	return r.ApiService.PutExporterConfigExecute(r)
}

/*
PutExporterConfig Alters the config of an exporter.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the exporter
 @return ApiPutExporterConfigRequest
*/
func (a *DefaultApiService) PutExporterConfig(ctx _context.Context, name string) ApiPutExporterConfigRequest {
	return ApiPutExporterConfigRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return UpdateExporterResponse
func (a *DefaultApiService) PutExporterConfigExecute(r ApiPutExporterConfigRequest) (UpdateExporterResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UpdateExporterResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PutExporterConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exporters/{name}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json", "application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutKekRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
	updateKekRequest *UpdateKekRequest
}

// The update request
func (r ApiPutKekRequest) UpdateKekRequest(updateKekRequest UpdateKekRequest) ApiPutKekRequest {
	r.updateKekRequest = &updateKekRequest
	return r
}

func (r ApiPutKekRequest) Execute() (Kek, *_nethttp.Response, error) {
	return r.ApiService.PutKekExecute(r)
}

/*
PutKek Alters a kek.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the kek
 @return ApiPutKekRequest
*/
func (a *DefaultApiService) PutKek(ctx _context.Context, name string) ApiPutKekRequest {
	return ApiPutKekRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return Kek
func (a *DefaultApiService) PutKekExecute(r ApiPutKekRequest) (Kek, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Kek
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PutKek")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dek-registry/v1/keks/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.updateKekRequest == nil {
		return localVarReturnValue, nil, reportError("updateKekRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json", "application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateKekRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegisterRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subject string
	body *RegisterSchemaRequest
	normalize *bool
}

// Schema
func (r ApiRegisterRequest) Body(body RegisterSchemaRequest) ApiRegisterRequest {
	r.body = &body
	return r
}
// Whether to register the normalized schema
func (r ApiRegisterRequest) Normalize(normalize bool) ApiRegisterRequest {
	r.normalize = &normalize
	return r
}

func (r ApiRegisterRequest) Execute() (RegisterSchemaResponse, *_nethttp.Response, error) {
	return r.ApiService.RegisterExecute(r)
}

/*
Register Register schema under a subject

Register a new schema under the specified subject. If successfully registered, this returns the unique identifier of this schema in the registry. The returned identifier should be used to retrieve this schema from the schemas resource and is different from the schema's version which is associated with the subject. If the same schema is registered under a different subject, the same identifier will be returned. However, the version of the schema may be different under different subjects.
A schema should be compatible with the previously registered schema or schemas (if there are any) as per the configured compatibility level. The configured compatibility level can be obtained by issuing a GET http:get:: /config/(string: subject). If that returns null, then GET http:get:: /config
When there are multiple instances of Schema Registry running in the same cluster, the schema registration request will be forwarded to one of the instances designated as the primary. If the primary is not available, the client will get an error code indicating that the forwarding has failed.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subject Name of the subject
 @return ApiRegisterRequest
*/
func (a *DefaultApiService) Register(ctx _context.Context, subject string) ApiRegisterRequest {
	return ApiRegisterRequest{
		ApiService: a,
		ctx: ctx,
		subject: subject,
	}
}

// Execute executes the request
//  @return RegisterSchemaResponse
func (a *DefaultApiService) RegisterExecute(r ApiRegisterRequest) (RegisterSchemaResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RegisterSchemaResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Register")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subjects/{subject}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.normalize != nil {
		localVarQueryParams.Add("normalize", parameterToString(*r.normalize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json", "application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetExporterRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
}


func (r ApiResetExporterRequest) Execute() (UpdateExporterResponse, *_nethttp.Response, error) {
	return r.ApiService.ResetExporterExecute(r)
}

/*
ResetExporter Reset an exporter.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the exporter
 @return ApiResetExporterRequest
*/
func (a *DefaultApiService) ResetExporter(ctx _context.Context, name string) ApiResetExporterRequest {
	return ApiResetExporterRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return UpdateExporterResponse
func (a *DefaultApiService) ResetExporterExecute(r ApiResetExporterRequest) (UpdateExporterResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UpdateExporterResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ResetExporter")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exporters/{name}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResumeExporterRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
}


func (r ApiResumeExporterRequest) Execute() (UpdateExporterResponse, *_nethttp.Response, error) {
	return r.ApiService.ResumeExporterExecute(r)
}

/*
ResumeExporter Resume an exporter.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the exporter
 @return ApiResumeExporterRequest
*/
func (a *DefaultApiService) ResumeExporter(ctx _context.Context, name string) ApiResumeExporterRequest {
	return ApiResumeExporterRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return UpdateExporterResponse
func (a *DefaultApiService) ResumeExporterExecute(r ApiResumeExporterRequest) (UpdateExporterResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UpdateExporterResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ResumeExporter")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exporters/{name}/resume"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchUsingAttributeRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	type_ *[]string
	types *string
	attr *[]string
	attrs *string
	attrName *[]string
	attrValuePrefix *[]string
	tag *[]string
	timeRangeType *string
	timeRangeAttr *string
	timeRangeStart *int64
	timeRangeEnd *int64
	sortBy *string
	sortOrder *string
	deleted *bool
	limit *int32
	offset *int32
}

// Limit the result to only entities of specified types
func (r ApiSearchUsingAttributeRequest) Type_(type_ []string) ApiSearchUsingAttributeRequest {
	r.type_ = &type_
	return r
}
func (r ApiSearchUsingAttributeRequest) Types(types string) ApiSearchUsingAttributeRequest {
	r.types = &types
	return r
}
// One of more additional attributes to return in the response
func (r ApiSearchUsingAttributeRequest) Attr(attr []string) ApiSearchUsingAttributeRequest {
	r.attr = &attr
	return r
}
func (r ApiSearchUsingAttributeRequest) Attrs(attrs string) ApiSearchUsingAttributeRequest {
	r.attrs = &attrs
	return r
}
// The attribute to search
func (r ApiSearchUsingAttributeRequest) AttrName(attrName []string) ApiSearchUsingAttributeRequest {
	r.attrName = &attrName
	return r
}
// The prefix for the attribute value to search
func (r ApiSearchUsingAttributeRequest) AttrValuePrefix(attrValuePrefix []string) ApiSearchUsingAttributeRequest {
	r.attrValuePrefix = &attrValuePrefix
	return r
}
// Limit the result to only entities tagged with the given tag
func (r ApiSearchUsingAttributeRequest) Tag(tag []string) ApiSearchUsingAttributeRequest {
	r.tag = &tag
	return r
}
// The type of time range search, default is CUSTOM
func (r ApiSearchUsingAttributeRequest) TimeRangeType(timeRangeType string) ApiSearchUsingAttributeRequest {
	r.timeRangeType = &timeRangeType
	return r
}
// The attribute for a time range search
func (r ApiSearchUsingAttributeRequest) TimeRangeAttr(timeRangeAttr string) ApiSearchUsingAttributeRequest {
	r.timeRangeAttr = &timeRangeAttr
	return r
}
// The start for a custom time range search in ms since the epoch
func (r ApiSearchUsingAttributeRequest) TimeRangeStart(timeRangeStart int64) ApiSearchUsingAttributeRequest {
	r.timeRangeStart = &timeRangeStart
	return r
}
// The end for a custom time range search in ms since the epoch
func (r ApiSearchUsingAttributeRequest) TimeRangeEnd(timeRangeEnd int64) ApiSearchUsingAttributeRequest {
	r.timeRangeEnd = &timeRangeEnd
	return r
}
// An attribute to sort by
func (r ApiSearchUsingAttributeRequest) SortBy(sortBy string) ApiSearchUsingAttributeRequest {
	r.sortBy = &sortBy
	return r
}
// Sort order, either ASCENDING (default) or DESCENDING
func (r ApiSearchUsingAttributeRequest) SortOrder(sortOrder string) ApiSearchUsingAttributeRequest {
	r.sortOrder = &sortOrder
	return r
}
// Whether to include deleted entities
func (r ApiSearchUsingAttributeRequest) Deleted(deleted bool) ApiSearchUsingAttributeRequest {
	r.deleted = &deleted
	return r
}
// Limit the result set to only include the specified number of entries
func (r ApiSearchUsingAttributeRequest) Limit(limit int32) ApiSearchUsingAttributeRequest {
	r.limit = &limit
	return r
}
// Start offset of the result set (useful for pagination)
func (r ApiSearchUsingAttributeRequest) Offset(offset int32) ApiSearchUsingAttributeRequest {
	r.offset = &offset
	return r
}

func (r ApiSearchUsingAttributeRequest) Execute() (SearchResult, *_nethttp.Response, error) {
	return r.ApiService.SearchUsingAttributeExecute(r)
}

/*
SearchUsingAttribute Retrieve data for the specified attribute search query.

Retrieve data for the specified attribute search query.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchUsingAttributeRequest
*/
func (a *DefaultApiService) SearchUsingAttribute(ctx _context.Context) ApiSearchUsingAttributeRequest {
	return ApiSearchUsingAttributeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchResult
func (a *DefaultApiService) SearchUsingAttributeExecute(r ApiSearchUsingAttributeRequest) (SearchResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SearchUsingAttribute")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/search/attribute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("type", parameterToString(t, "multi"))
		}
	}
	if r.types != nil {
		localVarQueryParams.Add("types", parameterToString(*r.types, ""))
	}
	if r.attr != nil {
		t := *r.attr
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("attr", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("attr", parameterToString(t, "multi"))
		}
	}
	if r.attrs != nil {
		localVarQueryParams.Add("attrs", parameterToString(*r.attrs, ""))
	}
	if r.attrName != nil {
		t := *r.attrName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("attrName", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("attrName", parameterToString(t, "multi"))
		}
	}
	if r.attrValuePrefix != nil {
		t := *r.attrValuePrefix
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("attrValuePrefix", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("attrValuePrefix", parameterToString(t, "multi"))
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.timeRangeType != nil {
		localVarQueryParams.Add("timeRangeType", parameterToString(*r.timeRangeType, ""))
	}
	if r.timeRangeAttr != nil {
		localVarQueryParams.Add("timeRangeAttr", parameterToString(*r.timeRangeAttr, ""))
	}
	if r.timeRangeStart != nil {
		localVarQueryParams.Add("timeRangeStart", parameterToString(*r.timeRangeStart, ""))
	}
	if r.timeRangeEnd != nil {
		localVarQueryParams.Add("timeRangeEnd", parameterToString(*r.timeRangeEnd, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("sortOrder", parameterToString(*r.sortOrder, ""))
	}
	if r.deleted != nil {
		localVarQueryParams.Add("deleted", parameterToString(*r.deleted, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchUsingBasicRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	query *string
	type_ *[]string
	types *string
	attr *[]string
	attrs *string
	tag *[]string
	timeRangeType *string
	timeRangeAttr *string
	timeRangeStart *int64
	timeRangeEnd *int64
	sortBy *string
	sortOrder *string
	deleted *bool
	limit *int32
	offset *int32
}

// The full-text query
func (r ApiSearchUsingBasicRequest) Query(query string) ApiSearchUsingBasicRequest {
	r.query = &query
	return r
}
// Limit the result to only entities of specified types
func (r ApiSearchUsingBasicRequest) Type_(type_ []string) ApiSearchUsingBasicRequest {
	r.type_ = &type_
	return r
}
func (r ApiSearchUsingBasicRequest) Types(types string) ApiSearchUsingBasicRequest {
	r.types = &types
	return r
}
// One of more additional attributes to return in the response
func (r ApiSearchUsingBasicRequest) Attr(attr []string) ApiSearchUsingBasicRequest {
	r.attr = &attr
	return r
}
func (r ApiSearchUsingBasicRequest) Attrs(attrs string) ApiSearchUsingBasicRequest {
	r.attrs = &attrs
	return r
}
// Limit the result to only entities with the given tag
func (r ApiSearchUsingBasicRequest) Tag(tag []string) ApiSearchUsingBasicRequest {
	r.tag = &tag
	return r
}
// The type of time range search, default is CUSTOM
func (r ApiSearchUsingBasicRequest) TimeRangeType(timeRangeType string) ApiSearchUsingBasicRequest {
	r.timeRangeType = &timeRangeType
	return r
}
// The attribute for a time range search
func (r ApiSearchUsingBasicRequest) TimeRangeAttr(timeRangeAttr string) ApiSearchUsingBasicRequest {
	r.timeRangeAttr = &timeRangeAttr
	return r
}
// The start for a custom time range search in ms since the epoch
func (r ApiSearchUsingBasicRequest) TimeRangeStart(timeRangeStart int64) ApiSearchUsingBasicRequest {
	r.timeRangeStart = &timeRangeStart
	return r
}
// The end for a custom time range search in ms since the epoch
func (r ApiSearchUsingBasicRequest) TimeRangeEnd(timeRangeEnd int64) ApiSearchUsingBasicRequest {
	r.timeRangeEnd = &timeRangeEnd
	return r
}
// An attribute to sort by
func (r ApiSearchUsingBasicRequest) SortBy(sortBy string) ApiSearchUsingBasicRequest {
	r.sortBy = &sortBy
	return r
}
// Sort order, either ASCENDING (default) or DESCENDING
func (r ApiSearchUsingBasicRequest) SortOrder(sortOrder string) ApiSearchUsingBasicRequest {
	r.sortOrder = &sortOrder
	return r
}
// Whether to include deleted entities
func (r ApiSearchUsingBasicRequest) Deleted(deleted bool) ApiSearchUsingBasicRequest {
	r.deleted = &deleted
	return r
}
// Limit the result set to only include the specified number of entries
func (r ApiSearchUsingBasicRequest) Limit(limit int32) ApiSearchUsingBasicRequest {
	r.limit = &limit
	return r
}
// Start offset of the result set (useful for pagination)
func (r ApiSearchUsingBasicRequest) Offset(offset int32) ApiSearchUsingBasicRequest {
	r.offset = &offset
	return r
}

func (r ApiSearchUsingBasicRequest) Execute() (SearchResult, *_nethttp.Response, error) {
	return r.ApiService.SearchUsingBasicExecute(r)
}

/*
SearchUsingBasic Retrieve data for the specified fulltext query.

Retrieve data for the specified fulltext query.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchUsingBasicRequest
*/
func (a *DefaultApiService) SearchUsingBasic(ctx _context.Context) ApiSearchUsingBasicRequest {
	return ApiSearchUsingBasicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchResult
func (a *DefaultApiService) SearchUsingBasicExecute(r ApiSearchUsingBasicRequest) (SearchResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SearchUsingBasic")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/search/basic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("type", parameterToString(t, "multi"))
		}
	}
	if r.types != nil {
		localVarQueryParams.Add("types", parameterToString(*r.types, ""))
	}
	if r.attr != nil {
		t := *r.attr
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("attr", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("attr", parameterToString(t, "multi"))
		}
	}
	if r.attrs != nil {
		localVarQueryParams.Add("attrs", parameterToString(*r.attrs, ""))
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.timeRangeType != nil {
		localVarQueryParams.Add("timeRangeType", parameterToString(*r.timeRangeType, ""))
	}
	if r.timeRangeAttr != nil {
		localVarQueryParams.Add("timeRangeAttr", parameterToString(*r.timeRangeAttr, ""))
	}
	if r.timeRangeStart != nil {
		localVarQueryParams.Add("timeRangeStart", parameterToString(*r.timeRangeStart, ""))
	}
	if r.timeRangeEnd != nil {
		localVarQueryParams.Add("timeRangeEnd", parameterToString(*r.timeRangeEnd, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("sortOrder", parameterToString(*r.sortOrder, ""))
	}
	if r.deleted != nil {
		localVarQueryParams.Add("deleted", parameterToString(*r.deleted, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestCompatibilityBySubjectNameRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subject string
	version string
	body *RegisterSchemaRequest
	contentType *string
	accept *string
	verbose *bool
}

// Schema
func (r ApiTestCompatibilityBySubjectNameRequest) Body(body RegisterSchemaRequest) ApiTestCompatibilityBySubjectNameRequest {
	r.body = &body
	return r
}
func (r ApiTestCompatibilityBySubjectNameRequest) ContentType(contentType string) ApiTestCompatibilityBySubjectNameRequest {
	r.contentType = &contentType
	return r
}
func (r ApiTestCompatibilityBySubjectNameRequest) Accept(accept string) ApiTestCompatibilityBySubjectNameRequest {
	r.accept = &accept
	return r
}
func (r ApiTestCompatibilityBySubjectNameRequest) Verbose(verbose bool) ApiTestCompatibilityBySubjectNameRequest {
	r.verbose = &verbose
	return r
}

func (r ApiTestCompatibilityBySubjectNameRequest) Execute() (CompatibilityCheckResponse, *_nethttp.Response, error) {
	return r.ApiService.TestCompatibilityBySubjectNameExecute(r)
}

/*
TestCompatibilityBySubjectName Test input schema against a particular version of a subject's schema for compatibility.

the compatibility level applied for the check is the configured compatibility level for the subject (http:get:: /config/(string: subject)). If this subject's compatibility level was never changed, then the global compatibility level applies (http:get:: /config).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subject Subject of the schema version against which compatibility is to be tested
 @param version Version of the subject's schema against which compatibility is to be tested. Valid values for versionId are between [1,2^31-1] or the string \"latest\".\"latest\" checks compatibility of the input schema with the last registered schema under the specified subject
 @return ApiTestCompatibilityBySubjectNameRequest
*/
func (a *DefaultApiService) TestCompatibilityBySubjectName(ctx _context.Context, subject string, version string) ApiTestCompatibilityBySubjectNameRequest {
	return ApiTestCompatibilityBySubjectNameRequest{
		ApiService: a,
		ctx: ctx,
		subject: subject,
		version: version,
	}
}

// Execute executes the request
//  @return CompatibilityCheckResponse
func (a *DefaultApiService) TestCompatibilityBySubjectNameExecute(r ApiTestCompatibilityBySubjectNameRequest) (CompatibilityCheckResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CompatibilityCheckResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestCompatibilityBySubjectName")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compatibility/subjects/{subject}/versions/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.verbose != nil {
		localVarQueryParams.Add("verbose", parameterToString(*r.verbose, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json", "application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.contentType != nil {
		localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	}
	if r.accept != nil {
		localVarHeaderParams["Accept"] = parameterToString(*r.accept, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestCompatibilityForSubjectRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subject string
	body *RegisterSchemaRequest
	contentType *string
	accept *string
	verbose *bool
}

// Schema
func (r ApiTestCompatibilityForSubjectRequest) Body(body RegisterSchemaRequest) ApiTestCompatibilityForSubjectRequest {
	r.body = &body
	return r
}
func (r ApiTestCompatibilityForSubjectRequest) ContentType(contentType string) ApiTestCompatibilityForSubjectRequest {
	r.contentType = &contentType
	return r
}
func (r ApiTestCompatibilityForSubjectRequest) Accept(accept string) ApiTestCompatibilityForSubjectRequest {
	r.accept = &accept
	return r
}
func (r ApiTestCompatibilityForSubjectRequest) Verbose(verbose bool) ApiTestCompatibilityForSubjectRequest {
	r.verbose = &verbose
	return r
}

func (r ApiTestCompatibilityForSubjectRequest) Execute() (CompatibilityCheckResponse, *_nethttp.Response, error) {
	return r.ApiService.TestCompatibilityForSubjectExecute(r)
}

/*
TestCompatibilityForSubject Test input schema against a subject's schemas for compatibility, based on the compatibility level of the subject configured. In other word, it will perform the same compatibility check as register for that subject

the compatibility level applied for the check is the configured compatibility level for the subject (http:get:: /config/(string: subject)). If this subject's compatibility level was never changed, then the global compatibility level applies (http:get:: /config).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subject Subject of the schema version against which compatibility is to be tested
 @return ApiTestCompatibilityForSubjectRequest
*/
func (a *DefaultApiService) TestCompatibilityForSubject(ctx _context.Context, subject string) ApiTestCompatibilityForSubjectRequest {
	return ApiTestCompatibilityForSubjectRequest{
		ApiService: a,
		ctx: ctx,
		subject: subject,
	}
}

// Execute executes the request
//  @return CompatibilityCheckResponse
func (a *DefaultApiService) TestCompatibilityForSubjectExecute(r ApiTestCompatibilityForSubjectRequest) (CompatibilityCheckResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CompatibilityCheckResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestCompatibilityForSubject")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compatibility/subjects/{subject}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.verbose != nil {
		localVarQueryParams.Add("verbose", parameterToString(*r.verbose, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json", "application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.contentType != nil {
		localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	}
	if r.accept != nil {
		localVarHeaderParams["Accept"] = parameterToString(*r.accept, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUndeleteDekVersionRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
	subject string
	version string
	algorithm *string
}

// Algorithm of the dek
func (r ApiUndeleteDekVersionRequest) Algorithm(algorithm string) ApiUndeleteDekVersionRequest {
	r.algorithm = &algorithm
	return r
}

func (r ApiUndeleteDekVersionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UndeleteDekVersionExecute(r)
}

/*
UndeleteDekVersion Undelete a dek version.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the kek
 @param subject Subject of the dek
 @param version Version of the dek
 @return ApiUndeleteDekVersionRequest
*/
func (a *DefaultApiService) UndeleteDekVersion(ctx _context.Context, name string, subject string, version string) ApiUndeleteDekVersionRequest {
	return ApiUndeleteDekVersionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		subject: subject,
		version: version,
	}
}

// Execute executes the request
func (a *DefaultApiService) UndeleteDekVersionExecute(r ApiUndeleteDekVersionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UndeleteDekVersion")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dek-registry/v1/keks/{name}/deks/{subject}/versions/{version}/undelete"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.algorithm != nil {
		localVarQueryParams.Add("algorithm", parameterToString(*r.algorithm, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUndeleteDekVersionsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
	subject string
	algorithm *string
}

// Algorithm of the dek
func (r ApiUndeleteDekVersionsRequest) Algorithm(algorithm string) ApiUndeleteDekVersionsRequest {
	r.algorithm = &algorithm
	return r
}

func (r ApiUndeleteDekVersionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UndeleteDekVersionsExecute(r)
}

/*
UndeleteDekVersions Undelete all versions of a dek.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the kek
 @param subject Subject of the dek
 @return ApiUndeleteDekVersionsRequest
*/
func (a *DefaultApiService) UndeleteDekVersions(ctx _context.Context, name string, subject string) ApiUndeleteDekVersionsRequest {
	return ApiUndeleteDekVersionsRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		subject: subject,
	}
}

// Execute executes the request
func (a *DefaultApiService) UndeleteDekVersionsExecute(r ApiUndeleteDekVersionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UndeleteDekVersions")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dek-registry/v1/keks/{name}/deks/{subject}/undelete"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.algorithm != nil {
		localVarQueryParams.Add("algorithm", parameterToString(*r.algorithm, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUndeleteKekRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	name string
}


func (r ApiUndeleteKekRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UndeleteKekExecute(r)
}

/*
UndeleteKek Undelete a kek.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the kek
 @return ApiUndeleteKekRequest
*/
func (a *DefaultApiService) UndeleteKek(ctx _context.Context, name string) ApiUndeleteKekRequest {
	return ApiUndeleteKekRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultApiService) UndeleteKekExecute(r ApiUndeleteKekRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UndeleteKek")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dek-registry/v1/keks/{name}/undelete"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateBusinessMetadataRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	businessMetadata *[]BusinessMetadata
}

// The business metadata
func (r ApiUpdateBusinessMetadataRequest) BusinessMetadata(businessMetadata []BusinessMetadata) ApiUpdateBusinessMetadataRequest {
	r.businessMetadata = &businessMetadata
	return r
}

func (r ApiUpdateBusinessMetadataRequest) Execute() ([]BusinessMetadataResponse, *_nethttp.Response, error) {
	return r.ApiService.UpdateBusinessMetadataExecute(r)
}

/*
UpdateBusinessMetadata Bulk API to update multiple business metadata.

Bulk API to update multiple business metadata.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateBusinessMetadataRequest
*/
func (a *DefaultApiService) UpdateBusinessMetadata(ctx _context.Context) ApiUpdateBusinessMetadataRequest {
	return ApiUpdateBusinessMetadataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BusinessMetadataResponse
func (a *DefaultApiService) UpdateBusinessMetadataExecute(r ApiUpdateBusinessMetadataRequest) ([]BusinessMetadataResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BusinessMetadataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateBusinessMetadata")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/entity/businessmetadata"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.businessMetadata
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBusinessMetadataDefsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	atlasBusinessMetadataDef *[]AtlasBusinessMetadataDef
}

// The business metadata definitions to update
func (r ApiUpdateBusinessMetadataDefsRequest) AtlasBusinessMetadataDef(atlasBusinessMetadataDef []AtlasBusinessMetadataDef) ApiUpdateBusinessMetadataDefsRequest {
	r.atlasBusinessMetadataDef = &atlasBusinessMetadataDef
	return r
}

func (r ApiUpdateBusinessMetadataDefsRequest) Execute() ([]BusinessMetadataDefResponse, *_nethttp.Response, error) {
	return r.ApiService.UpdateBusinessMetadataDefsExecute(r)
}

/*
UpdateBusinessMetadataDefs Bulk update API for business metadata definitions.

Bulk update API for business metadata definitions.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateBusinessMetadataDefsRequest
*/
func (a *DefaultApiService) UpdateBusinessMetadataDefs(ctx _context.Context) ApiUpdateBusinessMetadataDefsRequest {
	return ApiUpdateBusinessMetadataDefsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BusinessMetadataDefResponse
func (a *DefaultApiService) UpdateBusinessMetadataDefsExecute(r ApiUpdateBusinessMetadataDefsRequest) ([]BusinessMetadataDefResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BusinessMetadataDefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateBusinessMetadataDefs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/types/businessmetadatadefs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.atlasBusinessMetadataDef
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateModeRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subject string
	body *ModeUpdateRequest
}

// Update Request
func (r ApiUpdateModeRequest) Body(body ModeUpdateRequest) ApiUpdateModeRequest {
	r.body = &body
	return r
}

func (r ApiUpdateModeRequest) Execute() (ModeUpdateRequest, *_nethttp.Response, error) {
	return r.ApiService.UpdateModeExecute(r)
}

/*
UpdateMode Update mode for the specified subject.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subject Name of the Subject
 @return ApiUpdateModeRequest
*/
func (a *DefaultApiService) UpdateMode(ctx _context.Context, subject string) ApiUpdateModeRequest {
	return ApiUpdateModeRequest{
		ApiService: a,
		ctx: ctx,
		subject: subject,
	}
}

// Execute executes the request
//  @return ModeUpdateRequest
func (a *DefaultApiService) UpdateModeExecute(r ApiUpdateModeRequest) (ModeUpdateRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ModeUpdateRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateMode")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mode/{subject}"
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json", "application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSubjectLevelConfigRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	subject string
	body *ConfigUpdateRequest
}

// Config Update Request
func (r ApiUpdateSubjectLevelConfigRequest) Body(body ConfigUpdateRequest) ApiUpdateSubjectLevelConfigRequest {
	r.body = &body
	return r
}

func (r ApiUpdateSubjectLevelConfigRequest) Execute() (ConfigUpdateRequest, *_nethttp.Response, error) {
	return r.ApiService.UpdateSubjectLevelConfigExecute(r)
}

/*
UpdateSubjectLevelConfig Update compatibility level for the specified subject.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subject Name of the Subject
 @return ApiUpdateSubjectLevelConfigRequest
*/
func (a *DefaultApiService) UpdateSubjectLevelConfig(ctx _context.Context, subject string) ApiUpdateSubjectLevelConfigRequest {
	return ApiUpdateSubjectLevelConfigRequest{
		ApiService: a,
		ctx: ctx,
		subject: subject,
	}
}

// Execute executes the request
//  @return ConfigUpdateRequest
func (a *DefaultApiService) UpdateSubjectLevelConfigExecute(r ApiUpdateSubjectLevelConfigRequest) (ConfigUpdateRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ConfigUpdateRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSubjectLevelConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/{subject}"
	localVarPath = strings.Replace(localVarPath, "{"+"subject"+"}", _neturl.PathEscape(parameterToString(r.subject, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json", "application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTagDefsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	tagDef *[]TagDef
}

// The tag definitions to update
func (r ApiUpdateTagDefsRequest) TagDef(tagDef []TagDef) ApiUpdateTagDefsRequest {
	r.tagDef = &tagDef
	return r
}

func (r ApiUpdateTagDefsRequest) Execute() ([]TagDefResponse, *_nethttp.Response, error) {
	return r.ApiService.UpdateTagDefsExecute(r)
}

/*
UpdateTagDefs Bulk update API for tag definitions.

Bulk update API for tag definitions.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateTagDefsRequest
*/
func (a *DefaultApiService) UpdateTagDefs(ctx _context.Context) ApiUpdateTagDefsRequest {
	return ApiUpdateTagDefsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TagDefResponse
func (a *DefaultApiService) UpdateTagDefsExecute(r ApiUpdateTagDefsRequest) ([]TagDefResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []TagDefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateTagDefs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/types/tagdefs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagDef
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTagsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	tag *[]Tag
}

// The tags
func (r ApiUpdateTagsRequest) Tag(tag []Tag) ApiUpdateTagsRequest {
	r.tag = &tag
	return r
}

func (r ApiUpdateTagsRequest) Execute() ([]TagResponse, *_nethttp.Response, error) {
	return r.ApiService.UpdateTagsExecute(r)
}

/*
UpdateTags Bulk API to update multiple tags.

Bulk API to update multiple tags.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateTagsRequest
*/
func (a *DefaultApiService) UpdateTags(ctx _context.Context) ApiUpdateTagsRequest {
	return ApiUpdateTagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TagResponse
func (a *DefaultApiService) UpdateTagsExecute(r ApiUpdateTagsRequest) ([]TagResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []TagResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateTags")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/catalog/v1/entity/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tag
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTopLevelConfigRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	configUpdateRequest *ConfigUpdateRequest
}

// Config Update Request
func (r ApiUpdateTopLevelConfigRequest) ConfigUpdateRequest(configUpdateRequest ConfigUpdateRequest) ApiUpdateTopLevelConfigRequest {
	r.configUpdateRequest = &configUpdateRequest
	return r
}

func (r ApiUpdateTopLevelConfigRequest) Execute() (ConfigUpdateRequest, *_nethttp.Response, error) {
	return r.ApiService.UpdateTopLevelConfigExecute(r)
}

/*
UpdateTopLevelConfig Update global compatibility level

Updates the global compatibility level. On success, echoes the original request back to the client.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateTopLevelConfigRequest
*/
func (a *DefaultApiService) UpdateTopLevelConfig(ctx _context.Context) ApiUpdateTopLevelConfigRequest {
	return ApiUpdateTopLevelConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConfigUpdateRequest
func (a *DefaultApiService) UpdateTopLevelConfigExecute(r ApiUpdateTopLevelConfigRequest) (ConfigUpdateRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ConfigUpdateRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateTopLevelConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.configUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("configUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json", "application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTopLevelModeRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	body *ModeUpdateRequest
}

// Update Request
func (r ApiUpdateTopLevelModeRequest) Body(body ModeUpdateRequest) ApiUpdateTopLevelModeRequest {
	r.body = &body
	return r
}

func (r ApiUpdateTopLevelModeRequest) Execute() (ModeUpdateRequest, *_nethttp.Response, error) {
	return r.ApiService.UpdateTopLevelModeExecute(r)
}

/*
UpdateTopLevelMode Update global mode.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateTopLevelModeRequest
*/
func (a *DefaultApiService) UpdateTopLevelMode(ctx _context.Context) ApiUpdateTopLevelModeRequest {
	return ApiUpdateTopLevelModeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModeUpdateRequest
func (a *DefaultApiService) UpdateTopLevelModeExecute(r ApiUpdateTopLevelModeRequest) (ModeUpdateRequest, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ModeUpdateRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateTopLevelMode")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json", "application/json", "application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.schemaregistry.v1+json", "application/vnd.schemaregistry+json; qs=0.9", "application/json; qs=0.5"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
