// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: interfaces.go

package mock

import (
	sync "sync"

	github_com_confluentinc_ccloud_sdk_go_v1_public "github.com/confluentinc/ccloud-sdk-go-v1-public"
)

// Auth is a mock of Auth interface
type Auth struct {
	lockLogin sync.Mutex
	LoginFunc func(arg0 *github_com_confluentinc_ccloud_sdk_go_v1_public.AuthenticateRequest) (*github_com_confluentinc_ccloud_sdk_go_v1_public.AuthenticateReply, error)

	lockOktaLogin sync.Mutex
	OktaLoginFunc func(arg0 *github_com_confluentinc_ccloud_sdk_go_v1_public.AuthenticateRequest) (*github_com_confluentinc_ccloud_sdk_go_v1_public.AuthenticateReply, error)

	lockUser sync.Mutex
	UserFunc func() (*github_com_confluentinc_ccloud_sdk_go_v1_public.GetMeReply, error)

	calls struct {
		Login []struct {
			Arg0 *github_com_confluentinc_ccloud_sdk_go_v1_public.AuthenticateRequest
		}
		OktaLogin []struct {
			Arg0 *github_com_confluentinc_ccloud_sdk_go_v1_public.AuthenticateRequest
		}
		User []struct {
		}
	}
}

// Login mocks base method by wrapping the associated func.
func (m *Auth) Login(arg0 *github_com_confluentinc_ccloud_sdk_go_v1_public.AuthenticateRequest) (*github_com_confluentinc_ccloud_sdk_go_v1_public.AuthenticateReply, error) {
	m.lockLogin.Lock()
	defer m.lockLogin.Unlock()

	if m.LoginFunc == nil {
		panic("mocker: Auth.LoginFunc is nil but Auth.Login was called.")
	}

	call := struct {
		Arg0 *github_com_confluentinc_ccloud_sdk_go_v1_public.AuthenticateRequest
	}{
		Arg0: arg0,
	}

	m.calls.Login = append(m.calls.Login, call)

	return m.LoginFunc(arg0)
}

// LoginCalled returns true if Login was called at least once.
func (m *Auth) LoginCalled() bool {
	m.lockLogin.Lock()
	defer m.lockLogin.Unlock()

	return len(m.calls.Login) > 0
}

// LoginCalls returns the calls made to Login.
func (m *Auth) LoginCalls() []struct {
	Arg0 *github_com_confluentinc_ccloud_sdk_go_v1_public.AuthenticateRequest
} {
	m.lockLogin.Lock()
	defer m.lockLogin.Unlock()

	return m.calls.Login
}

// OktaLogin mocks base method by wrapping the associated func.
func (m *Auth) OktaLogin(arg0 *github_com_confluentinc_ccloud_sdk_go_v1_public.AuthenticateRequest) (*github_com_confluentinc_ccloud_sdk_go_v1_public.AuthenticateReply, error) {
	m.lockOktaLogin.Lock()
	defer m.lockOktaLogin.Unlock()

	if m.OktaLoginFunc == nil {
		panic("mocker: Auth.OktaLoginFunc is nil but Auth.OktaLogin was called.")
	}

	call := struct {
		Arg0 *github_com_confluentinc_ccloud_sdk_go_v1_public.AuthenticateRequest
	}{
		Arg0: arg0,
	}

	m.calls.OktaLogin = append(m.calls.OktaLogin, call)

	return m.OktaLoginFunc(arg0)
}

// OktaLoginCalled returns true if OktaLogin was called at least once.
func (m *Auth) OktaLoginCalled() bool {
	m.lockOktaLogin.Lock()
	defer m.lockOktaLogin.Unlock()

	return len(m.calls.OktaLogin) > 0
}

// OktaLoginCalls returns the calls made to OktaLogin.
func (m *Auth) OktaLoginCalls() []struct {
	Arg0 *github_com_confluentinc_ccloud_sdk_go_v1_public.AuthenticateRequest
} {
	m.lockOktaLogin.Lock()
	defer m.lockOktaLogin.Unlock()

	return m.calls.OktaLogin
}

// User mocks base method by wrapping the associated func.
func (m *Auth) User() (*github_com_confluentinc_ccloud_sdk_go_v1_public.GetMeReply, error) {
	m.lockUser.Lock()
	defer m.lockUser.Unlock()

	if m.UserFunc == nil {
		panic("mocker: Auth.UserFunc is nil but Auth.User was called.")
	}

	call := struct {
	}{}

	m.calls.User = append(m.calls.User, call)

	return m.UserFunc()
}

// UserCalled returns true if User was called at least once.
func (m *Auth) UserCalled() bool {
	m.lockUser.Lock()
	defer m.lockUser.Unlock()

	return len(m.calls.User) > 0
}

// UserCalls returns the calls made to User.
func (m *Auth) UserCalls() []struct {
} {
	m.lockUser.Lock()
	defer m.lockUser.Unlock()

	return m.calls.User
}

// Reset resets the calls made to the mocked methods.
func (m *Auth) Reset() {
	m.lockLogin.Lock()
	m.calls.Login = nil
	m.lockLogin.Unlock()
	m.lockOktaLogin.Lock()
	m.calls.OktaLogin = nil
	m.lockOktaLogin.Unlock()
	m.lockUser.Lock()
	m.calls.User = nil
	m.lockUser.Unlock()
}
