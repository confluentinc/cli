// Copyright 2021 Confluent Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*
ksqlDB Cluster Management API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 0.0.1
Contact: ksql-team@confluent.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v2

import (
	"encoding/json"
)

import (
	"reflect"
)

// KsqldbcmV2ClusterSpec The desired state of the Cluster
type KsqldbcmV2ClusterSpec struct {
	// The name of the ksqlDB cluster.
	DisplayName *string `json:"display_name,omitempty"`
	// This flag controls whether you want to include the row data in the processing log topic. Turn it off if you don't want to emit sensitive information to the processing log 
	UseDetailedProcessingLog *bool `json:"use_detailed_processing_log,omitempty"`
	// The number of CSUs (Confluent Streaming Units) in a ksqlDB cluster.
	Csu *int32 `json:"csu,omitempty"`
	// The kafka_cluster to which this belongs.
	KafkaCluster *ObjectReference `json:"kafka_cluster,omitempty"`
	// The credential_identity to which this belongs. The credential_identity can be one of iam.v2.User, iam.v2.ServiceAccount.
	CredentialIdentity *ObjectReference `json:"credential_identity,omitempty"`
	// The environment to which this belongs.
	Environment *ObjectReference `json:"environment,omitempty"`
}

// NewKsqldbcmV2ClusterSpec instantiates a new KsqldbcmV2ClusterSpec object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewKsqldbcmV2ClusterSpec() *KsqldbcmV2ClusterSpec {
	this := KsqldbcmV2ClusterSpec{}
	var useDetailedProcessingLog bool = true
	this.UseDetailedProcessingLog = &useDetailedProcessingLog
	return &this
}

// NewKsqldbcmV2ClusterSpecWithDefaults instantiates a new KsqldbcmV2ClusterSpec object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewKsqldbcmV2ClusterSpecWithDefaults() *KsqldbcmV2ClusterSpec {
	this := KsqldbcmV2ClusterSpec{}
	var useDetailedProcessingLog bool = true
	this.UseDetailedProcessingLog = &useDetailedProcessingLog
	return &this
}

// GetDisplayName returns the DisplayName field value if set, zero value otherwise.
func (o *KsqldbcmV2ClusterSpec) GetDisplayName() string {
	if o == nil || o.DisplayName == nil {
		var ret string
		return ret
	}
	return *o.DisplayName
}

// GetDisplayNameOk returns a tuple with the DisplayName field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *KsqldbcmV2ClusterSpec) GetDisplayNameOk() (*string, bool) {
	if o == nil || o.DisplayName == nil {
		return nil, false
	}
	return o.DisplayName, true
}

// HasDisplayName returns a boolean if a field has been set.
func (o *KsqldbcmV2ClusterSpec) HasDisplayName() bool {
	if o != nil && o.DisplayName != nil {
		return true
	}

	return false
}

// SetDisplayName gets a reference to the given string and assigns it to the DisplayName field.
func (o *KsqldbcmV2ClusterSpec) SetDisplayName(v string) {
	o.DisplayName = &v
}

// GetUseDetailedProcessingLog returns the UseDetailedProcessingLog field value if set, zero value otherwise.
func (o *KsqldbcmV2ClusterSpec) GetUseDetailedProcessingLog() bool {
	if o == nil || o.UseDetailedProcessingLog == nil {
		var ret bool
		return ret
	}
	return *o.UseDetailedProcessingLog
}

// GetUseDetailedProcessingLogOk returns a tuple with the UseDetailedProcessingLog field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *KsqldbcmV2ClusterSpec) GetUseDetailedProcessingLogOk() (*bool, bool) {
	if o == nil || o.UseDetailedProcessingLog == nil {
		return nil, false
	}
	return o.UseDetailedProcessingLog, true
}

// HasUseDetailedProcessingLog returns a boolean if a field has been set.
func (o *KsqldbcmV2ClusterSpec) HasUseDetailedProcessingLog() bool {
	if o != nil && o.UseDetailedProcessingLog != nil {
		return true
	}

	return false
}

// SetUseDetailedProcessingLog gets a reference to the given bool and assigns it to the UseDetailedProcessingLog field.
func (o *KsqldbcmV2ClusterSpec) SetUseDetailedProcessingLog(v bool) {
	o.UseDetailedProcessingLog = &v
}

// GetCsu returns the Csu field value if set, zero value otherwise.
func (o *KsqldbcmV2ClusterSpec) GetCsu() int32 {
	if o == nil || o.Csu == nil {
		var ret int32
		return ret
	}
	return *o.Csu
}

// GetCsuOk returns a tuple with the Csu field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *KsqldbcmV2ClusterSpec) GetCsuOk() (*int32, bool) {
	if o == nil || o.Csu == nil {
		return nil, false
	}
	return o.Csu, true
}

// HasCsu returns a boolean if a field has been set.
func (o *KsqldbcmV2ClusterSpec) HasCsu() bool {
	if o != nil && o.Csu != nil {
		return true
	}

	return false
}

// SetCsu gets a reference to the given int32 and assigns it to the Csu field.
func (o *KsqldbcmV2ClusterSpec) SetCsu(v int32) {
	o.Csu = &v
}

// GetKafkaCluster returns the KafkaCluster field value if set, zero value otherwise.
func (o *KsqldbcmV2ClusterSpec) GetKafkaCluster() ObjectReference {
	if o == nil || o.KafkaCluster == nil {
		var ret ObjectReference
		return ret
	}
	return *o.KafkaCluster
}

// GetKafkaClusterOk returns a tuple with the KafkaCluster field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *KsqldbcmV2ClusterSpec) GetKafkaClusterOk() (*ObjectReference, bool) {
	if o == nil || o.KafkaCluster == nil {
		return nil, false
	}
	return o.KafkaCluster, true
}

// HasKafkaCluster returns a boolean if a field has been set.
func (o *KsqldbcmV2ClusterSpec) HasKafkaCluster() bool {
	if o != nil && o.KafkaCluster != nil {
		return true
	}

	return false
}

// SetKafkaCluster gets a reference to the given ObjectReference and assigns it to the KafkaCluster field.
func (o *KsqldbcmV2ClusterSpec) SetKafkaCluster(v ObjectReference) {
	o.KafkaCluster = &v
}

// GetCredentialIdentity returns the CredentialIdentity field value if set, zero value otherwise.
func (o *KsqldbcmV2ClusterSpec) GetCredentialIdentity() ObjectReference {
	if o == nil || o.CredentialIdentity == nil {
		var ret ObjectReference
		return ret
	}
	return *o.CredentialIdentity
}

// GetCredentialIdentityOk returns a tuple with the CredentialIdentity field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *KsqldbcmV2ClusterSpec) GetCredentialIdentityOk() (*ObjectReference, bool) {
	if o == nil || o.CredentialIdentity == nil {
		return nil, false
	}
	return o.CredentialIdentity, true
}

// HasCredentialIdentity returns a boolean if a field has been set.
func (o *KsqldbcmV2ClusterSpec) HasCredentialIdentity() bool {
	if o != nil && o.CredentialIdentity != nil {
		return true
	}

	return false
}

// SetCredentialIdentity gets a reference to the given ObjectReference and assigns it to the CredentialIdentity field.
func (o *KsqldbcmV2ClusterSpec) SetCredentialIdentity(v ObjectReference) {
	o.CredentialIdentity = &v
}

// GetEnvironment returns the Environment field value if set, zero value otherwise.
func (o *KsqldbcmV2ClusterSpec) GetEnvironment() ObjectReference {
	if o == nil || o.Environment == nil {
		var ret ObjectReference
		return ret
	}
	return *o.Environment
}

// GetEnvironmentOk returns a tuple with the Environment field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *KsqldbcmV2ClusterSpec) GetEnvironmentOk() (*ObjectReference, bool) {
	if o == nil || o.Environment == nil {
		return nil, false
	}
	return o.Environment, true
}

// HasEnvironment returns a boolean if a field has been set.
func (o *KsqldbcmV2ClusterSpec) HasEnvironment() bool {
	if o != nil && o.Environment != nil {
		return true
	}

	return false
}

// SetEnvironment gets a reference to the given ObjectReference and assigns it to the Environment field.
func (o *KsqldbcmV2ClusterSpec) SetEnvironment(v ObjectReference) {
	o.Environment = &v
}

// Redact resets all sensitive fields to their zero value.
func (o *KsqldbcmV2ClusterSpec) Redact() {
    o.recurseRedact(o.DisplayName)
    o.recurseRedact(o.UseDetailedProcessingLog)
    o.recurseRedact(o.Csu)
    o.recurseRedact(o.KafkaCluster)
    o.recurseRedact(o.CredentialIdentity)
    o.recurseRedact(o.Environment)
}

func (o *KsqldbcmV2ClusterSpec) recurseRedact(v interface{}) {
    type redactor interface {
        Redact()
    }
    if r, ok := v.(redactor); ok {
        r.Redact()
    } else {
        val := reflect.ValueOf(v)
        if val.Kind() == reflect.Ptr {
            val = val.Elem()
        }
        switch val.Kind() {
        case reflect.Slice, reflect.Array:
            for i := 0; i < val.Len(); i++ {
                // support data types declared without pointers
                o.recurseRedact(val.Index(i).Interface())
                // ... and data types that were declared without but need pointers (for Redact)
                if val.Index(i).CanAddr() {
                    o.recurseRedact(val.Index(i).Addr().Interface())
                }
            }
        }
    }
}

func (o KsqldbcmV2ClusterSpec) zeroField(v interface{}) {
    p := reflect.ValueOf(v).Elem()
    p.Set(reflect.Zero(p.Type()))
}

func (o KsqldbcmV2ClusterSpec) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]interface{}{}
	if o.DisplayName != nil {
		toSerialize["display_name"] = o.DisplayName
	}
	if o.UseDetailedProcessingLog != nil {
		toSerialize["use_detailed_processing_log"] = o.UseDetailedProcessingLog
	}
	if o.Csu != nil {
		toSerialize["csu"] = o.Csu
	}
	if o.KafkaCluster != nil {
		toSerialize["kafka_cluster"] = o.KafkaCluster
	}
	if o.CredentialIdentity != nil {
		toSerialize["credential_identity"] = o.CredentialIdentity
	}
	if o.Environment != nil {
		toSerialize["environment"] = o.Environment
	}
	return json.Marshal(toSerialize)
}

type NullableKsqldbcmV2ClusterSpec struct {
	value *KsqldbcmV2ClusterSpec
	isSet bool
}

func (v NullableKsqldbcmV2ClusterSpec) Get() *KsqldbcmV2ClusterSpec {
	return v.value
}

func (v *NullableKsqldbcmV2ClusterSpec) Set(val *KsqldbcmV2ClusterSpec) {
	v.value = val
	v.isSet = true
}

func (v NullableKsqldbcmV2ClusterSpec) IsSet() bool {
	return v.isSet
}

func (v *NullableKsqldbcmV2ClusterSpec) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableKsqldbcmV2ClusterSpec(val *KsqldbcmV2ClusterSpec) *NullableKsqldbcmV2ClusterSpec {
	return &NullableKsqldbcmV2ClusterSpec{value: val, isSet: true}
}

func (v NullableKsqldbcmV2ClusterSpec) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableKsqldbcmV2ClusterSpec) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


