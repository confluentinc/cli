// Copyright 2021 Confluent Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*
Kafka Connect APIs

REST API for managing connectors

API version: 1.0
Contact: connect@confluent.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v1

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type LifecycleV1Api interface {

	/*
	PauseConnectv1Connector Pause a Connector

	[![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Pause the connector and its tasks. Stops message processing until the connector is resumed. This call is asynchronous and the tasks will not transition to PAUSED state at the same time.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param connectorName The unique name of the connector.
	 @param environmentId The unique identifier of the environment this resource belongs to.
	 @param kafkaClusterId The unique identifier for the Kafka cluster.
	 @return ApiPauseConnectv1ConnectorRequest
	*/
	PauseConnectv1Connector(ctx _context.Context, connectorName string, environmentId string, kafkaClusterId string) ApiPauseConnectv1ConnectorRequest

	// PauseConnectv1ConnectorExecute executes the request
	PauseConnectv1ConnectorExecute(r ApiPauseConnectv1ConnectorRequest) (*_nethttp.Response, error)

	/*
	ResumeConnectv1Connector Resume a Connector

	[![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Resume a paused connector or do nothing if the connector is not paused. This call is asynchronous and the tasks will not transition to RUNNING state at the same time.

	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param connectorName The unique name of the connector.
	 @param environmentId The unique identifier of the environment this resource belongs to.
	 @param kafkaClusterId The unique identifier for the Kafka cluster.
	 @return ApiResumeConnectv1ConnectorRequest
	*/
	ResumeConnectv1Connector(ctx _context.Context, connectorName string, environmentId string, kafkaClusterId string) ApiResumeConnectv1ConnectorRequest

	// ResumeConnectv1ConnectorExecute executes the request
	ResumeConnectv1ConnectorExecute(r ApiResumeConnectv1ConnectorRequest) (*_nethttp.Response, error)
}

// LifecycleV1ApiService LifecycleV1Api service
type LifecycleV1ApiService service

type ApiPauseConnectv1ConnectorRequest struct {
	ctx _context.Context
	ApiService LifecycleV1Api
	connectorName string
	environmentId string
	kafkaClusterId string
}


func (r ApiPauseConnectv1ConnectorRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PauseConnectv1ConnectorExecute(r)
}

/*
PauseConnectv1Connector Pause a Connector

[![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Pause the connector and its tasks. Stops message processing until the connector is resumed. This call is asynchronous and the tasks will not transition to PAUSED state at the same time.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectorName The unique name of the connector.
 @param environmentId The unique identifier of the environment this resource belongs to.
 @param kafkaClusterId The unique identifier for the Kafka cluster.
 @return ApiPauseConnectv1ConnectorRequest
*/
func (a *LifecycleV1ApiService) PauseConnectv1Connector(ctx _context.Context, connectorName string, environmentId string, kafkaClusterId string) ApiPauseConnectv1ConnectorRequest {
	return ApiPauseConnectv1ConnectorRequest{
		ApiService: a,
		ctx: ctx,
		connectorName: connectorName,
		environmentId: environmentId,
		kafkaClusterId: kafkaClusterId,
	}
}

// Execute executes the request
func (a *LifecycleV1ApiService) PauseConnectv1ConnectorExecute(r ApiPauseConnectv1ConnectorRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LifecycleV1ApiService.PauseConnectv1Connector")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connect/v1/environments/{environment_id}/clusters/{kafka_cluster_id}/connectors/{connector_name}/pause"
	localVarPath = strings.Replace(localVarPath, "{"+"connector_name"+"}", _neturl.PathEscape(parameterToString(r.connectorName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment_id"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"kafka_cluster_id"+"}", _neturl.PathEscape(parameterToString(r.kafkaClusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ConnectV1ConnectorError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ConnectV1ConnectorError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ConnectV1ConnectorError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiResumeConnectv1ConnectorRequest struct {
	ctx _context.Context
	ApiService LifecycleV1Api
	connectorName string
	environmentId string
	kafkaClusterId string
}


func (r ApiResumeConnectv1ConnectorRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ResumeConnectv1ConnectorExecute(r)
}

/*
ResumeConnectv1Connector Resume a Connector

[![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)

Resume a paused connector or do nothing if the connector is not paused. This call is asynchronous and the tasks will not transition to RUNNING state at the same time.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectorName The unique name of the connector.
 @param environmentId The unique identifier of the environment this resource belongs to.
 @param kafkaClusterId The unique identifier for the Kafka cluster.
 @return ApiResumeConnectv1ConnectorRequest
*/
func (a *LifecycleV1ApiService) ResumeConnectv1Connector(ctx _context.Context, connectorName string, environmentId string, kafkaClusterId string) ApiResumeConnectv1ConnectorRequest {
	return ApiResumeConnectv1ConnectorRequest{
		ApiService: a,
		ctx: ctx,
		connectorName: connectorName,
		environmentId: environmentId,
		kafkaClusterId: kafkaClusterId,
	}
}

// Execute executes the request
func (a *LifecycleV1ApiService) ResumeConnectv1ConnectorExecute(r ApiResumeConnectv1ConnectorRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LifecycleV1ApiService.ResumeConnectv1Connector")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connect/v1/environments/{environment_id}/clusters/{kafka_cluster_id}/connectors/{connector_name}/resume"
	localVarPath = strings.Replace(localVarPath, "{"+"connector_name"+"}", _neturl.PathEscape(parameterToString(r.connectorName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment_id"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"kafka_cluster_id"+"}", _neturl.PathEscape(parameterToString(r.kafkaClusterId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ConnectV1ConnectorError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ConnectV1ConnectorError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ConnectV1ConnectorError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
