/*
 * MDS API
 *
 * ## Confluent Metadata API - Swagger UI --- This tool (SwaggerUI) and the Open API spec file are provided _for development / test purposes only_:  - **Do _not_ enable in Production.** - **This tool only works with HTTP.**  ### Authenticating Authentication is supported in this version only for testing purposes. Real users get their tokens from cc-auth-service.  Authentication is performed by HTTP Basic Auth or by presenting a bearer token. In this UI, click **Authorize** to enter credentials.  To get a bearer token, first call the authenticate endpoint with basic auth, and then extract the auth_token part of the request, and pass that as the bearer token.  ### Access Restrictions - Who can call what?  Some endpoints can be called by any authenticated user, while others can only be called by \"admins\". Additionally, many of the endpoints in the API involve two users: the user who is calling the endpoint (the \"calling\" principal) and the user that the API call is about (the \"target\" principal).  Example: User u-abc12, who has the UserAdmin role, and is identifed by her basic auth credentials or a bearer token, calls the CRUD endpoint to modify role bindings about user u-45def.  To document what access restrictions each endpoint has, use the following legend, which lists access in order from least restrictive to most restrictive:  *  **Users**: Any authenticated user *  **Admins+Users**: Admins or the user requesting information about themself *  **Admins**: Admins only, which can be UserAdmin, SystemAdmin, broker super.user, or SecurityAdmin as \"Read\"  ### Overview of Responses  **Valid**  * 200 - Successful call with a return body. * 204 - Sucessuful call with **no** return body.  **Errors**  * 400 - Invalid request.  JSON parsing error, or otherwise incorrect request. * 401 - Not Authenticated.  You need to pass valid basic auth credentials or a user bearer token. * 403 - Not Authorized.  Valid request, but you aren't authorized to perform the requested action. * 404 - Invalid URL.  If you get this error from the authenticate endpoint, it means bearer token authentication needs to be enabled in the configuration.     * ``confluent.metadata.server.authentication.method=BEARER`` * 405 - Method Not Allowed.  Using the wrong HTTP method on a valid endpoint (for example, GET instead of POST). * 415 - Invalid Content Type.  Usually, not sending \"application/json\" as request body header. * 500 - Server Error.  ### Special Resource Types  Cluster and KsqlCluster are special ResourceTypes because they grant resource-scoped roles like ResourceOwner and DeveloperManage limited access to cluster-level operations (for example, Describe Configs on Kafka clusters). These special resource types only accept LITERAL patterns with the values \"kafka-cluster\" and \"kql-cluster\", respectively.
 *
 * API version: v2alpha1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package mdsv2alpha1

import (
	_bytes "bytes"
	_context "context"
	"github.com/antihax/optional"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type RBACRoleDefinitionsApi interface {

	/*
	 * RoleDetail List the resourceType and operations allowed for a given role. Callable by Users.
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param roleName Role name to look up.
	 * @param optional nil or *RoleDetailOpts - Optional Parameters:
	 * @param "Namespace" (optional.String) -  Return the role definitions available in the specified namespace. If no namespace is specified, return the public roles. May be a comma-separated list.
	 * @return Role
	 */
	RoleDetail(ctx _context.Context, roleName string, localVarOptionals *RoleDetailOpts) (Role, *_nethttp.Response, error)

	/*
	 * Rolenames Returns the names of all the roles defined in the system. For information and developer purposes. Callable by Users.
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param optional nil or *RolenamesOpts - Optional Parameters:
	 * @param "Namespace" (optional.String) -  Return the role names available in the specified namespace. If no namespace is specified, return the public roles. May be a comma-separated list.
	 * @return []string
	 */
	Rolenames(ctx _context.Context, localVarOptionals *RolenamesOpts) ([]string, *_nethttp.Response, error)

	/*
	 * Roles Returns all the public roles defined in the system.  For information and developer purposes. Callable by Users.
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param optional nil or *RolesOpts - Optional Parameters:
	 * @param "Namespace" (optional.String) -  Return the role definitions available in the specified namespace. If no namespace is specified, return the public roles. May be a comma-separated list.
	 * @return []Role
	 */
	Roles(ctx _context.Context, localVarOptionals *RolesOpts) ([]Role, *_nethttp.Response, error)
}

// RBACRoleDefinitionsApiService RBACRoleDefinitionsApi service
type RBACRoleDefinitionsApiService service

// RoleDetailOpts Optional parameters for the method 'RoleDetail'
type RoleDetailOpts struct {
	Namespace optional.String
}

/*
 * RoleDetail List the resourceType and operations allowed for a given role. Callable by Users.
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param roleName Role name to look up.
 * @param optional nil or *RoleDetailOpts - Optional Parameters:
 * @param "Namespace" (optional.String) -  Return the role definitions available in the specified namespace. If no namespace is specified, return the public roles. May be a comma-separated list.
 * @return Role
 */
func (a *RBACRoleDefinitionsApiService) RoleDetail(ctx _context.Context, roleName string, localVarOptionals *RoleDetailOpts) (Role, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Role
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/roles/{roleName}"
	localVarPath = strings.Replace(localVarPath, "{"+"roleName"+"}", _neturl.PathEscape(parameterToString(roleName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Namespace.IsSet() {
		localVarQueryParams.Add("namespace", parameterToString(localVarOptionals.Namespace.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// RolenamesOpts Optional parameters for the method 'Rolenames'
type RolenamesOpts struct {
	Namespace optional.String
}

/*
 * Rolenames Returns the names of all the roles defined in the system. For information and developer purposes. Callable by Users.
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *RolenamesOpts - Optional Parameters:
 * @param "Namespace" (optional.String) -  Return the role names available in the specified namespace. If no namespace is specified, return the public roles. May be a comma-separated list.
 * @return []string
 */
func (a *RBACRoleDefinitionsApiService) Rolenames(ctx _context.Context, localVarOptionals *RolenamesOpts) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/roleNames"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Namespace.IsSet() {
		localVarQueryParams.Add("namespace", parameterToString(localVarOptionals.Namespace.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// RolesOpts Optional parameters for the method 'Roles'
type RolesOpts struct {
	Namespace optional.String
}

/*
 * Roles Returns all the public roles defined in the system.  For information and developer purposes. Callable by Users.
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *RolesOpts - Optional Parameters:
 * @param "Namespace" (optional.String) -  Return the role definitions available in the specified namespace. If no namespace is specified, return the public roles. May be a comma-separated list.
 * @return []Role
 */
func (a *RBACRoleDefinitionsApiService) Roles(ctx _context.Context, localVarOptionals *RolesOpts) ([]Role, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Role
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/roles"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Namespace.IsSet() {
		localVarQueryParams.Add("namespace", parameterToString(localVarOptionals.Namespace.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
