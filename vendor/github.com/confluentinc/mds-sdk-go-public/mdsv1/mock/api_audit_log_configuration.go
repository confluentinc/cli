// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: api_audit_log_configuration.go

package mock

import (
	context "context"
	net_http "net/http"
	sync "sync"

	github_com_confluentinc_mds_sdk_go_public_mdsv1 "github.com/confluentinc/mds-sdk-go-public/mdsv1"
)

// AuditLogConfigurationApi is a mock of AuditLogConfigurationApi interface
type AuditLogConfigurationApi struct {
	lockGetConfig sync.Mutex
	GetConfigFunc func(ctx context.Context) (github_com_confluentinc_mds_sdk_go_public_mdsv1.AuditLogConfigSpec, *net_http.Response, error)

	lockListRoutes sync.Mutex
	ListRoutesFunc func(ctx context.Context, localVarOptionals *github_com_confluentinc_mds_sdk_go_public_mdsv1.ListRoutesOpts) (github_com_confluentinc_mds_sdk_go_public_mdsv1.AuditLogConfigListRoutesResponse, *net_http.Response, error)

	lockPutConfig sync.Mutex
	PutConfigFunc func(ctx context.Context, auditLogConfigSpec github_com_confluentinc_mds_sdk_go_public_mdsv1.AuditLogConfigSpec) (github_com_confluentinc_mds_sdk_go_public_mdsv1.AuditLogConfigSpec, *net_http.Response, error)

	lockResolveResourceRoute sync.Mutex
	ResolveResourceRouteFunc func(ctx context.Context, localVarOptionals *github_com_confluentinc_mds_sdk_go_public_mdsv1.ResolveResourceRouteOpts) (github_com_confluentinc_mds_sdk_go_public_mdsv1.AuditLogConfigResolveResourceRouteResponse, *net_http.Response, error)

	calls struct {
		GetConfig []struct {
			Ctx context.Context
		}
		ListRoutes []struct {
			Ctx               context.Context
			LocalVarOptionals *github_com_confluentinc_mds_sdk_go_public_mdsv1.ListRoutesOpts
		}
		PutConfig []struct {
			Ctx                context.Context
			AuditLogConfigSpec github_com_confluentinc_mds_sdk_go_public_mdsv1.AuditLogConfigSpec
		}
		ResolveResourceRoute []struct {
			Ctx               context.Context
			LocalVarOptionals *github_com_confluentinc_mds_sdk_go_public_mdsv1.ResolveResourceRouteOpts
		}
	}
}

// GetConfig mocks base method by wrapping the associated func.
func (m *AuditLogConfigurationApi) GetConfig(ctx context.Context) (github_com_confluentinc_mds_sdk_go_public_mdsv1.AuditLogConfigSpec, *net_http.Response, error) {
	m.lockGetConfig.Lock()
	defer m.lockGetConfig.Unlock()

	if m.GetConfigFunc == nil {
		panic("mocker: AuditLogConfigurationApi.GetConfigFunc is nil but AuditLogConfigurationApi.GetConfig was called.")
	}

	call := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}

	m.calls.GetConfig = append(m.calls.GetConfig, call)

	return m.GetConfigFunc(ctx)
}

// GetConfigCalled returns true if GetConfig was called at least once.
func (m *AuditLogConfigurationApi) GetConfigCalled() bool {
	m.lockGetConfig.Lock()
	defer m.lockGetConfig.Unlock()

	return len(m.calls.GetConfig) > 0
}

// GetConfigCalls returns the calls made to GetConfig.
func (m *AuditLogConfigurationApi) GetConfigCalls() []struct {
	Ctx context.Context
} {
	m.lockGetConfig.Lock()
	defer m.lockGetConfig.Unlock()

	return m.calls.GetConfig
}

// ListRoutes mocks base method by wrapping the associated func.
func (m *AuditLogConfigurationApi) ListRoutes(ctx context.Context, localVarOptionals *github_com_confluentinc_mds_sdk_go_public_mdsv1.ListRoutesOpts) (github_com_confluentinc_mds_sdk_go_public_mdsv1.AuditLogConfigListRoutesResponse, *net_http.Response, error) {
	m.lockListRoutes.Lock()
	defer m.lockListRoutes.Unlock()

	if m.ListRoutesFunc == nil {
		panic("mocker: AuditLogConfigurationApi.ListRoutesFunc is nil but AuditLogConfigurationApi.ListRoutes was called.")
	}

	call := struct {
		Ctx               context.Context
		LocalVarOptionals *github_com_confluentinc_mds_sdk_go_public_mdsv1.ListRoutesOpts
	}{
		Ctx:               ctx,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.ListRoutes = append(m.calls.ListRoutes, call)

	return m.ListRoutesFunc(ctx, localVarOptionals)
}

// ListRoutesCalled returns true if ListRoutes was called at least once.
func (m *AuditLogConfigurationApi) ListRoutesCalled() bool {
	m.lockListRoutes.Lock()
	defer m.lockListRoutes.Unlock()

	return len(m.calls.ListRoutes) > 0
}

// ListRoutesCalls returns the calls made to ListRoutes.
func (m *AuditLogConfigurationApi) ListRoutesCalls() []struct {
	Ctx               context.Context
	LocalVarOptionals *github_com_confluentinc_mds_sdk_go_public_mdsv1.ListRoutesOpts
} {
	m.lockListRoutes.Lock()
	defer m.lockListRoutes.Unlock()

	return m.calls.ListRoutes
}

// PutConfig mocks base method by wrapping the associated func.
func (m *AuditLogConfigurationApi) PutConfig(ctx context.Context, auditLogConfigSpec github_com_confluentinc_mds_sdk_go_public_mdsv1.AuditLogConfigSpec) (github_com_confluentinc_mds_sdk_go_public_mdsv1.AuditLogConfigSpec, *net_http.Response, error) {
	m.lockPutConfig.Lock()
	defer m.lockPutConfig.Unlock()

	if m.PutConfigFunc == nil {
		panic("mocker: AuditLogConfigurationApi.PutConfigFunc is nil but AuditLogConfigurationApi.PutConfig was called.")
	}

	call := struct {
		Ctx                context.Context
		AuditLogConfigSpec github_com_confluentinc_mds_sdk_go_public_mdsv1.AuditLogConfigSpec
	}{
		Ctx:                ctx,
		AuditLogConfigSpec: auditLogConfigSpec,
	}

	m.calls.PutConfig = append(m.calls.PutConfig, call)

	return m.PutConfigFunc(ctx, auditLogConfigSpec)
}

// PutConfigCalled returns true if PutConfig was called at least once.
func (m *AuditLogConfigurationApi) PutConfigCalled() bool {
	m.lockPutConfig.Lock()
	defer m.lockPutConfig.Unlock()

	return len(m.calls.PutConfig) > 0
}

// PutConfigCalls returns the calls made to PutConfig.
func (m *AuditLogConfigurationApi) PutConfigCalls() []struct {
	Ctx                context.Context
	AuditLogConfigSpec github_com_confluentinc_mds_sdk_go_public_mdsv1.AuditLogConfigSpec
} {
	m.lockPutConfig.Lock()
	defer m.lockPutConfig.Unlock()

	return m.calls.PutConfig
}

// ResolveResourceRoute mocks base method by wrapping the associated func.
func (m *AuditLogConfigurationApi) ResolveResourceRoute(ctx context.Context, localVarOptionals *github_com_confluentinc_mds_sdk_go_public_mdsv1.ResolveResourceRouteOpts) (github_com_confluentinc_mds_sdk_go_public_mdsv1.AuditLogConfigResolveResourceRouteResponse, *net_http.Response, error) {
	m.lockResolveResourceRoute.Lock()
	defer m.lockResolveResourceRoute.Unlock()

	if m.ResolveResourceRouteFunc == nil {
		panic("mocker: AuditLogConfigurationApi.ResolveResourceRouteFunc is nil but AuditLogConfigurationApi.ResolveResourceRoute was called.")
	}

	call := struct {
		Ctx               context.Context
		LocalVarOptionals *github_com_confluentinc_mds_sdk_go_public_mdsv1.ResolveResourceRouteOpts
	}{
		Ctx:               ctx,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.ResolveResourceRoute = append(m.calls.ResolveResourceRoute, call)

	return m.ResolveResourceRouteFunc(ctx, localVarOptionals)
}

// ResolveResourceRouteCalled returns true if ResolveResourceRoute was called at least once.
func (m *AuditLogConfigurationApi) ResolveResourceRouteCalled() bool {
	m.lockResolveResourceRoute.Lock()
	defer m.lockResolveResourceRoute.Unlock()

	return len(m.calls.ResolveResourceRoute) > 0
}

// ResolveResourceRouteCalls returns the calls made to ResolveResourceRoute.
func (m *AuditLogConfigurationApi) ResolveResourceRouteCalls() []struct {
	Ctx               context.Context
	LocalVarOptionals *github_com_confluentinc_mds_sdk_go_public_mdsv1.ResolveResourceRouteOpts
} {
	m.lockResolveResourceRoute.Lock()
	defer m.lockResolveResourceRoute.Unlock()

	return m.calls.ResolveResourceRoute
}

// Reset resets the calls made to the mocked methods.
func (m *AuditLogConfigurationApi) Reset() {
	m.lockGetConfig.Lock()
	m.calls.GetConfig = nil
	m.lockGetConfig.Unlock()
	m.lockListRoutes.Lock()
	m.calls.ListRoutes = nil
	m.lockListRoutes.Unlock()
	m.lockPutConfig.Lock()
	m.calls.PutConfig = nil
	m.lockPutConfig.Unlock()
	m.lockResolveResourceRoute.Lock()
	m.calls.ResolveResourceRoute = nil
	m.lockResolveResourceRoute.Unlock()
}
