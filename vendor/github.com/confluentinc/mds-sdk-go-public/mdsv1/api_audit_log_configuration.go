/*
 * MDS API
 *
 * ## Confluent Metadata API - Swagger UI --- This tool (SwaggerUI) and the Open API spec file are provided _for development / test purposes only_:  - **Do _not_ enable in Production.** - **This tool only works with HTTP.**  ### Authenticating Authentication is performed by HTTP Basic Auth or by presenting a bearer token. In this UI, click **Authorize** to enter credentials.  To get a bearer token, first call the authenticate endpoint with basic auth, and then extract the auth_token part of the request, and pass that as the bearer token.  ### Access Restrictions - Who can call what?  Some endpoints can be called by any authenticated user, while others can only be called by \"admins\". Additionally, many of the endpoints in the API involve two users: the user who is calling the endpoint (the \"calling\" principal) and the user that the API call is about (the \"target\" principal).  Example: User \"alice\", who has the UserAdmin role, and is identifed by her basic auth credentials or a bearer token, calls the CRUD endpoint to modify role bindings about user \"bob\".  To document what access restrictions each endpoint has, use the following legend, which lists access in order from least restrictive to most restrictive:  *  **LDAP**: Any authenticated LDAP user *  **Admins+User**: Admins or the user requesting information about themself *  **Admins+ResourceOwners**: Admins or users with ResourceOwner role *  **Admins+AclUsers**: Admins or the user having the required ACL permissions *  **Admins**: Admins only, which can be UserAdmin, SystemAdmin, broker super.user, or SecurityAdmin as \"Read\"  ### Overview of Responses  **Valid**  * 200 - Successful call with a return body. * 204 - Sucessuful call with **no** return body.  **Errors**  * 400 - Invalid request.  JSON parsing error, or otherwise incorrect request. * 401 - Not Authenticated.  You need to pass valid basic auth credentials or a user bearer token. * 403 - Not Authorized.  Valid request, but you aren't authorized to perform the requested action. * 404 - Invalid URL.  If you get this error from the authenticate endpoint, it means bearer token authentication needs to be enabled in the configuration.     * ``confluent.metadata.server.authentication.method=BEARER`` * 405 - Method Not Allowed.  Using the wrong HTTP method on a valid endpoint (for example, GET instead of POST). * 409 - Conflict.  Adding a new resource or updating an existing resource which would result in a conflict with existing state.     * can be thrown by Audit Logs and Cluster Registry APIs * 415 - Invalid Content Type.  Usually, not sending \"application/json\" as request body header. * 500 - Server Error.  ### Special Resource Types  Cluster and KsqlCluster are special ResourceTypes because they grant resource-scoped roles like ResourceOwner and DeveloperManage limited access to cluster-level operations (for example, Describe Configs on Kafka clusters). These special resource types only accept LITERAL patterns with the values \"kafka-cluster\" and \"kql-cluster\", respectively.  ### Private RBAC UI Endpoints  These endpoints were developed specifically to power the Confluent Control Center UI. As such, they only focus on those use cases and have only been tested in the context of Confluent Control Center. These endpoints have not been tested, nor has their usability been evaluated with respect to manual API calls.
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package mdsv1

import (
	_bytes "bytes"
	_context "context"
	"github.com/antihax/optional"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

type AuditLogConfigurationApi interface {

	/*
	 * GetConfig Get the entire audit log configuration, including the live retention time policy values (``retention_ms``) for the destination topics.
	 *
	 * Requires the \&quot;AuditAdmin\&quot; role on the metadata service (MDS) cluster and every Kafka cluster in the cluster registry.  Callable by Admins.
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return AuditLogConfigSpec
	 */
	GetConfig(ctx _context.Context) (AuditLogConfigSpec, *_nethttp.Response, error)

	/*
	 * ListRoutes Lists all currently defined routes that match the queried resource or its sub-resources.
	 *
	 * Multiple routes may match a resource, but only the most specific route will be selected for events related to the resource. This endpoint returns all matching routes regardless of whether or not they would actually be selected, or ignored in favor of a more specific route.  Requires the \&quot;AuditAdmin\&quot; role on the metadata service (MDS) cluster and every Kafka cluster in the cluster registry.  Callable by Admins.  The CRN patterns in the audit log config routes can contain wildcards. So a route with a CRN pattern like &#x60;&#x60;crn://mds.example.com/kafka&#x3D;*_/topic&#x3D;finance-*&#x60;&#x60; would match events associated with the topic at address &#x60;&#x60;crn://mds.example.com/kafka&#x3D;abc123/topic&#x3D;finance-deposits&#x60;&#x60;, or events associated with the topic at &#x60;&#x60;crn://mds.example.com/kafka&#x3D;xyz789/topic&#x3D;finance-chargebacks&#x60;&#x60;, but would not match events associated with the topic &#x60;&#x60;crn://mds.example.com/kafka&#x3D;abc123/topic&#x3D;server-deployments&#x60;&#x60;. So a route&#39;s CRN pattern can match events from more than one resource, based on where the pattern&#39;s wildcards are.  It is possible to write multiple routes with different CRN patterns that match a given resource&#39;s CRN. For example: the resource at &#x60;&#x60;crn://mds.example.com/kafka&#x3D;abc123/topic&#x3D;finance-chargebacks&#x60;&#x60; is matched by any of the following route CRN patterns:  * &#x60;&#x60;crn://mds.example.com/kafka&#x3D;*_/topic&#x3D;*&#x60;&#x60; * &#x60;&#x60;crn://mds.example.com/kafka&#x3D;abc123/topic&#x3D;*&#x60;&#x60; * &#x60;&#x60;crn://mds.example.com/kafka&#x3D;*_/topic&#x3D;finance-*&#x60;&#x60;  When there are multiple matching routes for an event, we select the matching route with the most specific CRN pattern. The most specific CRN pattern is the one with the greatest length before its first wildcard. So in the above example, &#x60;&#x60;crn://mds.example.com/kafka&#x3D;abc123/topic&#x3D;*&#x60;&#x60; wins.  To break a tie, ignore the prefix that the patterns have in common. So, for example &#x60;&#x60;crn://mds.example.com/kafka&#x3D;*_/topic&#x3D;finance-*&#x60;&#x60; is more specific than &#x60;&#x60;crn://mds.example.com/kafka&#x3D;*_/topic&#x3D;*&#x60;&#x60;.  This endpoint lists all currently defined routes that match the queried resource or its sub-resources, regardless of whether or not they would actually be selected, or ignored in favor of a more specific route.  A query pattern like ...  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;abcde_FGHIJKL-01234567/connect&#x3D;qa-test&#x60;&#x60;  ... would match all of the following routes ...  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;abcde_FGHIJKL-01234567/connect&#x3D;qa-test/connector&#x3D;from-db4&#x60;&#x60;  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;abcde_FGHIJKL-01234567/connect&#x3D;qa-test/connector&#x3D;*&#x60;&#x60;  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;abcde_FGHIJKL-01234567/connect&#x3D;*_/connector&#x3D;*&#x60;&#x60;  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;abcde_FGHIJKL-01234567/connect&#x3D;qa-*&#x60;&#x60;  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;abcde_FGHIJKL-01234567/connect&#x3D;*&#x60;&#x60;  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;*_/connect&#x3D;qa-*&#x60;&#x60;  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;*_/connect&#x3D;qa-*_/connector&#x3D;*&#x60;&#x60;  ... but would not match any of these routes ...  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;*_/ksql&#x3D;*&#x60;&#x60;  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;abcde_FGHIJKL-01234567&#x60;&#x60;  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;abcde_FGHIJKL-01234567/connect&#x3D;stg-*&#x60;&#x60;  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;zyxwv-UTSRQPO_98765432/connect&#x3D;qa-*&#x60;&#x60;  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;abcde_FGHIJKL-01234567/topic&#x3D;qa-*&#x60;&#x60;
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param optional nil or *ListRoutesOpts - Optional Parameters:
	 * @param "Q" (optional.String) -  A Confluent resource name (CRN) .
	 * @return AuditLogConfigListRoutesResponse
	 */
	ListRoutes(ctx _context.Context, localVarOptionals *ListRoutesOpts) (AuditLogConfigListRoutesResponse, *_nethttp.Response, error)

	/*
	 * PutConfig Update the entire audit log configuration on the MDS cluster and all Kafka clusters known to the cluster registry.
	 *
	 * Also creates missing destination topics on the destination cluster and updates the retention time policy of destination topics, if necessary.  Requires the \&quot;AuditAdmin\&quot; role on the MDS cluster and every Kafka cluster in the cluster registry.  May result in a 409 conflict error status if the &#x60;&#x60;resource_version&#x60;&#x60; in the JSON body of the request does not match the current version.  Callable by Admins.
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param auditLogConfigSpec
	 * @return AuditLogConfigSpec
	 */
	PutConfig(ctx _context.Context, auditLogConfigSpec AuditLogConfigSpec) (AuditLogConfigSpec, *_nethttp.Response, error)

	/*
	 * ResolveResourceRoute Returns the route describing how messages regarding this CRN would be routed.
	 *
	 * Requires the \&quot;AuditAdmin\&quot; role on the metadata service (MDS) cluster and every Kafka cluster in the cluster registry.  The CRN patterns in the audit log config routes can contain wildcards. So a route with a CRN pattern like &#x60;&#x60;crn://mds.example.com/kafka&#x3D;*_/topic&#x3D;finance-*&#x60;&#x60; would match events associated with the topic at address &#x60;&#x60;crn://mds.example.com/kafka&#x3D;abc123/topic&#x3D;finance-deposits&#x60;&#x60;, or events associated with the topic at &#x60;&#x60;crn://mds.example.com/kafka&#x3D;xyz789/topic&#x3D;finance-chargebacks&#x60;&#x60;, but would not match events associated with the topic &#x60;&#x60;crn://mds.example.com/kafka&#x3D;abc123/topic&#x3D;server-deployments&#x60;&#x60;. So a route&#39;s CRN pattern can match events from more than one resource, based on where the pattern&#39;s wildcards are.  It is possible to write multiple routes with different CRN patterns that match a given resource&#39;s CRN. For example: the resource at &#x60;&#x60;crn://mds.example.com/kafka&#x3D;abc123/topic&#x3D;finance-chargebacks&#x60;&#x60; is matched by any of the following route CRN patterns:  * &#x60;&#x60;crn://mds.example.com/kafka&#x3D;*_/topic&#x3D;*&#x60;&#x60; * &#x60;&#x60;crn://mds.example.com/kafka&#x3D;abc123/topic&#x3D;*&#x60;&#x60; * &#x60;&#x60;crn://mds.example.com/kafka&#x3D;*_/topic&#x3D;finance-*&#x60;&#x60;  When there are multiple matching routes for an event, we select the matching route with the most specific CRN pattern. The most specific CRN pattern is the one with the greatest length before its first wildcard. So in the above example, &#x60;&#x60;crn://mds.example.com/kafka&#x3D;abc123/topic&#x3D;*&#x60;&#x60; wins.  To break a tie, ignore the prefix that the patterns have in common. So, for example &#x60;&#x60;crn://mds.example.com/kafka&#x3D;*_/topic&#x3D;finance-*&#x60;&#x60; is more specific than &#x60;&#x60;crn://mds.example.com/kafka&#x3D;*_/topic&#x3D;*&#x60;&#x60;.  This endpoint resolves the matching and precedence rules of all configured audit log routes for you, and returns the one selected (most specific) matching route describing how messages regarding the given CRN would be routed. Callable by Admins.
	 *
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param optional nil or *ResolveResourceRouteOpts - Optional Parameters:
	 * @param "Crn" (optional.String) -  A Confluent resource name (CRN).
	 * @return AuditLogConfigResolveResourceRouteResponse
	 */
	ResolveResourceRoute(ctx _context.Context, localVarOptionals *ResolveResourceRouteOpts) (AuditLogConfigResolveResourceRouteResponse, *_nethttp.Response, error)
}

// AuditLogConfigurationApiService AuditLogConfigurationApi service
type AuditLogConfigurationApiService service

/*
 * GetConfig Get the entire audit log configuration, including the live retention time policy values (``retention_ms``) for the destination topics.
 *
 * Requires the \&quot;AuditAdmin\&quot; role on the metadata service (MDS) cluster and every Kafka cluster in the cluster registry.  Callable by Admins.
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return AuditLogConfigSpec
 */
func (a *AuditLogConfigurationApiService) GetConfig(ctx _context.Context) (AuditLogConfigSpec, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AuditLogConfigSpec
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/security/1.0/audit/config"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ListRoutesOpts Optional parameters for the method 'ListRoutes'
type ListRoutesOpts struct {
	Q optional.String
}

/*
 * ListRoutes Lists all currently defined routes that match the queried resource or its sub-resources.
 *
 * Multiple routes may match a resource, but only the most specific route will be selected for events related to the resource. This endpoint returns all matching routes regardless of whether or not they would actually be selected, or ignored in favor of a more specific route.  Requires the \&quot;AuditAdmin\&quot; role on the metadata service (MDS) cluster and every Kafka cluster in the cluster registry.  Callable by Admins.  The CRN patterns in the audit log config routes can contain wildcards. So a route with a CRN pattern like &#x60;&#x60;crn://mds.example.com/kafka&#x3D;*_/topic&#x3D;finance-*&#x60;&#x60; would match events associated with the topic at address &#x60;&#x60;crn://mds.example.com/kafka&#x3D;abc123/topic&#x3D;finance-deposits&#x60;&#x60;, or events associated with the topic at &#x60;&#x60;crn://mds.example.com/kafka&#x3D;xyz789/topic&#x3D;finance-chargebacks&#x60;&#x60;, but would not match events associated with the topic &#x60;&#x60;crn://mds.example.com/kafka&#x3D;abc123/topic&#x3D;server-deployments&#x60;&#x60;. So a route&#39;s CRN pattern can match events from more than one resource, based on where the pattern&#39;s wildcards are.  It is possible to write multiple routes with different CRN patterns that match a given resource&#39;s CRN. For example: the resource at &#x60;&#x60;crn://mds.example.com/kafka&#x3D;abc123/topic&#x3D;finance-chargebacks&#x60;&#x60; is matched by any of the following route CRN patterns:  * &#x60;&#x60;crn://mds.example.com/kafka&#x3D;*_/topic&#x3D;*&#x60;&#x60; * &#x60;&#x60;crn://mds.example.com/kafka&#x3D;abc123/topic&#x3D;*&#x60;&#x60; * &#x60;&#x60;crn://mds.example.com/kafka&#x3D;*_/topic&#x3D;finance-*&#x60;&#x60;  When there are multiple matching routes for an event, we select the matching route with the most specific CRN pattern. The most specific CRN pattern is the one with the greatest length before its first wildcard. So in the above example, &#x60;&#x60;crn://mds.example.com/kafka&#x3D;abc123/topic&#x3D;*&#x60;&#x60; wins.  To break a tie, ignore the prefix that the patterns have in common. So, for example &#x60;&#x60;crn://mds.example.com/kafka&#x3D;*_/topic&#x3D;finance-*&#x60;&#x60; is more specific than &#x60;&#x60;crn://mds.example.com/kafka&#x3D;*_/topic&#x3D;*&#x60;&#x60;.  This endpoint lists all currently defined routes that match the queried resource or its sub-resources, regardless of whether or not they would actually be selected, or ignored in favor of a more specific route.  A query pattern like ...  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;abcde_FGHIJKL-01234567/connect&#x3D;qa-test&#x60;&#x60;  ... would match all of the following routes ...  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;abcde_FGHIJKL-01234567/connect&#x3D;qa-test/connector&#x3D;from-db4&#x60;&#x60;  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;abcde_FGHIJKL-01234567/connect&#x3D;qa-test/connector&#x3D;*&#x60;&#x60;  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;abcde_FGHIJKL-01234567/connect&#x3D;*_/connector&#x3D;*&#x60;&#x60;  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;abcde_FGHIJKL-01234567/connect&#x3D;qa-*&#x60;&#x60;  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;abcde_FGHIJKL-01234567/connect&#x3D;*&#x60;&#x60;  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;*_/connect&#x3D;qa-*&#x60;&#x60;  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;*_/connect&#x3D;qa-*_/connector&#x3D;*&#x60;&#x60;  ... but would not match any of these routes ...  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;*_/ksql&#x3D;*&#x60;&#x60;  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;abcde_FGHIJKL-01234567&#x60;&#x60;  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;abcde_FGHIJKL-01234567/connect&#x3D;stg-*&#x60;&#x60;  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;zyxwv-UTSRQPO_98765432/connect&#x3D;qa-*&#x60;&#x60;  &#x60;&#x60;crn://mds1.example.com/kafka&#x3D;abcde_FGHIJKL-01234567/topic&#x3D;qa-*&#x60;&#x60;
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ListRoutesOpts - Optional Parameters:
 * @param "Q" (optional.String) -  A Confluent resource name (CRN) .
 * @return AuditLogConfigListRoutesResponse
 */
func (a *AuditLogConfigurationApiService) ListRoutes(ctx _context.Context, localVarOptionals *ListRoutesOpts) (AuditLogConfigListRoutesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AuditLogConfigListRoutesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/security/1.0/audit/routes"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
 * PutConfig Update the entire audit log configuration on the MDS cluster and all Kafka clusters known to the cluster registry.
 *
 * Also creates missing destination topics on the destination cluster and updates the retention time policy of destination topics, if necessary.  Requires the \&quot;AuditAdmin\&quot; role on the MDS cluster and every Kafka cluster in the cluster registry.  May result in a 409 conflict error status if the &#x60;&#x60;resource_version&#x60;&#x60; in the JSON body of the request does not match the current version.  Callable by Admins.
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param auditLogConfigSpec
 * @return AuditLogConfigSpec
 */
func (a *AuditLogConfigurationApiService) PutConfig(ctx _context.Context, auditLogConfigSpec AuditLogConfigSpec) (AuditLogConfigSpec, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AuditLogConfigSpec
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/security/1.0/audit/config"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &auditLogConfigSpec
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v AuditLogConfigSpec
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ResolveResourceRouteOpts Optional parameters for the method 'ResolveResourceRoute'
type ResolveResourceRouteOpts struct {
	Crn optional.String
}

/*
 * ResolveResourceRoute Returns the route describing how messages regarding this CRN would be routed.
 *
 * Requires the \&quot;AuditAdmin\&quot; role on the metadata service (MDS) cluster and every Kafka cluster in the cluster registry.  The CRN patterns in the audit log config routes can contain wildcards. So a route with a CRN pattern like &#x60;&#x60;crn://mds.example.com/kafka&#x3D;*_/topic&#x3D;finance-*&#x60;&#x60; would match events associated with the topic at address &#x60;&#x60;crn://mds.example.com/kafka&#x3D;abc123/topic&#x3D;finance-deposits&#x60;&#x60;, or events associated with the topic at &#x60;&#x60;crn://mds.example.com/kafka&#x3D;xyz789/topic&#x3D;finance-chargebacks&#x60;&#x60;, but would not match events associated with the topic &#x60;&#x60;crn://mds.example.com/kafka&#x3D;abc123/topic&#x3D;server-deployments&#x60;&#x60;. So a route&#39;s CRN pattern can match events from more than one resource, based on where the pattern&#39;s wildcards are.  It is possible to write multiple routes with different CRN patterns that match a given resource&#39;s CRN. For example: the resource at &#x60;&#x60;crn://mds.example.com/kafka&#x3D;abc123/topic&#x3D;finance-chargebacks&#x60;&#x60; is matched by any of the following route CRN patterns:  * &#x60;&#x60;crn://mds.example.com/kafka&#x3D;*_/topic&#x3D;*&#x60;&#x60; * &#x60;&#x60;crn://mds.example.com/kafka&#x3D;abc123/topic&#x3D;*&#x60;&#x60; * &#x60;&#x60;crn://mds.example.com/kafka&#x3D;*_/topic&#x3D;finance-*&#x60;&#x60;  When there are multiple matching routes for an event, we select the matching route with the most specific CRN pattern. The most specific CRN pattern is the one with the greatest length before its first wildcard. So in the above example, &#x60;&#x60;crn://mds.example.com/kafka&#x3D;abc123/topic&#x3D;*&#x60;&#x60; wins.  To break a tie, ignore the prefix that the patterns have in common. So, for example &#x60;&#x60;crn://mds.example.com/kafka&#x3D;*_/topic&#x3D;finance-*&#x60;&#x60; is more specific than &#x60;&#x60;crn://mds.example.com/kafka&#x3D;*_/topic&#x3D;*&#x60;&#x60;.  This endpoint resolves the matching and precedence rules of all configured audit log routes for you, and returns the one selected (most specific) matching route describing how messages regarding the given CRN would be routed. Callable by Admins.
 *
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ResolveResourceRouteOpts - Optional Parameters:
 * @param "Crn" (optional.String) -  A Confluent resource name (CRN).
 * @return AuditLogConfigResolveResourceRouteResponse
 */
func (a *AuditLogConfigurationApiService) ResolveResourceRoute(ctx _context.Context, localVarOptionals *ResolveResourceRouteOpts) (AuditLogConfigResolveResourceRouteResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AuditLogConfigResolveResourceRouteResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/security/1.0/audit/lookup"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Crn.IsSet() {
		localVarQueryParams.Add("crn", parameterToString(localVarOptionals.Crn.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
